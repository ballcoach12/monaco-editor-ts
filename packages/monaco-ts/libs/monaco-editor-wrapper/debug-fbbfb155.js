import { _ as E, a as g, K as W, aQ as A, N as c, p as G, eM as xo, eN as Bo, c8 as Pn, ez as w, eO as Da, U as ee, S as Pe, eP as Ea, eQ as To, a3 as Wt, d3 as Fn, eR as yt, b1 as pe, a4 as nt, an as v, a0 as Ee, d0 as Ao, n as se, aY as Ie, e as re, aJ as _e, da as Dt, a8 as ni, b8 as Et, cx as Vn, D as ae, eS as Q, eT as Ia, eU as Lo, eV as _a, r as Ae, c1 as ye, eW as je, eX as xe, x as Wn, y as si, eY as Mi, eZ as Ni, e_ as xa, e$ as Ba, f as Un, h as Je, bx as It, f0 as le, f1 as Gt, f2 as $e, f3 as Ta, dj as fe, a_ as Le, f4 as Me, dC as K, f5 as Aa, es as Ri, f6 as La, f7 as Hn, f8 as Ma, I as $n, f9 as Ye, L as oe, cZ as Mo, fa as qe, ag as Na, fb as st, fc as Fe, aG as R, b_ as oi, fd as _t, cj as Re, aH as F, aI as y, fe as No, aE as Xe, aD as te, ff as Oe, d6 as Ro, fg as q, fh as Oo, fi as me, fj as Po, fk as Ra, aZ as xt, a$ as Fo, fl as Vo, fm as Oa, fn as Wo, fo as Pa, bf as qn, bB as x, ai as I, fp as Qe, E as ri, b7 as Fa, g as Kn, H as Va, fq as Wa, fr as Ut, fs as Ua, ah as C, ft as Uo, fu as Ho, ap as ne, d as z, as as Ha, V as ai, cX as $a, fv as qa, k as $o, fw as Ka, fx as za, fy as he, fz as ge, fA as Ga, fB as Ps, fC as qo, aK as zn, cd as Ko, fD as ja, fE as Xa, fF as zo, fG as Ja, fH as Go, C as Bt, bv as jo, fI as Xo, bZ as Ya, fJ as Qa, au as Za, fK as ed, fL as td, fM as id, fN as jt, fO as Jo, fP as nd, fQ as di, fR as sd, eB as od, eC as rd, b6 as J, fS as ad, fT as Gn, fU as dd, fV as cd, fW as ud, fX as Yo, fY as ot, fZ as Oi, f_ as ld, f$ as hd, g0 as gd, g1 as Qo, cw as Zo, g2 as pd, g3 as fd, g4 as bd, g5 as md, g6 as Sd, g7 as vd, g8 as wd, g9 as Tt, ga as kd, gb as Fs, cc as er, ce as Cd, gc as Vs, gd as yd, eb as Dd, cC as Ed, ge as Id, gf as M, gg as _d, ae as Ws, af as Us, s as xd, aL as tr, cm as At, bj as Lt, bz as rt, bX as Ce, gh as ir, cS as nr, gi as Bd, ax as O, bs as k, am as sr, cr as or, bT as We, cs as rr, bO as Z, ct as Td, bN as H, ei as Ad, gj as Ld, bS as Md, bu as at, gk as ar, gl as Nd, ba as jn, o as Mt, gm as Hs, gn as dr, go as Rd, gp as Od, bm as Ke, gq as U, gr as Pd, gs as Fd, d1 as $s, gt as Vd, gu as cr, co as Wd, cp as Ud, Q as Hd, gv as qs, gw as Xn, gx as ur, ch as $d, gy as qd, c2 as Kd, gz as zd, aW as He, aV as ve, gA as dt, gB as Ue, gC as lr, gD as ci, gE as ct, bV as ut, gF as Gd, gG as jd, gH as Nt, gI as Jn, gJ as Yn, gK as Qn, gL as Xd, gM as Jd, gN as Yd, gO as Qd, gP as Zd, gQ as ec, gR as Rt, bD as tc, gS as hr, gT as gr, gU as pr, gV as Zn, gW as ic, gX as fr, gY as nc, gZ as sc, g_ as es, dg as br, g$ as ts, bp as oc, h0 as Ot, h1 as mr, h2 as B, bg as rc, e4 as ac, h3 as dc, h4 as mi, ef as Sr, h5 as Pi, h6 as cc, h7 as uc, a5 as vr, h8 as Ks, h9 as is, ha as ns, hb as ui, hc as zs, hd as Si, he as Ht, hf as lc, hg as hc, hh as gc, hi as pc, br as fc, hj as bc, hk as mc, a9 as wr, hl as Sc, hm as vc, aC as wc, bL as kc, c4 as Cc, hn as yc, ho as Dc, hp as Gs, hq as Ec, b4 as ss, dL as Ic, hr as js, hs as _c, ht as xc, hu as Bc, hv as Tc, hw as Ac, bi as Lc, hx as Mc, hy as Xs, hz as Nc, hA as Rc, bU as kr, hB as Oc, hC as Pc, hD as Cr, hE as Fc, hF as Vc, hG as Wc, cW as Uc, hH as Js, hI as yr, hJ as Ys, hK as Hc, hL as Qs, hM as Zs, hN as $c, hO as qc, aj as eo, hP as Kc, cn as to, hQ as io, hR as zc, hS as Gc, ak as jc, ci as Xc, hT as no, hU as Jc, hV as Yc, hW as Qc, hX as Zc, cA as eu, hY as tu, bW as iu, bK as nu, b as su, hZ as ou, h_ as ru, by as Dr, bA as Er, d5 as au, c9 as du, bC as vi } from "./verifyPrepare-e26a1ce7.js";
import { P as cu, n as so, o as uu } from "./theme-0816311d.js";
import { g as lu, S as hu } from "./snippetsService-087b62ae.js";
import "./languageService-f5f48ab9.js";
let Fi = class {
  constructor(e, t) {
    this.breakpointContribution = e, this.contextKeyService = t, this.breakpointsWhen = typeof e.when == "string" ? A.deserialize(e.when) : void 0;
  }
  get language() {
    return this.breakpointContribution.language;
  }
  get enabled() {
    return !this.breakpointsWhen || this.contextKeyService.contextMatchesRules(this.breakpointsWhen);
  }
};
Fi = E([
  g(1, W)
], Fi);
function gu(d) {
  d.pattern = d.pattern || "^(?!.*\\$\\{(env|config|command)\\.)", d.patternErrorMessage = d.patternErrorMessage || c(
    "deprecatedVariables",
    "'env.', 'config.' and 'command.' are deprecated, use 'env:', 'config:' and 'command:' instead."
  );
}
let Vi = class {
  constructor(e, t, i, n, s, o, r, a, u) {
    this.adapterManager = e, this.configurationService = n, this.resourcePropertiesService = s, this.configurationResolverService = o, this.environmentService = r, this.debugService = a, this.contextKeyService = u, this.mergedExtensionDescriptions = [], this.debuggerContribution = { type: t.type }, this.merge(t, i), this.debuggerWhen = typeof this.debuggerContribution.when == "string" ? A.deserialize(this.debuggerContribution.when) : void 0;
  }
  merge(e, t) {
    function i(n, s, o, r = 0) {
      return Wt(n) ? (Wt(s) && Object.keys(s).forEach((a) => {
        a !== "__proto__" && (Wt(n[a]) && Wt(s[a]) ? i(n[a], s[a], o, r + 1) : a in n ? o && (r === 0 && a === "type" || (n[a] = s[a])) : n[a] = s[a]);
      }), n) : s;
    }
    this.mergedExtensionDescriptions.indexOf(t) < 0 && (this.mergedExtensionDescriptions.push(t), i(this.debuggerContribution, e, t.isBuiltin), Da(e) && (this.mainExtensionDescription = t));
  }
  async startDebugging(e, t) {
    const i = this.debugService.getModel().getSession(t);
    return await this.debugService.startDebugging(void 0, e, { parentSession: i }, void 0);
  }
  async createDebugAdapter(e) {
    await this.adapterManager.activateDebuggers("onDebugAdapterProtocolTracker", this.type);
    const t = this.adapterManager.createDebugAdapter(e);
    if (t)
      return Promise.resolve(t);
    throw new Error(c("cannot.find.da", "Cannot find debug adapter for type '{0}'.", this.type));
  }
  async substituteVariables(e, t) {
    const i = await this.adapterManager.substituteVariables(this.type, e, t);
    return await this.configurationResolverService.resolveWithInteractionReplace(e, i, "launch", this.variables, i.__configurationTarget);
  }
  runInTerminal(e, t) {
    return this.adapterManager.runInTerminal(this.type, e, t);
  }
  get label() {
    return this.debuggerContribution.label || this.debuggerContribution.type;
  }
  get type() {
    return this.debuggerContribution.type;
  }
  get variables() {
    return this.debuggerContribution.variables;
  }
  get configurationSnippets() {
    return this.debuggerContribution.configurationSnippets;
  }
  get languages() {
    return this.debuggerContribution.languages;
  }
  get when() {
    return this.debuggerWhen;
  }
  get enabled() {
    return !this.debuggerWhen || this.contextKeyService.contextMatchesRules(this.debuggerWhen);
  }
  get strings() {
    return this.debuggerContribution.strings ?? this.debuggerContribution.uiMessages;
  }
  interestedInLanguage(e) {
    return !!(this.languages && this.languages.indexOf(e) >= 0);
  }
  hasInitialConfiguration() {
    return !!this.debuggerContribution.initialConfigurations;
  }
  hasConfigurationProvider() {
    return this.debugService.getConfigurationManager().hasDebugConfigurationProvider(this.type);
  }
  getInitialConfigurationContent(e) {
    let t = this.debuggerContribution.initialConfigurations || [];
    e && (t = t.concat(e));
    const i = this.resourcePropertiesService.getEOL(ee.from({ scheme: Pe.untitled, path: "1" })) === `\r
` ? `\r
` : `
`, n = JSON.stringify(t, null, "	").split(`
`).map((l) => "	" + l).join(i).trim(), s = c(
      "launch.config.comment1",
      "Use IntelliSense to learn about possible attributes."
    ), o = c(
      "launch.config.comment2",
      "Hover to view descriptions of existing attributes."
    ), r = c(
      "launch.config.comment3",
      "For more information, visit: {0}",
      "https://go.microsoft.com/fwlink/?linkid=830387"
    );
    let a = [
      "{",
      `	// ${s}`,
      `	// ${o}`,
      `	// ${r}`,
      '	"version": "0.2.0",',
      `	"configurations": ${n}`,
      "}"
    ].join(i);
    const u = this.configurationService.getValue();
    return u.editor && u.editor.insertSpaces && (a = a.replace(new RegExp("	", "g"), " ".repeat(u.editor.tabSize))), Promise.resolve(a);
  }
  getMainExtensionDescriptor() {
    return this.mainExtensionDescription || this.mergedExtensionDescriptions[0];
  }
  getCustomTelemetryEndpoint() {
    const e = this.debuggerContribution.aiKey;
    if (!e)
      return;
    const t = Ea(this.environmentService.remoteAuthority) !== "other";
    return {
      id: `${this.getMainExtensionDescriptor().publisher}.${this.type}`,
      aiKey: e,
      sendErrorTelemetry: t
    };
  }
  getSchemaAttributes(e) {
    return this.debuggerContribution.configurationAttributes ? Object.keys(this.debuggerContribution.configurationAttributes).map((t) => {
      const i = `${this.type}:${t}`, n = this.debuggerContribution.configurationAttributes[t], s = ["name", "type", "request"];
      n.required = n.required && n.required.length ? s.concat(n.required) : s, n.additionalProperties = !1, n.type = "object", n.properties || (n.properties = {});
      const o = n.properties;
      o.type = {
        enum: [this.type],
        enumDescriptions: [this.label],
        description: c("debugType", "Type of configuration."),
        pattern: "^(?!node2)",
        deprecationMessage: this.debuggerContribution.deprecated || (this.enabled ? void 0 : To(this.type)),
        doNotSuggest: !!this.debuggerContribution.deprecated,
        errorMessage: c(
          "debugTypeNotRecognised",
          "The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled."
        ),
        patternErrorMessage: c(
          "node2NotSupported",
          '"node2" is no longer supported, use "node" instead and set the "protocol" attribute to "inspector".'
        )
      }, o.request = {
        enum: [t],
        description: c(
          "debugRequest",
          'Request type of configuration. Can be "launch" or "attach".'
        )
      };
      for (const a in e.common.properties)
        o[a] = {
          $ref: `#/definitions/common/properties/${a}`
        };
      Object.keys(o).forEach((a) => {
        gu(o[a]);
      }), e[i] = { ...n };
      const r = { ...n };
      return r.properties = {
        ...o,
        windows: {
          $ref: `#/definitions/${i}`,
          description: c(
            "debugWindowsConfiguration",
            "Windows specific launch configuration attributes."
          ),
          required: []
        },
        osx: {
          $ref: `#/definitions/${i}`,
          description: c("debugOSXConfiguration", "OS X specific launch configuration attributes."),
          required: []
        },
        linux: {
          $ref: `#/definitions/${i}`,
          description: c(
            "debugLinuxConfiguration",
            "Linux specific launch configuration attributes."
          ),
          required: []
        }
      }, r;
    }) : null;
  }
};
Vi = E([
  g(3, G),
  g(4, xo),
  g(5, Bo),
  g(6, Pn),
  g(7, w),
  g(8, W)
], Vi);
const wi = c(
  "JsonSchema.input.id",
  "The input's id is used to associate an input with a variable of the form ${input:id}."
), ki = c("JsonSchema.input.type", "The type of user input prompt to use."), oo = c(
  "JsonSchema.input.description",
  "The description is shown when the user is prompted for input."
), ro = c("JsonSchema.input.default", "The default value for the input."), pu = {
  definitions: {
    inputs: {
      type: "array",
      description: c(
        "JsonSchema.inputs",
        "User inputs. Used for defining user input prompts, such as free string input or a choice from several options."
      ),
      items: {
        oneOf: [
          {
            type: "object",
            required: ["id", "type", "description"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: wi
              },
              type: {
                type: "string",
                description: ki,
                enum: ["promptString"],
                enumDescriptions: [
                  c(
                    "JsonSchema.input.type.promptString",
                    "The 'promptString' type opens an input box to ask the user for input."
                  )
                ]
              },
              description: {
                type: "string",
                description: oo
              },
              default: {
                type: "string",
                description: ro
              },
              password: {
                type: "boolean",
                description: c(
                  "JsonSchema.input.password",
                  "Controls if a password input is shown. Password input hides the typed text."
                )
              }
            }
          },
          {
            type: "object",
            required: ["id", "type", "description", "options"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: wi
              },
              type: {
                type: "string",
                description: ki,
                enum: ["pickString"],
                enumDescriptions: [
                  c(
                    "JsonSchema.input.type.pickString",
                    "The 'pickString' type shows a selection list."
                  )
                ]
              },
              description: {
                type: "string",
                description: oo
              },
              default: {
                type: "string",
                description: ro
              },
              options: {
                type: "array",
                description: c(
                  "JsonSchema.input.options",
                  "An array of strings that defines the options for a quick pick."
                ),
                items: {
                  oneOf: [
                    {
                      type: "string"
                    },
                    {
                      type: "object",
                      required: ["value"],
                      additionalProperties: !1,
                      properties: {
                        label: {
                          type: "string",
                          description: c("JsonSchema.input.pickString.optionLabel", "Label for the option.")
                        },
                        value: {
                          type: "string",
                          description: c("JsonSchema.input.pickString.optionValue", "Value for the option.")
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          {
            type: "object",
            required: ["id", "type", "command"],
            additionalProperties: !1,
            properties: {
              id: {
                type: "string",
                description: wi
              },
              type: {
                type: "string",
                description: ki,
                enum: ["command"],
                enumDescriptions: [
                  c("JsonSchema.input.type.command", "The 'command' type executes a command.")
                ]
              },
              command: {
                type: "string",
                description: c(
                  "JsonSchema.input.command.command",
                  "The command to execute for this input variable."
                )
              },
              args: {
                oneOf: [
                  {
                    type: "object",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  },
                  {
                    type: "array",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  },
                  {
                    type: "string",
                    description: c(
                      "JsonSchema.input.command.args",
                      "Optional arguments passed to the command."
                    )
                  }
                ]
              }
            }
          }
        ]
      }
    }
  }
}, fu = Fn.registerExtensionPoint({
  extensionPoint: "debuggers",
  defaultExtensionKind: ["workspace"],
  jsonSchema: {
    description: c("vscode.extension.contributes.debuggers", "Contributes debug adapters."),
    type: "array",
    defaultSnippets: [{ body: [{ type: "" }] }],
    items: {
      additionalProperties: !1,
      type: "object",
      defaultSnippets: [{ body: { type: "", program: "", runtime: "" } }],
      properties: {
        type: {
          description: c(
            "vscode.extension.contributes.debuggers.type",
            "Unique identifier for this debug adapter."
          ),
          type: "string"
        },
        label: {
          description: c(
            "vscode.extension.contributes.debuggers.label",
            "Display name for this debug adapter."
          ),
          type: "string"
        },
        program: {
          description: c(
            "vscode.extension.contributes.debuggers.program",
            "Path to the debug adapter program. Path is either absolute or relative to the extension folder."
          ),
          type: "string"
        },
        args: {
          description: c(
            "vscode.extension.contributes.debuggers.args",
            "Optional arguments to pass to the adapter."
          ),
          type: "array"
        },
        runtime: {
          description: c(
            "vscode.extension.contributes.debuggers.runtime",
            "Optional runtime in case the program attribute is not an executable but requires a runtime."
          ),
          type: "string"
        },
        runtimeArgs: {
          description: c(
            "vscode.extension.contributes.debuggers.runtimeArgs",
            "Optional runtime arguments."
          ),
          type: "array"
        },
        variables: {
          description: c(
            "vscode.extension.contributes.debuggers.variables",
            "Mapping from interactive variables (e.g. ${action.pickProcess}) in `launch.json` to a command."
          ),
          type: "object"
        },
        initialConfigurations: {
          description: c(
            "vscode.extension.contributes.debuggers.initialConfigurations",
            "Configurations for generating the initial 'launch.json'."
          ),
          type: ["array", "string"]
        },
        languages: {
          description: c(
            "vscode.extension.contributes.debuggers.languages",
            'List of languages for which the debug extension could be considered the "default debugger".'
          ),
          type: "array"
        },
        configurationSnippets: {
          description: c(
            "vscode.extension.contributes.debuggers.configurationSnippets",
            "Snippets for adding new configurations in 'launch.json'."
          ),
          type: "array"
        },
        configurationAttributes: {
          description: c(
            "vscode.extension.contributes.debuggers.configurationAttributes",
            "JSON schema configurations for validating 'launch.json'."
          ),
          type: "object"
        },
        when: {
          description: c(
            "vscode.extension.contributes.debuggers.when",
            "Condition which must be true to enable this type of debugger. Consider using 'shellExecutionSupported', 'virtualWorkspace', 'resourceScheme' or an extension-defined context key as appropriate for this."
          ),
          type: "string",
          default: ""
        },
        deprecated: {
          description: c(
            "vscode.extension.contributes.debuggers.deprecated",
            "Optional message to mark this debug type as being deprecated."
          ),
          type: "string",
          default: ""
        },
        windows: {
          description: c(
            "vscode.extension.contributes.debuggers.windows",
            "Windows specific settings."
          ),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.windows.runtime",
                "Runtime used for Windows."
              ),
              type: "string"
            }
          }
        },
        osx: {
          description: c("vscode.extension.contributes.debuggers.osx", "macOS specific settings."),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.osx.runtime",
                "Runtime used for macOS."
              ),
              type: "string"
            }
          }
        },
        linux: {
          description: c("vscode.extension.contributes.debuggers.linux", "Linux specific settings."),
          type: "object",
          properties: {
            runtime: {
              description: c(
                "vscode.extension.contributes.debuggers.linux.runtime",
                "Runtime used for Linux."
              ),
              type: "string"
            }
          }
        },
        strings: {
          description: c(
            "vscode.extension.contributes.debuggers.strings",
            "UI strings contributed by this debug adapter."
          ),
          type: "object",
          properties: {
            unverifiedBreakpoints: {
              description: c(
                "vscode.extension.contributes.debuggers.strings.unverifiedBreakpoints",
                "When there are unverified breakpoints in a language supported by this debug adapter, this message will appear on the breakpoint hover and in the breakpoints view. Markdown and command links are supported."
              ),
              type: "string"
            }
          }
        }
      }
    }
  }
}), bu = Fn.registerExtensionPoint({
  extensionPoint: "breakpoints",
  jsonSchema: {
    description: c("vscode.extension.contributes.breakpoints", "Contributes breakpoints."),
    type: "array",
    defaultSnippets: [{ body: [{ language: "" }] }],
    items: {
      type: "object",
      additionalProperties: !1,
      defaultSnippets: [{ body: { language: "" } }],
      properties: {
        language: {
          description: c(
            "vscode.extension.contributes.breakpoints.language",
            "Allow breakpoints for this language."
          ),
          type: "string"
        },
        when: {
          description: c(
            "vscode.extension.contributes.breakpoints.when",
            "Condition which must be true to enable breakpoints in this language. Consider matching this to the debugger when clause as appropriate."
          ),
          type: "string",
          default: ""
        }
      }
    }
  }
}), Ir = {
  type: "object",
  description: c(
    "presentation",
    "Presentation options on how to show this configuration in the debug configuration dropdown and the command palette."
  ),
  properties: {
    hidden: {
      type: "boolean",
      default: !1,
      description: c(
        "presentation.hidden",
        "Controls if this configuration should be shown in the configuration dropdown and the command palette."
      )
    },
    group: {
      type: "string",
      default: "",
      description: c(
        "presentation.group",
        "Group that this configuration belongs to. Used for grouping and sorting in the configuration dropdown and the command palette."
      )
    },
    order: {
      type: "number",
      default: 1,
      description: c(
        "presentation.order",
        "Order of this configuration within a group. Used for grouping and sorting in the configuration dropdown and the command palette."
      )
    }
  },
  default: {
    hidden: !1,
    group: "",
    order: 1
  }
}, ao = { name: "Compound", configurations: [] }, tt = {
  id: yt,
  type: "object",
  title: c("app.launch.json.title", "Launch"),
  allowTrailingCommas: !0,
  allowComments: !0,
  required: [],
  default: { version: "0.2.0", configurations: [], compounds: [] },
  properties: {
    version: {
      type: "string",
      description: c("app.launch.json.version", "Version of this file format."),
      default: "0.2.0"
    },
    configurations: {
      type: "array",
      description: c(
        "app.launch.json.configurations",
        "List of configurations. Add new configurations or edit existing ones by using IntelliSense."
      ),
      items: {
        defaultSnippets: [],
        type: "object",
        oneOf: []
      }
    },
    compounds: {
      type: "array",
      description: c(
        "app.launch.json.compounds",
        "List of compounds. Each compound references multiple configurations which will get launched together."
      ),
      items: {
        type: "object",
        required: ["name", "configurations"],
        properties: {
          name: {
            type: "string",
            description: c(
              "app.launch.json.compound.name",
              "Name of compound. Appears in the launch configuration drop down menu."
            )
          },
          presentation: Ir,
          configurations: {
            type: "array",
            default: [],
            items: {
              oneOf: [{
                enum: [],
                description: c("useUniqueNames", "Please use unique configuration names.")
              }, {
                type: "object",
                required: ["name"],
                properties: {
                  name: {
                    enum: [],
                    description: c(
                      "app.launch.json.compound.name",
                      "Name of compound. Appears in the launch configuration drop down menu."
                    )
                  },
                  folder: {
                    enum: [],
                    description: c(
                      "app.launch.json.compound.folder",
                      "Name of folder in which the compound is located."
                    )
                  }
                }
              }]
            },
            description: c(
              "app.launch.json.compounds.configurations",
              "Names of configurations that will be started as part of this compound."
            )
          },
          stopAll: {
            type: "boolean",
            default: !1,
            description: c(
              "app.launch.json.compound.stopAll",
              "Controls whether manually terminating one session will stop all of the compound sessions."
            )
          },
          preLaunchTask: {
            type: "string",
            default: "",
            description: c(
              "compoundPrelaunchTask",
              "Task to run before any of the compound configurations start."
            )
          }
        },
        default: ao
      },
      default: [
        ao
      ]
    },
    inputs: pu.definitions.inputs
  }
}, mu = {
  type: "object",
  additionalProperties: !1,
  properties: {
    type: {
      type: "string",
      description: c(
        "TaskDefinition.description",
        "The actual task type. Please note that types starting with a '$' are reserved for internal usage."
      )
    },
    required: {
      type: "array",
      items: {
        type: "string"
      }
    },
    properties: {
      type: "object",
      description: c("TaskDefinition.properties", "Additional properties of the task type"),
      additionalProperties: {
        $ref: "http://json-schema.org/draft-07/schema#"
      }
    },
    when: {
      type: "string",
      markdownDescription: c(
        "TaskDefinition.when",
        "Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information."
      ),
      default: ""
    }
  }
};
var Wi;
(function(d) {
  function e(t, i, n) {
    if (!t)
      return;
    const s = pe(t.type) ? t.type : void 0;
    if (!s || s.length === 0) {
      n.error(c(
        "TaskTypeConfiguration.noType",
        "The task type configuration is missing the required 'taskType' property"
      ));
      return;
    }
    const o = [];
    if (Array.isArray(t.required))
      for (const r of t.required)
        pe(r) && o.push(r);
    return {
      extensionId: i.value,
      taskType: s,
      required: o,
      properties: t.properties ? nt(t.properties) : {},
      when: t.when ? A.deserialize(t.when) : void 0
    };
  }
  d.from = e;
})(Wi || (Wi = {}));
const Su = Fn.registerExtensionPoint({
  extensionPoint: "taskDefinitions",
  activationEventsGenerator: (d, e) => {
    for (const t of d)
      t.type && e.push(`onTaskType:${t.type}`);
  },
  jsonSchema: {
    description: c("TaskDefinitionExtPoint", "Contributes task kinds"),
    type: "array",
    items: mu
  }
});
class vu {
  constructor() {
    this._onDefinitionsChanged = new v(), this.onDefinitionsChanged = this._onDefinitionsChanged.event, this.taskTypes = /* @__PURE__ */ Object.create(null), this.readyPromise = new Promise((e, t) => {
      Su.setHandler((i, n) => {
        this._schema = void 0;
        try {
          for (const s of n.removed) {
            const o = s.value;
            for (const r of o)
              this.taskTypes && r.type && this.taskTypes[r.type] && delete this.taskTypes[r.type];
          }
          for (const s of n.added) {
            const o = s.value;
            for (const r of o) {
              const a = Wi.from(r, s.description.identifier, s.collector);
              a && (this.taskTypes[a.taskType] = a);
            }
          }
          (n.removed.length > 0 || n.added.length > 0) && this._onDefinitionsChanged.fire();
        } catch {
        }
        e(void 0);
      });
    });
  }
  onReady() {
    return this.readyPromise;
  }
  get(e) {
    return this.taskTypes[e];
  }
  all() {
    return Object.keys(this.taskTypes).map((e) => this.taskTypes[e]);
  }
  getJsonSchema() {
    if (this._schema === void 0) {
      const e = [];
      for (const t of this.all()) {
        const i = {
          type: "object",
          additionalProperties: !1
        };
        t.required.length > 0 && (i.required = t.required.slice(0)), t.properties !== void 0 ? i.properties = nt(t.properties) : i.properties = /* @__PURE__ */ Object.create(null), i.properties.type = {
          type: "string",
          enum: [t.taskType]
        }, e.push(i);
      }
      this._schema = { oneOf: e };
    }
    return this._schema;
  }
}
const wu = new vu(), ku = Ee.as(Ao.JSONContribution);
let Ui = class extends ae {
  constructor(e, t, i, n, s, o, r, a, u, l, h) {
    super(), this.editorService = t, this.configurationService = i, this.quickInputService = n, this.instantiationService = s, this.commandService = o, this.extensionService = r, this.contextKeyService = a, this.languageService = u, this.dialogService = l, this.lifecycleService = h, this.debugAdapterFactories = /* @__PURE__ */ new Map(), this._onDidRegisterDebugger = new v(), this._onDidDebuggersExtPointRead = new v(), this.breakpointContributions = [], this.debuggerWhenKeys = /* @__PURE__ */ new Set(), this.usedDebugTypes = /* @__PURE__ */ new Set(), this.adapterDescriptorFactories = [], this.debuggers = [], this.registerListeners(), this.contextKeyService.bufferChangeEvents(() => {
      this.debuggersAvailable = Q.bindTo(a), this.debugExtensionsAvailable = Ia.bindTo(a);
    }), this._register(this.contextKeyService.onDidChangeContext((p) => {
      p.affectsSome(this.debuggerWhenKeys) && (this.debuggersAvailable.set(this.hasEnabledDebuggers()), this.updateDebugAdapterSchema());
    })), this._register(this.onDidDebuggersExtPointRead(() => {
      this.debugExtensionsAvailable.set(this.debuggers.length > 0);
    })), this.lifecycleService.when(4).then(() => this.debugExtensionsAvailable.set(this.debuggers.length > 0)), this._register(e.onDidNewSession((p) => {
      this.usedDebugTypes.add(p.configuration.type);
    }));
  }
  registerListeners() {
    fu.setHandler((e, t) => {
      t.added.forEach((i) => {
        i.value.forEach((n) => {
          var s;
          if ((!n.type || typeof n.type != "string") && i.collector.error(c(
            "debugNoType",
            "Debugger 'type' can not be omitted and must be of type 'string'."
          )), n.type !== "*") {
            const o = this.getDebugger(n.type);
            if (o)
              o.merge(n, i.description);
            else {
              const r = this.instantiationService.createInstance(Vi, this, n, i.description);
              (s = r.when) == null || s.keys().forEach((a) => this.debuggerWhenKeys.add(a)), this.debuggers.push(r);
            }
          }
        });
      }), e.forEach((i) => {
        i.value.forEach((n) => {
          n.type === "*" && this.debuggers.forEach((s) => s.merge(n, i.description));
        });
      }), t.removed.forEach((i) => {
        const n = i.value.map((s) => s.type);
        this.debuggers = this.debuggers.filter((s) => n.indexOf(s.type) === -1);
      }), this.updateDebugAdapterSchema(), this._onDidDebuggersExtPointRead.fire();
    }), bu.setHandler((e) => {
      this.breakpointContributions = e.flatMap((t) => t.value.map(
        (i) => this.instantiationService.createInstance(Fi, i)
      ));
    });
  }
  updateDebugAdapterSchema() {
    const e = tt.properties.configurations.items, t = wu.getJsonSchema(), i = {
      common: {
        properties: {
          name: {
            type: "string",
            description: c(
              "debugName",
              "Name of configuration; appears in the launch configuration dropdown menu."
            ),
            default: "Launch"
          },
          debugServer: {
            type: "number",
            description: c(
              "debugServer",
              "For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode"
            ),
            default: 4711
          },
          preLaunchTask: {
            anyOf: [t, {
              type: ["string"]
            }],
            default: "",
            defaultSnippets: [{ body: { task: "", type: "" } }],
            description: c("debugPrelaunchTask", "Task to run before debug session starts.")
          },
          postDebugTask: {
            anyOf: [t, {
              type: ["string"]
            }],
            default: "",
            defaultSnippets: [{ body: { task: "", type: "" } }],
            description: c("debugPostDebugTask", "Task to run after debug session ends.")
          },
          presentation: Ir,
          internalConsoleOptions: Lo,
          suppressMultipleSessionWarning: {
            type: "boolean",
            description: c(
              "suppressMultipleSessionWarning",
              "Disable the warning when trying to start the same debug configuration more than once."
            ),
            default: !0
          }
        }
      }
    };
    tt.definitions = i, e.oneOf = [], e.defaultSnippets = [], this.debuggers.forEach((n) => {
      const s = n.getSchemaAttributes(i);
      s && e.oneOf && e.oneOf.push(...s);
      const o = n.configurationSnippets;
      o && e.defaultSnippets && e.defaultSnippets.push(...o);
    }), ku.registerSchema(yt, tt);
  }
  registerDebugAdapterFactory(e, t) {
    return e.forEach((i) => this.debugAdapterFactories.set(i, t)), this.debuggersAvailable.set(this.hasEnabledDebuggers()), this._onDidRegisterDebugger.fire(), {
      dispose: () => {
        e.forEach((i) => this.debugAdapterFactories.delete(i));
      }
    };
  }
  hasEnabledDebuggers() {
    for (const [e] of this.debugAdapterFactories) {
      const t = this.getDebugger(e);
      if (t && t.enabled)
        return !0;
    }
    return !1;
  }
  createDebugAdapter(e) {
    const t = this.debugAdapterFactories.get(e.configuration.type);
    if (t)
      return t.createDebugAdapter(e);
  }
  substituteVariables(e, t, i) {
    const n = this.debugAdapterFactories.get(e);
    return n ? n.substituteVariables(t, i) : Promise.resolve(i);
  }
  runInTerminal(e, t, i) {
    const n = this.debugAdapterFactories.get(e);
    return n ? n.runInTerminal(t, i) : Promise.resolve(void 0);
  }
  registerDebugAdapterDescriptorFactory(e) {
    return this.adapterDescriptorFactories.push(e), {
      dispose: () => {
        this.unregisterDebugAdapterDescriptorFactory(e);
      }
    };
  }
  unregisterDebugAdapterDescriptorFactory(e) {
    const t = this.adapterDescriptorFactories.indexOf(e);
    t >= 0 && this.adapterDescriptorFactories.splice(t, 1);
  }
  getDebugAdapterDescriptor(e) {
    const t = e.configuration, i = this.adapterDescriptorFactories.filter((n) => n.type === t.type && n.createDebugAdapterDescriptor);
    return i.length === 1 ? i[0].createDebugAdapterDescriptor(e) : Promise.resolve(void 0);
  }
  getDebuggerLabel(e) {
    const t = this.getDebugger(e);
    if (t)
      return t.label;
  }
  get onDidRegisterDebugger() {
    return this._onDidRegisterDebugger.event;
  }
  get onDidDebuggersExtPointRead() {
    return this._onDidDebuggersExtPointRead.event;
  }
  canSetBreakpointsIn(e) {
    const t = e.getLanguageId();
    return !t || t === "jsonc" || t === "log" ? !1 : this.configurationService.getValue("debug").allowBreakpointsEverywhere ? !0 : this.breakpointContributions.some((i) => i.language === t && i.enabled);
  }
  getDebugger(e) {
    return this.debuggers.find((t) => _a(t.type, e));
  }
  getEnabledDebugger(e) {
    const t = this.getDebugger(e);
    return t && t.enabled ? t : void 0;
  }
  someDebuggerInterestedInLanguage(e) {
    return !!this.debuggers.filter((t) => t.enabled).find((t) => t.interestedInLanguage(e));
  }
  async guessDebugger(e) {
    const t = this.editorService.activeTextEditorControl;
    let i = [], n = null, s = null;
    if (Ae(t)) {
      s = t.getModel();
      const l = s ? s.getLanguageId() : void 0;
      l && (n = this.languageService.getLanguageName(l));
      const h = this.debuggers.filter((p) => p.enabled).filter((p) => l && p.interestedInLanguage(l));
      if (h.length === 1)
        return h[0];
      h.length > 1 && (i = h);
    }
    if ((!n || e || s && this.canSetBreakpointsIn(s)) && i.length === 0 && (await this.activateDebuggers("onDebugInitialConfigurations"), i = this.debuggers.filter((l) => l.enabled).filter((l) => l.hasInitialConfiguration() || l.hasConfigurationProvider())), i.length === 0 && n) {
      n.indexOf(" ") >= 0 && (n = `'${n}'`);
      const { confirmed: l } = await this.dialogService.confirm({
        type: ye.Warning,
        message: c(
          "CouldNotFindLanguage",
          "You don't have an extension for debugging {0}. Should we find a {0} extension in the Marketplace?",
          n
        ),
        primaryButton: c(
          { key: "findExtension", comment: ["&& denotes a mnemonic"] },
          "&&Find {0} extension",
          n
        )
      });
      l && await this.commandService.executeCommand("debug.installAdditionalDebuggers", n);
      return;
    }
    this.initExtensionActivationsIfNeeded(), i.sort((l, h) => l.label.localeCompare(h.label));
    const o = [], r = [];
    i.forEach((l) => {
      var p;
      const h = l.getMainExtensionDescriptor();
      h.id && ((p = this.earlyActivatedExtensions) != null && p.has(h.id)) || this.usedDebugTypes.has(l.type) ? o.push(l) : r.push(l);
    });
    const a = [];
    o.length > 0 && a.push({ type: "separator", label: c("suggestedDebuggers", "Suggested") }, ...o.map((l) => ({ label: l.label, debugger: l }))), r.length > 0 && (a.length > 0 && a.push({ type: "separator", label: "" }), a.push(...r.map((l) => ({ label: l.label, debugger: l })))), a.push({ type: "separator", label: "" }, { label: n ? c("installLanguage", "Install an extension for {0}...", n) : c("installExt", "Install extension...") });
    const u = c("selectDebug", "Select debugger");
    return this.quickInputService.pick(a, { activeItem: a[0], placeHolder: u }).then((l) => {
      if (l && l.debugger)
        return l.debugger;
      l && this.commandService.executeCommand("debug.installAdditionalDebuggers", n);
    });
  }
  initExtensionActivationsIfNeeded() {
    if (!this.earlyActivatedExtensions) {
      this.earlyActivatedExtensions = /* @__PURE__ */ new Set();
      const e = this.extensionService.getExtensionsStatus();
      for (const t in e)
        e[t].activationTimes && this.earlyActivatedExtensions.add(t);
    }
  }
  async activateDebuggers(e, t) {
    this.initExtensionActivationsIfNeeded();
    const i = [
      this.extensionService.activateByEvent(e),
      this.extensionService.activateByEvent("onDebug")
    ];
    t && i.push(this.extensionService.activateByEvent(`${e}:${t}`)), await Promise.all(i);
  }
};
Ui = E([
  g(1, se),
  g(2, G),
  g(3, Ie),
  g(4, re),
  g(5, _e),
  g(6, Dt),
  g(7, W),
  g(8, ni),
  g(9, Et),
  g(10, Vn)
], Ui);
const Hi = c("unknownSource", "Unknown Source");
class qt {
  constructor(e, t, i, n) {
    let s;
    e ? (this.raw = e, s = this.raw.path || this.raw.name || "", this.available = !0) : (this.raw = { name: Hi }, this.available = !1, s = `${xe}:${Hi}`), this.uri = _r(this.raw, s, t, i, n);
  }
  get name() {
    return this.raw.name || je(this.uri);
  }
  get origin() {
    return this.raw.origin;
  }
  get presentationHint() {
    return this.raw.presentationHint;
  }
  get reference() {
    return this.raw.sourceReference;
  }
  get inMemory() {
    return this.uri.scheme === xe;
  }
  openInEditor(e, t, i, n, s) {
    return this.available ? e.openEditor({
      resource: this.uri,
      description: this.origin,
      options: {
        preserveFocus: i,
        selection: t,
        revealIfOpened: !0,
        selectionRevealType: 1,
        pinned: s
      }
    }, n ? Wn : si) : Promise.resolve(void 0);
  }
  static getEncodedDebugData(e) {
    let t, i, n;
    switch (e.scheme) {
      case Pe.file:
        t = Mi(e.fsPath);
        break;
      case xe:
        if (t = e.path, e.query) {
          const s = e.query.split("&");
          for (const o of s) {
            const r = o.split("=");
            if (r.length === 2)
              switch (r[0]) {
                case "session":
                  n = r[1];
                  break;
                case "ref":
                  i = parseInt(r[1]);
                  break;
              }
          }
        }
        break;
      default:
        t = e.toString();
        break;
    }
    return {
      name: je(e),
      path: t,
      sourceReference: i,
      sessionId: n
    };
  }
}
function _r(d, e, t, i, n) {
  const s = (o) => typeof d.sourceReference == "number" && d.sourceReference > 0 ? ee.from({
    scheme: xe,
    path: o,
    query: `session=${t}&ref=${d.sourceReference}`
  }) : o && Ni(o) ? i.asCanonicalUri(ee.parse(o)) : o && xa(o) ? i.asCanonicalUri(ee.file(o)) : i.asCanonicalUri(ee.from({
    scheme: xe,
    path: o,
    query: `session=${t}`
  }));
  try {
    return s(e);
  } catch {
    return n.error("Invalid path from debug adapter: " + e), s("/invalidDebugSource");
  }
}
class ce extends Ba {
  constructor() {
    super(...arguments), this.resource = void 0;
  }
  get typeId() {
    return ce.ID;
  }
  static get instance() {
    return (!ce._instance || ce._instance.isDisposed()) && (ce._instance = new ce()), ce._instance;
  }
  getName() {
    return c("disassemblyInputName", "Disassembly");
  }
  matches(e) {
    return e instanceof ce;
  }
}
ce.ID = "debug.disassemblyView.input";
class Y {
  constructor(e, t, i, n, s = 0, o = 0, r = void 0, a = 0, u = void 0) {
    this.session = e, this.threadId = t, this._reference = i, this.id = n, this.namedVariables = s, this.indexedVariables = o, this.memoryReference = r, this.startOfVariables = a, this.presentationHint = u, this.valueChanged = !1, this._value = "";
  }
  get reference() {
    return this._reference;
  }
  set reference(e) {
    this._reference = e, this.children = void 0;
  }
  async evaluateLazy() {
    if (typeof this.reference > "u")
      return;
    const e = await this.session.variables(this.reference, this.threadId, void 0, void 0, void 0);
    if (!e || !e.body || !e.body.variables || e.body.variables.length !== 1)
      return;
    const t = e.body.variables[0];
    this.reference = t.variablesReference, this._value = t.value, this.namedVariables = t.namedVariables, this.indexedVariables = t.indexedVariables, this.memoryReference = t.memoryReference, this.presentationHint = t.presentationHint, this.adoptLazyResponse(t);
  }
  adoptLazyResponse(e) {
  }
  getChildren() {
    return this.children || (this.children = this.doGetChildren()), this.children;
  }
  async doGetChildren() {
    if (!this.hasChildren)
      return [];
    if (!this.getChildrenInChunks)
      return this.fetchVariables(void 0, void 0, void 0);
    const e = this.namedVariables ? await this.fetchVariables(void 0, void 0, "named") : [];
    let t = Y.BASE_CHUNK_SIZE;
    for (; this.indexedVariables && this.indexedVariables > t * Y.BASE_CHUNK_SIZE; )
      t *= Y.BASE_CHUNK_SIZE;
    if (this.indexedVariables && this.indexedVariables > t) {
      const n = Math.ceil(this.indexedVariables / t);
      for (let s = 0; s < n; s++) {
        const o = (this.startOfVariables || 0) + s * t, r = Math.min(t, this.indexedVariables - s * t);
        e.push(new be(
          this.session,
          this.threadId,
          this,
          this.reference,
          `[${o}..${o + r - 1}]`,
          "",
          "",
          void 0,
          r,
          void 0,
          { kind: "virtual" },
          void 0,
          void 0,
          !0,
          o
        ));
      }
      return e;
    }
    const i = await this.fetchVariables(this.startOfVariables, this.indexedVariables, "indexed");
    return e.concat(i);
  }
  getId() {
    return this.id;
  }
  getSession() {
    return this.session;
  }
  get value() {
    return this._value;
  }
  get hasChildren() {
    var e;
    return !!this.reference && this.reference > 0 && !((e = this.presentationHint) != null && e.lazy);
  }
  async fetchVariables(e, t, i) {
    try {
      const n = await this.session.variables(this.reference || 0, this.threadId, i, e, t);
      if (!n || !n.body || !n.body.variables)
        return [];
      const s = /* @__PURE__ */ new Map(), o = n.body.variables.filter((r) => !!r).map((r) => {
        if (pe(r.value) && pe(r.name) && typeof r.variablesReference == "number") {
          const a = s.get(r.name) || 0, u = a > 0 ? a.toString() : "";
          return s.set(r.name, a + 1), new be(
            this.session,
            this.threadId,
            this,
            r.variablesReference,
            r.name,
            r.evaluateName,
            r.value,
            r.namedVariables,
            r.indexedVariables,
            r.memoryReference,
            r.presentationHint,
            r.type,
            r.__vscodeVariableMenuContext,
            !0,
            0,
            u
          );
        }
        return new be(
          this.session,
          this.threadId,
          this,
          0,
          "",
          void 0,
          c("invalidVariableAttributes", "Invalid variable attributes"),
          0,
          0,
          void 0,
          { kind: "virtual" },
          void 0,
          void 0,
          !1
        );
      });
      return this.session.autoExpandLazyVariables && await Promise.all(o.map((r) => {
        var a;
        return ((a = r.presentationHint) == null ? void 0 : a.lazy) && r.evaluateLazy();
      })), o;
    } catch (n) {
      return [new be(
        this.session,
        this.threadId,
        this,
        0,
        "",
        void 0,
        n.message,
        0,
        0,
        void 0,
        { kind: "virtual" },
        void 0,
        void 0,
        !1
      )];
    }
  }
  get getChildrenInChunks() {
    return !!this.indexedVariables;
  }
  set value(e) {
    this._value = e, this.valueChanged = !!Y.allValues.get(this.getId()) && Y.allValues.get(this.getId()) !== $.DEFAULT_VALUE && Y.allValues.get(this.getId()) !== e, Y.allValues.set(this.getId(), e);
  }
  toString() {
    return this.value;
  }
  async evaluateExpression(e, t, i, n, s = !1) {
    var o;
    if (!t || !i && n !== "repl")
      return this.value = n === "repl" ? c("startDebugFirst", "Please start a debug session to evaluate expressions") : $.DEFAULT_VALUE, this.reference = 0, !1;
    this.session = t;
    try {
      const r = await t.evaluate(e, i ? i.frameId : void 0, n);
      return r && r.body ? (this.value = r.body.result || "", this.reference = r.body.variablesReference, this.namedVariables = r.body.namedVariables, this.indexedVariables = r.body.indexedVariables, this.memoryReference = r.body.memoryReference, this.type = r.body.type || this.type, this.presentationHint = r.body.presentationHint, !s && ((o = r.body.presentationHint) != null && o.lazy) && await this.evaluateLazy(), !0) : !1;
    } catch (r) {
      return this.value = r.message || "", this.reference = 0, !1;
    }
  }
}
Y.allValues = /* @__PURE__ */ new Map();
Y.BASE_CHUNK_SIZE = 100;
function $i(d, e) {
  e && e.body && (d.value = e.body.value || "", d.type = e.body.type || d.type, d.reference = e.body.variablesReference, d.namedVariables = e.body.namedVariables, d.indexedVariables = e.body.indexedVariables);
}
class $ extends Y {
  constructor(e, t = le()) {
    super(void 0, void 0, 0, t), this.name = e, this.available = !1, e && (this.value = $.DEFAULT_VALUE);
  }
  async evaluate(e, t, i, n) {
    this.available = await this.evaluateExpression(this.name, e, t, i, n);
  }
  toString() {
    return `${this.name}
${this.value}`;
  }
  async setExpression(e, t) {
    if (!this.session)
      return;
    const i = await this.session.setExpression(t.frameId, this.name, e);
    $i(this, i);
  }
}
$.DEFAULT_VALUE = c("notAvailable", "not available");
class be extends Y {
  constructor(e, t, i, n, s, o, r, a, u, l, h, p = void 0, f = void 0, b = !0, m = 0, S = "") {
    super(e, t, n, `variable:${i.getId()}:${s}:${S}`, a, u, l, m, h), this.parent = i, this.name = s, this.evaluateName = o, this.variableMenuContext = f, this.available = b, this.value = r || "", this.type = p;
  }
  async setVariable(e, t) {
    if (this.session)
      try {
        if (this.session.capabilities.supportsSetExpression && !this.session.capabilities.supportsSetVariable && this.evaluateName)
          return this.setExpression(e, t);
        const i = await this.session.setVariable(this.parent.reference, this.name, e);
        $i(this, i);
      } catch (i) {
        this.errorMessage = i.message;
      }
  }
  async setExpression(e, t) {
    if (!this.session || !this.evaluateName)
      return;
    const i = await this.session.setExpression(t.frameId, this.evaluateName, e);
    $i(this, i);
  }
  toString() {
    return this.name ? `${this.name}: ${this.value}` : this.value;
  }
  adoptLazyResponse(e) {
    this.evaluateName = e.evaluateName;
  }
  toDebugProtocolObject() {
    return {
      name: this.name,
      variablesReference: this.reference || 0,
      memoryReference: this.memoryReference,
      value: this.value,
      evaluateName: this.evaluateName
    };
  }
}
class xr extends Y {
  constructor(e, t, i, n, s, o, r, a) {
    super(e.thread.session, e.thread.threadId, n, `scope:${i}:${t}`, o, r), this.name = i, this.expensive = s, this.range = a;
  }
  toString() {
    return this.name;
  }
  toDebugProtocolObject() {
    return {
      name: this.name,
      variablesReference: this.reference || 0,
      expensive: this.expensive
    };
  }
}
class Cu extends xr {
  constructor(e, t, i) {
    super(e, t, i, 0, !1);
  }
  toString() {
    return this.name;
  }
}
class yu {
  constructor(e, t, i, n, s, o, r, a, u) {
    this.thread = e, this.frameId = t, this.source = i, this.name = n, this.presentationHint = s, this.range = o, this.index = r, this.canRestart = a, this.instructionPointerReference = u;
  }
  getId() {
    return `stackframe:${this.thread.getId()}:${this.index}:${this.source.name}`;
  }
  getScopes() {
    return this.scopes || (this.scopes = this.thread.session.scopes(this.frameId, this.thread.threadId).then((e) => {
      if (!e || !e.body || !e.body.scopes)
        return [];
      const t = /* @__PURE__ */ new Set();
      return e.body.scopes.map((i) => {
        let n = 0;
        do
          n = Ma(`${i.name}:${i.line}:${i.column}`, n);
        while (t.has(n));
        return t.add(n), new xr(
          this,
          n,
          i.name,
          i.variablesReference,
          i.expensive,
          i.namedVariables,
          i.indexedVariables,
          i.line && i.column && i.endLine && i.endColumn ? new K(i.line, i.column, i.endLine, i.endColumn) : void 0
        );
      });
    }, (e) => [new Cu(this, 0, e.message)])), this.scopes;
  }
  async getMostSpecificScopes(e) {
    const i = (await this.getScopes()).filter((o) => !o.expensive);
    if (!i.some((o) => !!o.range))
      return i;
    const s = i.filter((o) => o.range && K.containsRange(o.range, e)).sort((o, r) => o.range.endLineNumber - o.range.startLineNumber - (r.range.endLineNumber - r.range.startLineNumber));
    return s.length ? s : i;
  }
  restart() {
    return this.thread.session.restartFrame(this.frameId, this.thread.threadId);
  }
  forgetScopes() {
    this.scopes = void 0;
  }
  toString() {
    const e = typeof this.range.startLineNumber == "number" ? `:${this.range.startLineNumber}` : "", t = `${this.source.inMemory ? this.source.name : this.source.uri.fsPath}${e}`;
    return t === Hi ? this.name : `${this.name} (${t})`;
  }
  async openInEditor(e, t, i, n) {
    var o;
    const s = (o = this.thread.stoppedDetails) == null ? void 0 : o.reason;
    if (this.instructionPointerReference && (s === "instruction breakpoint" || s === "step" && this.thread.lastSteppingGranularity === "instruction"))
      return e.openEditor(ce.instance, { pinned: !0 });
    if (this.source.available)
      return this.source.openInEditor(e, this.range, t, i, n);
  }
  equals(e) {
    return this.name === e.name && e.thread === this.thread && this.frameId === e.frameId && e.source === this.source && K.equalsRange(this.range, e.range);
  }
}
class Du {
  constructor(e, t, i) {
    this.session = e, this.name = t, this.threadId = i, this.callStackCancellationTokens = [], this.reachedEndOfCallStack = !1, this.callStack = [], this.staleCallStack = [], this.stopped = !1;
  }
  getId() {
    return `thread:${this.session.getId()}:${this.threadId}`;
  }
  clearCallStack() {
    this.callStack.length && (this.staleCallStack = this.callStack), this.callStack = [], this.callStackCancellationTokens.forEach((e) => e.dispose(!0)), this.callStackCancellationTokens = [];
  }
  getCallStack() {
    return this.callStack;
  }
  getStaleCallStack() {
    return this.staleCallStack;
  }
  getTopStackFrame() {
    const e = this.getCallStack();
    return e.find((i) => {
      var n, s;
      return !!(i && (((n = this.stoppedDetails) == null ? void 0 : n.reason) === "instruction breakpoint" || ((s = this.stoppedDetails) == null ? void 0 : s.reason) === "step" && this.lastSteppingGranularity === "instruction") && i.instructionPointerReference || i.source && i.source.available && i.source.presentationHint !== "deemphasize");
    }) || (e.length > 0 ? e[0] : void 0);
  }
  get stateLabel() {
    return this.stoppedDetails ? this.stoppedDetails.description || (this.stoppedDetails.reason ? c(
      { key: "pausedOn", comment: ["indicates reason for program being paused"] },
      "Paused on {0}",
      this.stoppedDetails.reason
    ) : c("paused", "Paused")) : c({ key: "running", comment: ["indicates state"] }, "Running");
  }
  async fetchCallStack(e = 20) {
    var t;
    if (this.stopped) {
      const i = this.callStack.length, n = await this.getCallStackImpl(i, e);
      this.reachedEndOfCallStack = n.length < e, i < this.callStack.length && this.callStack.splice(i, this.callStack.length - i), this.callStack = this.callStack.concat(n || []), typeof ((t = this.stoppedDetails) == null ? void 0 : t.totalFrames) == "number" && this.stoppedDetails.totalFrames === this.callStack.length && (this.reachedEndOfCallStack = !0);
    }
  }
  async getCallStackImpl(e, t) {
    try {
      const i = new Me();
      this.callStackCancellationTokens.push(i);
      const n = await this.session.stackTrace(this.threadId, e, t, i.token);
      return !n || !n.body || i.token.isCancellationRequested ? [] : (this.stoppedDetails && (this.stoppedDetails.totalFrames = n.body.totalFrames), n.body.stackFrames.map((s, o) => {
        const r = this.session.getSource(s.source);
        return new yu(
          this,
          s.id,
          r,
          s.name,
          s.presentationHint,
          new K(s.line, s.column, s.endLine || s.line, s.endColumn || s.column),
          e + o,
          typeof s.canRestart == "boolean" ? s.canRestart : !0,
          s.instructionPointerReference
        );
      }));
    } catch (i) {
      return this.stoppedDetails && (this.stoppedDetails.framesErrorMessage = i.message), [];
    }
  }
  get exceptionInfo() {
    return this.stoppedDetails && this.stoppedDetails.reason === "exception" ? this.session.capabilities.supportsExceptionInfoRequest ? this.session.exceptionInfo(this.threadId) : Promise.resolve({
      description: this.stoppedDetails.text,
      breakMode: null
    }) : Promise.resolve(void 0);
  }
  next(e) {
    return this.session.next(this.threadId, e);
  }
  stepIn(e) {
    return this.session.stepIn(this.threadId, void 0, e);
  }
  stepOut(e) {
    return this.session.stepOut(this.threadId, e);
  }
  stepBack(e) {
    return this.session.stepBack(this.threadId, e);
  }
  continue() {
    return this.session.continue(this.threadId);
  }
  pause() {
    return this.session.pause(this.threadId);
  }
  terminate() {
    return this.session.terminateThreads([this.threadId]);
  }
  reverseContinue() {
    return this.session.reverseContinue(this.threadId);
  }
}
const Eu = (d, e, t, i = "memory") => ee.from({
  scheme: Gt,
  authority: d,
  path: "/" + encodeURIComponent(e) + `/${encodeURIComponent(i)}.bin`,
  query: t ? `?range=${t.fromOffset}:${t.toOffset}` : void 0
});
class Iu extends ae {
  constructor(e, t) {
    super(), this.memoryReference = e, this.session = t, this.invalidateEmitter = this._register(new v()), this.onDidInvalidate = this.invalidateEmitter.event, this.writable = !!this.session.capabilities.supportsWriteMemoryRequest, this._register(t.onDidInvalidateMemory((i) => {
      i.body.memoryReference === e && this.invalidate(i.body.offset, i.body.count - i.body.offset);
    }));
  }
  async read(e, t) {
    var u;
    const i = t - e, n = e, s = await this.session.readMemory(this.memoryReference, n, i);
    if (s === void 0 || !((u = s.body) != null && u.data))
      return [{ type: 1, offset: n, length: i }];
    let o;
    try {
      o = Aa(s.body.data);
    } catch {
      return [{ type: 2, offset: n, length: i, error: "Invalid base64 data from debug adapter" }];
    }
    const r = s.body.unreadableBytes || 0, a = i - r;
    if (o.byteLength < a) {
      const l = Ri.alloc(a - o.byteLength);
      l.buffer.fill(0), o = Ri.concat([o, l], a);
    } else
      o.byteLength > a && (o = o.slice(0, a));
    return r ? [
      { type: 0, offset: n, length: a, data: o },
      { type: 1, offset: n + a, length: r }
    ] : [{ type: 0, offset: n, length: i, data: o }];
  }
  async write(e, t) {
    var s;
    const i = await this.session.writeMemory(this.memoryReference, e, La(t), !0), n = ((s = i == null ? void 0 : i.body) == null ? void 0 : s.bytesWritten) ?? t.byteLength;
    return this.invalidate(e, e + n), n;
  }
  dispose() {
    super.dispose();
  }
  invalidate(e, t) {
    this.invalidateEmitter.fire({ fromOffset: e, toOffset: t });
  }
}
class _u {
  constructor(e, t) {
    this.enabled = e, this.id = t;
  }
  getId() {
    return this.id;
  }
}
function pt(d, e) {
  return Hn({
    supportsConditionalBreakpoints: !!e.supportsConditionalBreakpoints,
    supportsHitConditionalBreakpoints: !!e.supportsHitConditionalBreakpoints,
    supportsLogPoints: !!e.supportsLogPoints,
    supportsFunctionBreakpoints: !!e.supportsFunctionBreakpoints,
    supportsDataBreakpoints: !!e.supportsDataBreakpoints,
    supportsInstructionBreakpoints: !!e.supportsInstructionBreakpoints
  }, d);
}
class Pt extends _u {
  constructor(e, t, i, n, s) {
    super(e, s), this.hitCondition = t, this.condition = i, this.logMessage = n, this.sessionData = /* @__PURE__ */ new Map(), e === void 0 && (this.enabled = !0);
  }
  setSessionData(e, t) {
    t ? (t.sessionId = e, this.sessionData.set(e, t)) : this.sessionData.delete(e);
    const i = Array.from(this.sessionData.values()), n = Le(i.filter((s) => s.verified), (s) => `${s.line}:${s.column}`);
    n.length ? this.data = n.length === 1 ? n[0] : void 0 : this.data = i.length ? i[0] : void 0;
  }
  get message() {
    if (this.data)
      return this.data.message;
  }
  get verified() {
    return this.data ? this.data.verified : !0;
  }
  get sessionsThatVerified() {
    const e = [];
    for (const [t, i] of this.sessionData)
      i.verified && e.push(t);
    return e;
  }
  getIdFromAdapter(e) {
    const t = this.sessionData.get(e);
    return t ? t.id : void 0;
  }
  getDebugProtocolBreakpoint(e) {
    const t = this.sessionData.get(e);
    if (t)
      return {
        id: t.id,
        verified: t.verified,
        message: t.message,
        source: t.source,
        line: t.line,
        column: t.column,
        endLine: t.endLine,
        endColumn: t.endColumn,
        instructionReference: t.instructionReference,
        offset: t.offset
      };
  }
  toJSON() {
    const e = /* @__PURE__ */ Object.create(null);
    return e.enabled = this.enabled, e.condition = this.condition, e.hitCondition = this.hitCondition, e.logMessage = this.logMessage, e;
  }
}
class Be extends Pt {
  constructor(e, t, i, n, s, o, r, a, u, l, h, p = le()) {
    super(n, o, s, r, p), this._uri = e, this._lineNumber = t, this._column = i, this._adapterData = a, this.textFileService = u, this.uriIdentityService = l, this.logService = h;
  }
  get originalUri() {
    return this._uri;
  }
  get lineNumber() {
    return this.verified && this.data && typeof this.data.line == "number" ? this.data.line : this._lineNumber;
  }
  get verified() {
    return this.data ? this.data.verified && !this.textFileService.isDirty(this._uri) : !0;
  }
  get uri() {
    return this.verified && this.data && this.data.source ? _r(this.data.source, this.data.source.path, this.data.sessionId, this.uriIdentityService, this.logService) : this._uri;
  }
  get column() {
    return this.verified && this.data && typeof this.data.column == "number" ? this.data.column : this._column;
  }
  get message() {
    return this.textFileService.isDirty(this.uri) ? c(
      "breakpointDirtydHover",
      "Unverified breakpoint. File is modified, please restart debug session."
    ) : super.message;
  }
  get adapterData() {
    return this.data && this.data.source && this.data.source.adapterData ? this.data.source.adapterData : this._adapterData;
  }
  get endLineNumber() {
    return this.verified && this.data ? this.data.endLine : void 0;
  }
  get endColumn() {
    return this.verified && this.data ? this.data.endColumn : void 0;
  }
  get sessionAgnosticData() {
    return {
      lineNumber: this._lineNumber,
      column: this._column
    };
  }
  get supported() {
    return this.data ? !(this.logMessage && !this.data.supportsLogPoints || this.condition && !this.data.supportsConditionalBreakpoints || this.hitCondition && !this.data.supportsHitConditionalBreakpoints) : !0;
  }
  setSessionData(e, t) {
    super.setSessionData(e, t), this._adapterData || (this._adapterData = this.adapterData);
  }
  toJSON() {
    const e = super.toJSON();
    return e.uri = this._uri, e.lineNumber = this._lineNumber, e.column = this._column, e.adapterData = this.adapterData, e;
  }
  toString() {
    return `${je(this.uri)} ${this.lineNumber}`;
  }
  update(e) {
    $e(e.lineNumber) || (this._lineNumber = e.lineNumber), $e(e.column) || (this._column = e.column), $e(e.condition) || (this.condition = e.condition), $e(e.hitCondition) || (this.hitCondition = e.hitCondition), $e(e.logMessage) || (this.logMessage = e.logMessage);
  }
}
class De extends Pt {
  constructor(e, t, i, n, s, o = le()) {
    super(t, i, n, s, o), this.name = e;
  }
  toJSON() {
    const e = super.toJSON();
    return e.name = this.name, e;
  }
  get supported() {
    return this.data ? this.data.supportsFunctionBreakpoints : !0;
  }
  toString() {
    return this.name;
  }
}
class Te extends Pt {
  constructor(e, t, i, n, s, o, r, a, u, l = le()) {
    super(n, s, o, r, l), this.description = e, this.dataId = t, this.canPersist = i, this.accessTypes = a, this.accessType = u;
  }
  toJSON() {
    const e = super.toJSON();
    return e.description = this.description, e.dataId = this.dataId, e.accessTypes = this.accessTypes, e.accessType = this.accessType, e;
  }
  get supported() {
    return this.data ? this.data.supportsDataBreakpoints : !0;
  }
  toString() {
    return this.description;
  }
}
class qi extends Pt {
  constructor(e, t, i, n, s, o, r, a = !1) {
    super(i, void 0, s, void 0, le()), this.filter = e, this.label = t, this.supportsCondition = n, this.description = o, this.conditionDescription = r, this.fallback = a, this.supportedSessions = /* @__PURE__ */ new Set();
  }
  toJSON() {
    const e = /* @__PURE__ */ Object.create(null);
    return e.filter = this.filter, e.label = this.label, e.enabled = this.enabled, e.supportsCondition = this.supportsCondition, e.conditionDescription = this.conditionDescription, e.condition = this.condition, e.fallback = this.fallback, e.description = this.description, e;
  }
  setSupportedSession(e, t) {
    t ? this.supportedSessions.add(e) : this.supportedSessions.delete(e);
  }
  setFallback(e) {
    this.fallback = e;
  }
  get supported() {
    return !0;
  }
  isSupportedSession(e) {
    return e ? this.supportedSessions.has(e) : this.fallback;
  }
  matches(e) {
    return this.filter === e.filter && this.label === e.label && this.supportsCondition === !!e.supportsCondition && this.conditionDescription === e.conditionDescription && this.description === e.description;
  }
  toString() {
    return this.label;
  }
}
class it extends Pt {
  constructor(e, t, i, n, s, o, r, a = le()) {
    super(n, s, o, r, a), this.instructionReference = e, this.offset = t, this.canPersist = i;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instructionReference = this.instructionReference, e.offset = this.offset, e;
  }
  get supported() {
    return this.data ? this.data.supportsInstructionBreakpoints : !0;
  }
  toString() {
    return this.instructionReference;
  }
}
let Ki = class {
  constructor(e, t, i, n) {
    this.textFileService = t, this.uriIdentityService = i, this.logService = n, this.schedulers = /* @__PURE__ */ new Map(), this.breakpointsActivated = !0, this._onDidChangeBreakpoints = new v(), this._onDidChangeCallStack = new v(), this._onDidChangeWatchExpressions = new v(), this.breakpoints = e.loadBreakpoints(), this.functionBreakpoints = e.loadFunctionBreakpoints(), this.exceptionBreakpoints = e.loadExceptionBreakpoints(), this.dataBreakpoints = e.loadDataBreakpoints(), this.watchExpressions = e.loadWatchExpressions(), this.instructionBreakpoints = [], this.sessions = [];
  }
  getId() {
    return "root";
  }
  getSession(e, t = !1) {
    if (e)
      return this.getSessions(t).find((i) => i.getId() === e);
  }
  getSessions(e = !1) {
    return this.sessions.filter((t) => e || t.state !== 0);
  }
  addSession(e) {
    this.sessions = this.sessions.filter((n) => !(n.getId() === e.getId() || n.state === 0 && n.configuration.name === e.configuration.name));
    let t = 1;
    for (; this.sessions.some((n) => n.getLabel() === e.getLabel()); )
      e.setName(`${e.configuration.name} ${++t}`);
    let i = -1;
    e.parentSession && (i = Ta(this.sessions, (n) => n.parentSession === e.parentSession || n === e.parentSession)), i >= 0 ? this.sessions.splice(i + 1, 0, e) : this.sessions.push(e), this._onDidChangeCallStack.fire(void 0);
  }
  get onDidChangeBreakpoints() {
    return this._onDidChangeBreakpoints.event;
  }
  get onDidChangeCallStack() {
    return this._onDidChangeCallStack.event;
  }
  get onDidChangeWatchExpressions() {
    return this._onDidChangeWatchExpressions.event;
  }
  rawUpdate(e) {
    const t = this.sessions.find((i) => i.getId() === e.sessionId);
    t && (t.rawUpdate(e), this._onDidChangeCallStack.fire(void 0));
  }
  clearThreads(e, t, i = void 0) {
    const n = this.sessions.find((s) => s.getId() === e);
    this.schedulers.forEach((s) => s.dispose()), this.schedulers.clear(), n && (n.clearThreads(t, i), this._onDidChangeCallStack.fire(void 0));
  }
  async fetchCallstack(e, t) {
    var s;
    if (e.reachedEndOfCallStack)
      return;
    const i = (s = e.stoppedDetails) == null ? void 0 : s.totalFrames, n = typeof i == "number" ? i - e.getCallStack().length : void 0;
    (!t || n && t > n) && (t = n), t && t > 0 && (await e.fetchCallStack(t), this._onDidChangeCallStack.fire());
  }
  refreshTopOfCallstack(e) {
    if (e.session.capabilities.supportsDelayedStackTraceLoading) {
      let i = Promise.resolve();
      const n = new Promise((s, o) => {
        i = e.fetchCallStack(1).then(() => {
          this.schedulers.has(e.getId()) || this.schedulers.set(e.getId(), new fe(() => {
            e.fetchCallStack(19).then(() => {
              const r = e.getStaleCallStack(), a = e.getCallStack();
              let u = r.length !== a.length;
              for (let l = 1; l < r.length && !u; l++)
                u = !r[l].equals(a[l]);
              u && this._onDidChangeCallStack.fire(), s();
            });
          }, 420)), this.schedulers.get(e.getId()).schedule(), this._onDidChangeCallStack.fire();
        });
      });
      return { topCallStack: i, wholeCallStack: n };
    }
    const t = e.fetchCallStack();
    return { wholeCallStack: t, topCallStack: t };
  }
  getBreakpoints(e) {
    var t, i;
    if (e) {
      const n = (t = e.uri) == null ? void 0 : t.toString(), s = (i = e.originalUri) == null ? void 0 : i.toString();
      return this.breakpoints.filter((o) => !(n && o.uri.toString() !== n || s && o.originalUri.toString() !== s || e.lineNumber && o.lineNumber !== e.lineNumber || e.column && o.column !== e.column || e.enabledOnly && (!this.breakpointsActivated || !o.enabled)));
    }
    return this.breakpoints;
  }
  getFunctionBreakpoints() {
    return this.functionBreakpoints;
  }
  getDataBreakpoints() {
    return this.dataBreakpoints;
  }
  getExceptionBreakpoints() {
    return this.exceptionBreakpoints;
  }
  getExceptionBreakpointsForSession(e) {
    return this.exceptionBreakpoints.filter((t) => t.isSupportedSession(e));
  }
  getInstructionBreakpoints() {
    return this.instructionBreakpoints;
  }
  setExceptionBreakpointsForSession(e, t) {
    if (t) {
      let i = !1;
      t.forEach((n) => {
        let s = this.exceptionBreakpoints.filter((o) => o.matches(n)).pop();
        s || (i = !0, s = new qi(
          n.filter,
          n.label,
          !!n.default,
          !!n.supportsCondition,
          void 0,
          n.description,
          n.conditionDescription
        ), this.exceptionBreakpoints.push(s)), s.setSupportedSession(e, !0);
      }), i && this._onDidChangeBreakpoints.fire(void 0);
    }
  }
  removeExceptionBreakpointsForSession(e) {
    this.exceptionBreakpoints.forEach((t) => t.setSupportedSession(e, !1));
  }
  setExceptionBreakpointFallbackSession(e) {
    this.exceptionBreakpoints.forEach((t) => t.setFallback(t.isSupportedSession(e)));
  }
  setExceptionBreakpointCondition(e, t) {
    e.condition = t, this._onDidChangeBreakpoints.fire(void 0);
  }
  areBreakpointsActivated() {
    return this.breakpointsActivated;
  }
  setBreakpointsActivated(e) {
    this.breakpointsActivated = e, this._onDidChangeBreakpoints.fire(void 0);
  }
  addBreakpoints(e, t, i = !0) {
    const n = t.map((s) => new Be(
      e,
      s.lineNumber,
      s.column,
      s.enabled !== !1,
      s.condition,
      s.hitCondition,
      s.logMessage,
      void 0,
      this.textFileService,
      this.uriIdentityService,
      this.logService,
      s.id
    ));
    return this.breakpoints = this.breakpoints.concat(n), this.breakpointsActivated = !0, this.sortAndDeDup(), i && this._onDidChangeBreakpoints.fire({ added: n, sessionOnly: !1 }), n;
  }
  removeBreakpoints(e) {
    this.breakpoints = this.breakpoints.filter((t) => !e.some((i) => i.getId() === t.getId())), this._onDidChangeBreakpoints.fire({ removed: e, sessionOnly: !1 });
  }
  updateBreakpoints(e) {
    const t = [];
    this.breakpoints.forEach((i) => {
      const n = e.get(i.getId());
      n && (i.update(n), t.push(i));
    }), this.sortAndDeDup(), this._onDidChangeBreakpoints.fire({ changed: t, sessionOnly: !1 });
  }
  setBreakpointSessionData(e, t, i) {
    this.breakpoints.forEach((n) => {
      if (!i)
        n.setSessionData(e, void 0);
      else {
        const s = i.get(n.getId());
        s && n.setSessionData(e, pt(s, t));
      }
    }), this.functionBreakpoints.forEach((n) => {
      if (!i)
        n.setSessionData(e, void 0);
      else {
        const s = i.get(n.getId());
        s && n.setSessionData(e, pt(s, t));
      }
    }), this.dataBreakpoints.forEach((n) => {
      if (!i)
        n.setSessionData(e, void 0);
      else {
        const s = i.get(n.getId());
        s && n.setSessionData(e, pt(s, t));
      }
    }), this.exceptionBreakpoints.forEach((n) => {
      if (!i)
        n.setSessionData(e, void 0);
      else {
        const s = i.get(n.getId());
        s && n.setSessionData(e, pt(s, t));
      }
    }), this.instructionBreakpoints.forEach((n) => {
      if (!i)
        n.setSessionData(e, void 0);
      else {
        const s = i.get(n.getId());
        s && n.setSessionData(e, pt(s, t));
      }
    }), this._onDidChangeBreakpoints.fire({
      sessionOnly: !0
    });
  }
  getDebugProtocolBreakpoint(e, t) {
    const i = this.breakpoints.find((n) => n.getId() === e);
    if (i)
      return i.getDebugProtocolBreakpoint(t);
  }
  sortAndDeDup() {
    this.breakpoints = this.breakpoints.sort((e, t) => e.uri.toString() !== t.uri.toString() ? je(e.uri).localeCompare(je(t.uri)) : e.lineNumber === t.lineNumber ? e.column && t.column ? e.column - t.column : 1 : e.lineNumber - t.lineNumber), this.breakpoints = Le(this.breakpoints, (e) => `${e.uri.toString()}:${e.lineNumber}:${e.column}`);
  }
  setEnablement(e, t) {
    if (e instanceof Be || e instanceof De || e instanceof qi || e instanceof Te || e instanceof it) {
      const i = [];
      e.enabled !== t && (e instanceof Be || e instanceof De || e instanceof Te || e instanceof it) && i.push(e), e.enabled = t, t && (this.breakpointsActivated = !0), this._onDidChangeBreakpoints.fire({ changed: i, sessionOnly: !1 });
    }
  }
  enableOrDisableAllBreakpoints(e) {
    const t = [];
    this.breakpoints.forEach((i) => {
      i.enabled !== e && t.push(i), i.enabled = e;
    }), this.functionBreakpoints.forEach((i) => {
      i.enabled !== e && t.push(i), i.enabled = e;
    }), this.dataBreakpoints.forEach((i) => {
      i.enabled !== e && t.push(i), i.enabled = e;
    }), this.instructionBreakpoints.forEach((i) => {
      i.enabled !== e && t.push(i), i.enabled = e;
    }), e && (this.breakpointsActivated = !0), this._onDidChangeBreakpoints.fire({ changed: t, sessionOnly: !1 });
  }
  addFunctionBreakpoint(e, t) {
    const i = new De(e, !0, void 0, void 0, void 0, t);
    return this.functionBreakpoints.push(i), this._onDidChangeBreakpoints.fire({ added: [i], sessionOnly: !1 }), i;
  }
  updateFunctionBreakpoint(e, t) {
    const i = this.functionBreakpoints.find((n) => n.getId() === e);
    i && (typeof t.name == "string" && (i.name = t.name), typeof t.condition == "string" && (i.condition = t.condition), typeof t.hitCondition == "string" && (i.hitCondition = t.hitCondition), this._onDidChangeBreakpoints.fire({ changed: [i], sessionOnly: !1 }));
  }
  removeFunctionBreakpoints(e) {
    let t;
    e ? (t = this.functionBreakpoints.filter((i) => i.getId() === e), this.functionBreakpoints = this.functionBreakpoints.filter((i) => i.getId() !== e)) : (t = this.functionBreakpoints, this.functionBreakpoints = []), this._onDidChangeBreakpoints.fire({ removed: t, sessionOnly: !1 });
  }
  addDataBreakpoint(e, t, i, n, s) {
    const o = new Te(
      e,
      t,
      i,
      !0,
      void 0,
      void 0,
      void 0,
      n,
      s
    );
    this.dataBreakpoints.push(o), this._onDidChangeBreakpoints.fire({ added: [o], sessionOnly: !1 });
  }
  removeDataBreakpoints(e) {
    let t;
    e ? (t = this.dataBreakpoints.filter((i) => i.getId() === e), this.dataBreakpoints = this.dataBreakpoints.filter((i) => i.getId() !== e)) : (t = this.dataBreakpoints, this.dataBreakpoints = []), this._onDidChangeBreakpoints.fire({ removed: t, sessionOnly: !1 });
  }
  addInstructionBreakpoint(e, t, i, n) {
    const s = new it(e, t, !1, !0, n, i, void 0);
    this.instructionBreakpoints.push(s), this._onDidChangeBreakpoints.fire({ added: [s], sessionOnly: !0 });
  }
  removeInstructionBreakpoints(e) {
    let t;
    e ? (t = this.instructionBreakpoints.filter((i) => i.instructionReference === e), this.instructionBreakpoints = this.instructionBreakpoints.filter((i) => i.instructionReference !== e)) : (t = this.instructionBreakpoints, this.instructionBreakpoints = []), this._onDidChangeBreakpoints.fire({ removed: t, sessionOnly: !1 });
  }
  getWatchExpressions() {
    return this.watchExpressions;
  }
  addWatchExpression(e) {
    const t = new $(e || "");
    return this.watchExpressions.push(t), this._onDidChangeWatchExpressions.fire(t), t;
  }
  renameWatchExpression(e, t) {
    const i = this.watchExpressions.filter((n) => n.getId() === e);
    i.length === 1 && (i[0].name = t, this._onDidChangeWatchExpressions.fire(i[0]));
  }
  removeWatchExpressions(e = null) {
    this.watchExpressions = e ? this.watchExpressions.filter((t) => t.getId() !== e) : [], this._onDidChangeWatchExpressions.fire(void 0);
  }
  moveWatchExpression(e, t) {
    const i = this.watchExpressions.find((n) => n.getId() === e);
    i && (this.watchExpressions = this.watchExpressions.filter((n) => n.getId() !== e), this.watchExpressions = this.watchExpressions.slice(0, t).concat(i, this.watchExpressions.slice(t)), this._onDidChangeWatchExpressions.fire(void 0));
  }
  sourceIsNotAvailable(e) {
    this.sessions.forEach((t) => {
      const i = t.getSourceForUri(e);
      i && (i.available = !1);
    }), this._onDidChangeCallStack.fire(void 0);
  }
};
Ki = E([
  g(1, Un),
  g(2, Je),
  g(3, It)
], Ki);
async function xu(d) {
  const e = d.get(Ie), t = d.get(w), i = d.get(se), n = t.getModel().getSessions(!1), s = d.get($n), o = d.get(ni), r = d.get(Ye), a = new oe(), u = e.createQuickPick();
  a.add(u), u.matchOnLabel = u.matchOnDescription = u.matchOnDetail = u.sortByLabel = !1, u.placeholder = c("moveFocusedView.selectView", "Search loaded scripts by name"), u.items = await co(u.value, n, i, s, o, r), a.add(u.onDidChangeValue(async () => {
    u.items = await co(u.value, n, i, s, o, r);
  })), a.add(u.onDidAccept(() => {
    u.selectedItems[0].accept(), u.hide(), a.dispose();
  })), u.show();
}
async function Bu(d, e, t, i, n, s) {
  const o = [];
  return o.push({ type: "separator", label: d.name }), (await d.getLoadedSources()).forEach((a) => {
    const u = Tu(a, e, t, i, n, s);
    u && o.push(u);
  }), o;
}
async function co(d, e, t, i, n, s) {
  const o = [], r = await Promise.all(e.map(
    (a) => Bu(a, d, t, i, n, s)
  ));
  for (const a of r)
    for (const u of a)
      o.push(u);
  return o;
}
function Tu(d, e, t, i, n, s) {
  const o = s.getUriBasenameLabel(d.uri), r = s.getUriLabel(Mo(d.uri)), a = qe(e, o, !0), u = qe(e, r, !0);
  if (a || u)
    return {
      label: o,
      description: r === "." ? void 0 : r,
      highlights: { label: a ?? void 0, description: u ?? void 0 },
      iconClasses: Na(i, n, d.uri),
      accept: () => {
        d.available && d.openInEditor(t, { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 });
      }
    };
}
async function Au(d, e) {
  const t = d.get(Ie), i = d.get(w), n = d.get(st), s = d.get(_e), o = new oe(), r = t.createQuickPick();
  o.add(r), r.matchOnLabel = r.matchOnDescription = r.matchOnDetail = r.sortByLabel = !1, r.placeholder = c("moveFocusedView.selectView", "Search debug sessions by name");
  const a = uo(r.value, e, i, n, s);
  r.items = a.picks, r.activeItems = a.activeItems, o.add(r.onDidChangeValue(async () => {
    r.items = uo(r.value, e, i, n, s).picks;
  })), o.add(r.onDidAccept(() => {
    r.selectedItems[0].accept(), r.hide(), o.dispose();
  })), r.show();
}
function uo(d, e, t, i, n) {
  const s = [], o = [], r = t.getViewModel().focusedSession, a = t.getModel().getSessions(!1), u = [];
  a.forEach((h) => {
    h.compact && h.parentSession && o.push(h.parentSession);
  }), a.forEach((h) => {
    const p = o.includes(h);
    if (h.parentSession || s.push({ type: "separator", label: p ? h.name : void 0 }), !p) {
      const f = Mu(h, d, t, i);
      f && (s.push(f), h.getId() === (r == null ? void 0 : r.getId()) && u.push(f));
    }
  }), s.length && s.push({ type: "separator" });
  const l = c("workbench.action.debug.startDebug", "Start a New Debug Session");
  return s.push({
    label: `$(plus) ${l}`,
    ariaLabel: l,
    accept: () => n.executeCommand(e)
  }), { picks: s, activeItems: u };
}
function Lu(d) {
  var s;
  const e = d.configuration.name.length ? d.configuration.name : d.name, t = d.compact || (s = d.parentSession) == null ? void 0 : s.configuration.name;
  let i = "", n = "";
  return t && (n = c(
    "workbench.action.debug.spawnFrom",
    "Session {0} spawned from {1}",
    e,
    t
  ), i = t), { label: e, description: i, ariaLabel: n };
}
function Mu(d, e, t, i, n) {
  const s = Lu(d), o = qe(e, s.label, !0);
  if (o)
    return {
      label: s.label,
      description: s.description,
      ariaLabel: s.ariaLabel,
      highlights: { label: o },
      accept: () => {
        t.focusStackFrame(void 0, void 0, d, { explicit: !0 }), i.isViewVisible(Fe) || i.openView(Fe, !0);
      }
    };
}
const os = "debug.addConfiguration", rs = "editor.debug.action.toggleInlineBreakpoint", Nu = "debug.copyStackTrace", Br = "workbench.action.debug.reverseContinue", Tr = "workbench.action.debug.stepBack", as = "workbench.action.debug.restart", Ru = "workbench.action.debug.terminateThread", ds = "workbench.action.debug.stepOver", cs = "workbench.action.debug.stepInto", Ou = "workbench.action.debug.stepIntoTarget", us = "workbench.action.debug.stepOut", Ar = "workbench.action.debug.pause", Ft = "workbench.action.debug.disconnect", Lr = "workbench.action.debug.disconnectAndSuspend", lt = "workbench.action.debug.stop", Pu = "workbench.action.debug.restartFrame", ls = "workbench.action.debug.continue", Fu = "workbench.debug.action.focusRepl", Mr = "debug.jumpToCursor", hs = "workbench.action.debug.focusProcess", li = "workbench.action.debug.selectandstart", Nr = "workbench.action.debug.selectDebugConsole", Vu = "workbench.action.debug.selectDebugSession", Xt = "workbench.action.debug.configure", Wu = "workbench.action.debug.start", Uu = "workbench.action.debug.run", Hu = "debug.renameWatchExpression", $u = "debug.setWatchExpression", qu = "debug.removeWatchExpression", Ku = "workbench.action.debug.showLoadedScripts", zu = "workbench.action.debug.callStackTop", Gu = "workbench.action.debug.callStackBottom", ju = "workbench.action.debug.callStackUp", Xu = "workbench.action.debug.callStackDown", Rr = { original: "Debug", value: c("debug", "Debug") }, Ju = { value: c("restartDebug", "Restart"), original: "Restart" }, Yu = { value: c("stepOverDebug", "Step Over"), original: "Step Over" }, Qu = { value: c("stepIntoDebug", "Step Into"), original: "Step Into" }, Zu = { value: c("stepOutDebug", "Step Out"), original: "Step Out" }, el = { value: c("pauseDebug", "Pause"), original: "Pause" }, gs = { value: c("disconnect", "Disconnect"), original: "Disconnect" }, tl = { value: c("disconnectSuspend", "Disconnect and Suspend"), original: "Disconnect and Suspend" }, ps = { value: c("stop", "Stop"), original: "Stop" }, il = { value: c("continueDebug", "Continue"), original: "Continue" }, nl = { value: c("focusSession", "Focus Session"), original: "Focus Session" }, Or = c("openLaunchJson", "Open '{0}'", "launch.json"), fs = "debug ", bs = "debug consoles ";
function sl(d) {
  return d && typeof d.sessionId == "string" && typeof d.threadId == "string";
}
async function ue(d, e, t) {
  const i = d.get(w);
  let n;
  if (sl(e)) {
    const s = i.getModel().getSession(e.sessionId);
    s && (n = s.getAllThreads().find((o) => o.getId() === e.threadId));
  } else if (ms(e)) {
    const s = i.getModel().getSession(e.sessionId);
    if (s) {
      const o = s.getAllThreads();
      n = o.length > 0 ? o[0] : void 0;
    }
  }
  if (!n && (n = i.getViewModel().focusedThread, !n)) {
    const s = i.getViewModel().focusedSession, o = s ? s.getAllThreads() : void 0;
    n = o && o.length ? o[0] : void 0;
  }
  n && await t(n);
}
function ol(d) {
  return d && typeof d.sessionId == "string" && typeof d.threadId == "string" && typeof d.frameId == "string";
}
function Pr(d, e) {
  if (ol(e)) {
    const t = d.getModel().getSession(e.sessionId);
    if (t) {
      const i = t.getAllThreads().find((n) => n.getId() === e.threadId);
      if (i)
        return i.getCallStack().find((n) => n.getId() === e.frameId);
    }
  } else
    return d.getViewModel().focusedStackFrame;
}
function ms(d) {
  return d && typeof d.sessionId == "string";
}
async function Fr(d, e) {
  const t = d.getViewModel().focusedStackFrame;
  if (t) {
    let i = t.thread.getCallStack(), n = i.findIndex((o) => o.frameId === t.frameId), s;
    if (e) {
      if (n >= i.length - 1)
        if (t.thread.reachedEndOfCallStack) {
          Wr(d);
          return;
        } else
          await d.getModel().fetchCallstack(t.thread, 20), i = t.thread.getCallStack(), n = i.findIndex((o) => o.frameId === t.frameId);
      s = zi(!0, i, n);
    } else {
      if (n <= 0) {
        Vr(d);
        return;
      }
      s = zi(!1, i, n);
    }
    s && d.focusStackFrame(s);
  }
}
async function Vr(d) {
  const e = d.getViewModel().focusedThread;
  if (e) {
    await d.getModel().fetchCallstack(e);
    const t = e.getCallStack();
    if (t.length > 0) {
      const i = zi(!1, t, 0);
      i && d.focusStackFrame(i);
    }
  }
}
function Wr(d) {
  const e = d.getViewModel().focusedThread;
  e && d.focusStackFrame(e.getTopStackFrame());
}
function zi(d, e, t) {
  t >= e.length ? t = e.length - 1 : t < 0 && (t = 0);
  let i = t, n;
  do
    if (d ? i === e.length - 1 ? i = 0 : i++ : i === 0 ? i = e.length - 1 : i--, n = e[i], !(n.source.presentationHint === "deemphasize" || n.presentationHint === "deemphasize"))
      return n;
  while (i !== t);
}
R.registerCommand({
  id: Nu,
  handler: async (d, e, t) => {
    const i = d.get(xo), n = d.get(oi), s = d.get(w), o = Pr(s, t);
    if (o) {
      const r = i.getEOL(o.source.uri);
      await n.writeText(o.thread.getCallStack().map((a) => a.toString()).join(r));
    }
  }
});
R.registerCommand({
  id: Br,
  handler: async (d, e, t) => {
    await ue(d, t, (i) => i.reverseContinue());
  }
});
R.registerCommand({
  id: Tr,
  handler: async (d, e, t) => {
    const i = d.get(W);
    _t.getValue(i) ? await ue(d, t, (n) => n.stepBack("instruction")) : await ue(d, t, (n) => n.stepBack());
  }
});
R.registerCommand({
  id: Ru,
  handler: async (d, e, t) => {
    await ue(d, t, (i) => i.terminate());
  }
});
R.registerCommand({
  id: Mr,
  handler: async (d) => {
    const t = d.get(w).getViewModel().focusedStackFrame, n = d.get(se).activeTextEditorControl, s = d.get(Re), o = d.get(Ie);
    if (t && Ae(n) && n.hasModel()) {
      const r = n.getPosition(), a = n.getModel().uri, u = t.thread.session.getSourceForUri(a);
      if (u) {
        const l = await t.thread.session.gotoTargets(u.raw, r.lineNumber, r.column), h = l == null ? void 0 : l.body.targets;
        if (h && h.length) {
          let p = h[0].id;
          if (h.length > 1) {
            const f = h.map((m) => ({ label: m.label, _id: m.id })), b = await o.pick(f, { placeHolder: c("chooseLocation", "Choose the specific location") });
            if (!b)
              return;
            p = b._id;
          }
          return await t.thread.session.goto(t.thread.threadId, p).catch((f) => s.warn(f));
        }
      }
    }
    return s.warn(c(
      "noExecutableCode",
      "No executable code is associated at the current cursor position."
    ));
  }
});
R.registerCommand({
  id: zu,
  handler: async (d, e, t) => {
    const i = d.get(w);
    Wr(i);
  }
});
R.registerCommand({
  id: Gu,
  handler: async (d, e, t) => {
    const i = d.get(w);
    await Vr(i);
  }
});
R.registerCommand({
  id: ju,
  handler: async (d, e, t) => {
    const i = d.get(w);
    Fr(i, !1);
  }
});
R.registerCommand({
  id: Xu,
  handler: async (d, e, t) => {
    const i = d.get(w);
    Fr(i, !0);
  }
});
F.appendMenuItem(y.EditorContext, {
  command: {
    id: Mr,
    title: c("jumpToCursor", "Jump to Cursor"),
    category: Rr
  },
  when: A.and(No, Xe.editorTextFocus),
  group: "debug",
  order: 3
});
te.registerCommandAndKeybindingRule({
  id: as,
  weight: 200,
  primary: 3135,
  when: Oe,
  handler: async (d, e, t) => {
    const i = d.get(w), n = d.get(G);
    let s;
    if (ms(t) ? s = i.getModel().getSession(t.sessionId) : s = i.getViewModel().focusedSession, s) {
      const o = n.getValue("debug").showSubSessionsInToolBar;
      for (; !o && s.lifecycleManagedByParent && s.parentSession; )
        s = s.parentSession;
      s.removeReplExpressions(), await i.restartSession(s);
    } else {
      const { launch: o, name: r } = i.getConfigurationManager().selectedConfiguration;
      await i.startDebugging(o, r, { noDebug: !1, startedByUser: !0 });
    }
  }
});
te.registerCommandAndKeybindingRule({
  id: ds,
  weight: 200,
  primary: Ro ? 580 : 68,
  when: q.isEqualTo("stopped"),
  handler: async (d, e, t) => {
    const i = d.get(W);
    _t.getValue(i) ? await ue(d, t, (n) => n.next("instruction")) : await ue(d, t, (n) => n.next());
  }
});
const Ur = Ro && qn ? 581 : 69;
te.registerCommandAndKeybindingRule({
  id: cs,
  weight: 200 + 10,
  primary: Ur,
  when: q.notEqualsTo("inactive"),
  handler: async (d, e, t) => {
    const i = d.get(W);
    _t.getValue(i) ? await ue(d, t, (n) => n.stepIn("instruction")) : await ue(d, t, (n) => n.stepIn());
  }
});
te.registerCommandAndKeybindingRule({
  id: us,
  weight: 200,
  primary: 1093,
  when: q.isEqualTo("stopped"),
  handler: async (d, e, t) => {
    const i = d.get(W);
    _t.getValue(i) ? await ue(d, t, (n) => n.stepOut("instruction")) : await ue(d, t, (n) => n.stepOut());
  }
});
te.registerCommandAndKeybindingRule({
  id: Ar,
  weight: 200 + 2,
  primary: 64,
  when: q.isEqualTo("running"),
  handler: async (d, e, t) => {
    await ue(d, t, (i) => i.pause());
  }
});
te.registerCommandAndKeybindingRule({
  id: Ou,
  primary: Ur | 2048,
  when: A.and(Oo, Oe, q.isEqualTo("stopped")),
  weight: 200,
  handler: async (d, e, t) => {
    const i = d.get(Ie), n = d.get(w), s = n.getViewModel().focusedSession, o = n.getViewModel().focusedStackFrame;
    if (!o || !s)
      return;
    const r = await d.get(se).openEditor({
      resource: o.source.uri,
      options: { revealIfOpened: !0 }
    });
    let a;
    if (r) {
      const l = r == null ? void 0 : r.getControl();
      Ae(l) && (a = l);
    }
    const u = i.createQuickPick();
    u.busy = !0, u.show(), u.onDidChangeActive(([l]) => {
      a && l && l.target.line !== void 0 && (a.revealLineInCenterIfOutsideViewport(l.target.line), a.setSelection({
        startLineNumber: l.target.line,
        startColumn: l.target.column || 1,
        endLineNumber: l.target.endLine || l.target.line,
        endColumn: l.target.endColumn || l.target.column || 1
      }));
    }), u.onDidAccept(() => {
      u.activeItems.length && s.stepIn(o.thread.threadId, u.activeItems[0].target.id);
    }), u.onDidHide(() => u.dispose()), s.stepInTargets(o.frameId).then((l) => {
      u.busy = !1, l != null && l.length ? u.items = l == null ? void 0 : l.map((h) => ({ target: h, label: h.label })) : u.placeholder = c("editor.debug.action.stepIntoTargets.none", "No step targets available");
    });
  }
});
async function Ss(d, e, t, i, n) {
  const s = d.get(w);
  let o;
  ms(t) ? o = s.getModel().getSession(t.sessionId) : o = s.getViewModel().focusedSession;
  const a = d.get(G).getValue("debug").showSubSessionsInToolBar;
  for (; !a && o && o.lifecycleManagedByParent && o.parentSession; )
    o = o.parentSession;
  await s.stopSession(o, i, n);
}
te.registerCommandAndKeybindingRule({
  id: Ft,
  weight: 200,
  primary: 1087,
  when: A.and(me, Oe),
  handler: (d, e, t) => Ss(d, e, t, !0)
});
R.registerCommand({
  id: Lr,
  handler: (d, e, t) => Ss(d, e, t, !0, !0)
});
te.registerCommandAndKeybindingRule({
  id: lt,
  weight: 200,
  primary: 1087,
  when: A.and(me.toNegated(), Oe),
  handler: (d, e, t) => Ss(d, e, t, !1)
});
R.registerCommand({
  id: Pu,
  handler: async (d, e, t) => {
    const i = d.get(w), n = d.get(Re), s = Pr(i, t);
    if (s)
      try {
        await s.restart();
      } catch (o) {
        n.error(o);
      }
  }
});
te.registerCommandAndKeybindingRule({
  id: ls,
  weight: 200 + 10,
  primary: 63,
  when: q.isEqualTo("stopped"),
  handler: async (d, e, t) => {
    await ue(d, t, (i) => i.continue());
  }
});
R.registerCommand({
  id: Ku,
  handler: async (d) => {
    await xu(d);
  }
});
R.registerCommand({
  id: Fu,
  handler: async (d) => {
    await d.get(st).openView(Fe, !0);
  }
});
R.registerCommand({
  id: "debug.startFromConfig",
  handler: async (d, e) => {
    await d.get(w).startDebugging(void 0, e);
  }
});
R.registerCommand({
  id: hs,
  handler: async (d, e) => {
    const t = d.get(w), i = d.get(se), n = t.getModel().getSessions().find((o) => o.parentSession === e && o.state === 2);
    n && e.state !== 2 && (e = n), await t.focusStackFrame(void 0, void 0, e, { explicit: !0 });
    const s = t.getViewModel().focusedStackFrame;
    s && await s.openInEditor(i, !0);
  }
});
R.registerCommand({
  id: li,
  handler: async (d) => {
    d.get(Ie).quickAccess.show(fs);
  }
});
R.registerCommand({
  id: Nr,
  handler: async (d) => {
    d.get(Ie).quickAccess.show(bs);
  }
});
R.registerCommand({
  id: Vu,
  handler: async (d) => {
    Au(d, li);
  }
});
te.registerCommandAndKeybindingRule({
  id: "debug.toggleBreakpoint",
  weight: 200 + 5,
  when: A.and(Po, Ra.toNegated()),
  primary: 10,
  handler: (d) => {
    const e = d.get(xt), t = d.get(w), i = e.lastFocusedList;
    if (i instanceof Fo) {
      const n = i.getFocusedElements();
      n && n.length && t.enableOrDisableBreakpoints(!n[0].enabled, n[0]);
    }
  }
});
te.registerCommandAndKeybindingRule({
  id: "debug.enableOrDisableBreakpoint",
  weight: 200,
  primary: void 0,
  when: Xe.editorTextFocus,
  handler: (d) => {
    const e = d.get(w), i = d.get(se).activeTextEditorControl;
    if (Ae(i)) {
      const n = i.getModel();
      if (n) {
        const s = i.getPosition();
        if (s) {
          const o = e.getModel().getBreakpoints({ uri: n.uri, lineNumber: s.lineNumber });
          o.length && e.enableOrDisableBreakpoints(!o[0].enabled, o[0]);
        }
      }
    }
  }
});
te.registerCommandAndKeybindingRule({
  id: Hu,
  weight: 200 + 5,
  when: Vo,
  primary: 60,
  mac: { primary: 3 },
  handler: (d, e) => {
    const t = d.get(w);
    if (!(e instanceof $)) {
      const n = d.get(xt).lastFocusedList;
      if (n) {
        const s = n.getFocus();
        Array.isArray(s) && s[0] instanceof $ && (e = s[0]);
      }
    }
    e instanceof $ && t.getViewModel().setSelectedExpression(e, !1);
  }
});
R.registerCommand({
  id: $u,
  handler: async (d, e) => {
    const t = d.get(w);
    (e instanceof $ || e instanceof be) && t.getViewModel().setSelectedExpression(e, !0);
  }
});
te.registerCommandAndKeybindingRule({
  id: "debug.setVariable",
  weight: 200 + 5,
  when: Oa,
  primary: 60,
  mac: { primary: 3 },
  handler: (d) => {
    const e = d.get(xt), t = d.get(w), i = e.lastFocusedList;
    if (i) {
      const n = i.getFocus();
      Array.isArray(n) && n[0] instanceof be && t.getViewModel().setSelectedExpression(n[0], !1);
    }
  }
});
te.registerCommandAndKeybindingRule({
  id: qu,
  weight: 200,
  when: A.and(Vo, Wo.toNegated()),
  primary: 20,
  mac: { primary: 2049 },
  handler: (d, e) => {
    const t = d.get(w);
    if (e instanceof $) {
      t.removeWatchExpressions(e.getId());
      return;
    }
    const n = d.get(xt).lastFocusedList;
    if (n) {
      let s = n.getFocus();
      if (Array.isArray(s) && s[0] instanceof $) {
        const o = n.getSelection();
        o && o.indexOf(s[0]) >= 0 && (s = o), s.forEach((r) => t.removeWatchExpressions(r.getId()));
      }
    }
  }
});
te.registerCommandAndKeybindingRule({
  id: "debug.removeBreakpoint",
  weight: 200,
  when: A.and(Po, Pa.toNegated()),
  primary: 20,
  mac: { primary: 2049 },
  handler: (d) => {
    const e = d.get(xt), t = d.get(w), i = e.lastFocusedList;
    if (i instanceof Fo) {
      const n = i.getFocusedElements(), s = n.length ? n[0] : void 0;
      s instanceof Be ? t.removeBreakpoints(s.getId()) : s instanceof De ? t.removeFunctionBreakpoints(s.getId()) : s instanceof Te && t.removeDataBreakpoints(s.getId());
    }
  }
});
const rl = (d) => {
  const e = d.get(w), i = d.get(se).activeTextEditorControl;
  if (Ae(i)) {
    const n = i.getPosition();
    if (n && i.hasModel() && e.canSetBreakpointsIn(i.getModel())) {
      const s = i.getModel().uri;
      e.getModel().getBreakpoints({ lineNumber: n.lineNumber, uri: s }).some(
        (r) => r.sessionAgnosticData.column === n.column || !r.column && n.column <= 1
      ) || e.addBreakpoints(s, [{ lineNumber: n.lineNumber, column: n.column > 1 ? n.column : void 0 }]);
    }
  }
};
te.registerCommandAndKeybindingRule({
  weight: 200,
  primary: 1091,
  when: Xe.editorTextFocus,
  id: rs,
  handler: rl
});
F.appendMenuItem(y.EditorContext, {
  command: {
    id: rs,
    title: c("addInlineBreakpoint", "Add Inline Breakpoint"),
    category: Rr
  },
  when: A.and(Oe, cu.toNegated(), Xe.editorTextFocus),
  group: "debug",
  order: 1
});
const mt = {
  regular: x("debug-breakpoint", I.debugBreakpoint, c("debugBreakpoint", "Icon for breakpoints.")),
  disabled: x(
    "debug-breakpoint-disabled",
    I.debugBreakpointDisabled,
    c("debugBreakpointDisabled", "Icon for disabled breakpoints.")
  ),
  unverified: x(
    "debug-breakpoint-unverified",
    I.debugBreakpointUnverified,
    c("debugBreakpointUnverified", "Icon for unverified breakpoints.")
  )
}, Hr = {
  regular: x(
    "debug-breakpoint-function",
    I.debugBreakpointFunction,
    c("debugBreakpointFunction", "Icon for function breakpoints.")
  ),
  disabled: x(
    "debug-breakpoint-function-disabled",
    I.debugBreakpointFunctionDisabled,
    c(
      "debugBreakpointFunctionDisabled",
      "Icon for disabled function breakpoints."
    )
  ),
  unverified: x(
    "debug-breakpoint-function-unverified",
    I.debugBreakpointFunctionUnverified,
    c(
      "debugBreakpointFunctionUnverified",
      "Icon for unverified function breakpoints."
    )
  )
}, $r = {
  regular: x(
    "debug-breakpoint-conditional",
    I.debugBreakpointConditional,
    c("debugBreakpointConditional", "Icon for conditional breakpoints.")
  ),
  disabled: x(
    "debug-breakpoint-conditional-disabled",
    I.debugBreakpointConditionalDisabled,
    c(
      "debugBreakpointConditionalDisabled",
      "Icon for disabled conditional breakpoints."
    )
  ),
  unverified: x(
    "debug-breakpoint-conditional-unverified",
    I.debugBreakpointConditionalUnverified,
    c(
      "debugBreakpointConditionalUnverified",
      "Icon for unverified conditional breakpoints."
    )
  )
}, qr = {
  regular: x("debug-breakpoint-data", I.debugBreakpointData, c("debugBreakpointData", "Icon for data breakpoints.")),
  disabled: x(
    "debug-breakpoint-data-disabled",
    I.debugBreakpointDataDisabled,
    c("debugBreakpointDataDisabled", "Icon for disabled data breakpoints.")
  ),
  unverified: x(
    "debug-breakpoint-data-unverified",
    I.debugBreakpointDataUnverified,
    c("debugBreakpointDataUnverified", "Icon for unverified data breakpoints.")
  )
}, Gi = {
  regular: x("debug-breakpoint-log", I.debugBreakpointLog, c("debugBreakpointLog", "Icon for log breakpoints.")),
  disabled: x(
    "debug-breakpoint-log-disabled",
    I.debugBreakpointLogDisabled,
    c("debugBreakpointLogDisabled", "Icon for disabled log breakpoint.")
  ),
  unverified: x(
    "debug-breakpoint-log-unverified",
    I.debugBreakpointLogUnverified,
    c("debugBreakpointLogUnverified", "Icon for unverified log breakpoints.")
  )
}, Kr = x("debug-hint", I.debugHint, c(
  "debugBreakpointHint",
  "Icon for breakpoint hints shown on hover in editor glyph margin."
)), zr = x(
  "debug-breakpoint-unsupported",
  I.debugBreakpointUnsupported,
  c("debugBreakpointUnsupported", "Icon for unsupported breakpoints.")
), Ci = [mt, Hr, $r, qr, Gi], ji = x("debug-stackframe", I.debugStackframe, c(
  "debugStackframe",
  "Icon for a stackframe shown in the editor glyph margin."
)), Xi = x("debug-stackframe-focused", I.debugStackframeFocused, c(
  "debugStackframeFocused",
  "Icon for a focused stackframe  shown in the editor glyph margin."
)), al = x("debug-gripper", I.gripper, c("debugGripper", "Icon for the debug bar gripper.")), lo = x("debug-restart-frame", I.debugRestartFrame, c("debugRestartFrame", "Icon for the debug restart frame action.")), St = x("debug-stop", I.debugStop, c("debugStop", "Icon for the debug stop action.")), ze = x("debug-disconnect", I.debugDisconnect, c("debugDisconnect", "Icon for the debug disconnect action.")), Ji = x("debug-restart", I.debugRestart, c("debugRestart", "Icon for the debug restart action.")), Yi = x("debug-step-over", I.debugStepOver, c("debugStepOver", "Icon for the debug step over action.")), Kt = x("debug-step-into", I.debugStepInto, c("debugStepInto", "Icon for the debug step into action.")), zt = x("debug-step-out", I.debugStepOut, c("debugStepOut", "Icon for the debug step out action.")), Qi = x("debug-step-back", I.debugStepBack, c("debugStepBack", "Icon for the debug step back action.")), Zi = x("debug-pause", I.debugPause, c("debugPause", "Icon for the debug pause action.")), en = x("debug-continue", I.debugContinue, c("debugContinue", "Icon for the debug continue action.")), tn = x("debug-reverse-continue", I.debugReverseContinue, c("debugReverseContinue", "Icon for the debug reverse continue action.")), dl = x("debug-run", I.run, c("debugRun", "Icon for the run or debug action.")), Gr = x("debug-start", I.debugStart, c("debugStart", "Icon for the debug start action.")), jr = x("debug-configure", I.gear, c("debugConfigure", "Icon for the debug configure action.")), cl = x("debug-remove-config", I.trash, c("debugRemoveConfig", "Icon for removing debug configurations.")), ul = x("watch-expressions-add-function-breakpoint", I.add, c(
  "watchExpressionsAddFuncBreakpoint",
  "Icon for the add function breakpoint action in the watch view."
)), ll = x("breakpoints-remove-all", I.closeAll, c(
  "breakpointsRemoveAll",
  "Icon for the Remove All action in the breakpoints view."
)), hl = x("breakpoints-activate", I.activateBreakpoints, c(
  "breakpointsActivate",
  "Icon for the activate action in the breakpoints view."
)), Xr = Ee.as(Ao.JSONContribution);
Xr.registerSchema(yt, tt);
const yi = "debug.selectedconfigname", Di = "debug.selectedroot", ho = "debug.selectedtype", Ei = "debug.recentdynamicconfigurations";
let nn = class {
  constructor(e, t, i, n, s, o, r, a, u, l) {
    this.adapterManager = e, this.contextService = t, this.configurationService = i, this.quickInputService = n, this.instantiationService = s, this.storageService = o, this.extensionService = r, this.historyService = a, this.uriIdentityService = u, this.getSelectedConfig = () => Promise.resolve(void 0), this.selectedDynamic = !1, this._onDidSelectConfigurationName = new v(), this.configProviders = [], this.toDispose = [], this.initLaunches(), this.registerListeners();
    const h = this.storageService.get(Di, 1), p = this.storageService.get(ho, 1), f = this.launches.find((S) => S.uri.toString() === h), b = this.storageService.get(yi, 1);
    this.debugConfigurationTypeContext = Wa.bindTo(l);
    const m = p ? { type: p } : void 0;
    f && f.getConfigurationNames().length ? this.selectConfiguration(f, b, void 0, m) : this.launches.length > 0 && this.selectConfiguration(void 0, b, void 0, m);
  }
  registerDebugConfigurationProvider(e) {
    return this.configProviders.push(e), {
      dispose: () => {
        this.unregisterDebugConfigurationProvider(e);
      }
    };
  }
  unregisterDebugConfigurationProvider(e) {
    const t = this.configProviders.indexOf(e);
    t >= 0 && this.configProviders.splice(t, 1);
  }
  hasDebugConfigurationProvider(e, t) {
    return t === void 0 && (t = Ut.Initial), !!this.configProviders.find((n) => n.provideDebugConfigurations && n.type === e && n.triggerKind === t);
  }
  async resolveConfigurationByProviders(e, t, i, n) {
    const s = async (a, u) => {
      a !== "*" && await this.adapterManager.activateDebuggers("onDebugResolve", a);
      for (const l of this.configProviders)
        l.type === a && l.resolveDebugConfiguration && u && (u = await l.resolveDebugConfiguration(e, u, n));
      return u;
    };
    let o = i.type ?? t, r = i;
    for (let a = /* @__PURE__ */ new Set(); r && !a.has(o); )
      a.add(o), r = await s(o, r), r = await s("*", r), o = (r == null ? void 0 : r.type) ?? t;
    return r;
  }
  async resolveDebugConfigurationWithSubstitutedVariables(e, t, i, n) {
    const s = this.configProviders.filter((r) => r.type === t && r.resolveDebugConfigurationWithSubstitutedVariables).concat(this.configProviders.filter((r) => r.type === "*" && r.resolveDebugConfigurationWithSubstitutedVariables));
    let o = i;
    return await Ua(s.map((r) => async () => {
      o && (o = await r.resolveDebugConfigurationWithSubstitutedVariables(e, o, n));
    })), o;
  }
  async provideDebugConfigurations(e, t, i) {
    return await this.adapterManager.activateDebuggers("onDebugInitialConfigurations"), (await Promise.all(this.configProviders.filter((s) => s.type === t && s.triggerKind === Ut.Initial && s.provideDebugConfigurations).map((s) => s.provideDebugConfigurations(e, i)))).reduce((s, o) => s.concat(o), []);
  }
  async getDynamicProviders() {
    await this.extensionService.whenInstalledExtensionsRegistered();
    const e = "onDebugDynamicConfigurations";
    return this.extensionService.extensions.reduce((i, n) => {
      var r, a;
      if (!n.activationEvents)
        return i;
      const s = [];
      let o = !1;
      for (const u of n.activationEvents)
        u === e ? o = !0 : u.startsWith(`${e}:`) && s.push(u.slice(e.length + 1));
      if (s.length)
        return i.concat(s);
      if (o) {
        const u = (a = (r = n.contributes) == null ? void 0 : r.debuggers) == null ? void 0 : a[0].type;
        return u ? i.concat(u) : i;
      }
      return i;
    }, []).map((i) => ({
      label: this.adapterManager.getDebuggerLabel(i),
      getProvider: async () => (await this.adapterManager.activateDebuggers(e, i), this.configProviders.find((n) => n.type === i && n.triggerKind === Ut.Dynamic && n.provideDebugConfigurations)),
      type: i,
      pick: async () => {
        await this.adapterManager.activateDebuggers(e, i);
        const n = new oe(), s = n.add(this.quickInputService.createQuickPick());
        s.busy = !0, s.placeholder = c("selectConfiguration", "Select Launch Configuration"), s.show();
        const o = new Promise((f) => {
          n.add(s.onDidAccept(() => f(s.activeItems[0]))), n.add(s.onDidTriggerItemButton(async (b) => {
            f(void 0);
            const { launch: m, config: S } = b.item;
            await m.openConfigFile({ preserveFocus: !1, type: S.type, suppressInitialConfigs: !0 }), await m.writeConfiguration(S), await this.selectConfiguration(m, S.name), this.removeRecentDynamicConfigurations(S.name, S.type);
          }));
        }), r = new Me(), a = [], u = this.configProviders.find((f) => f.type === i && f.triggerKind === Ut.Dynamic && f.provideDebugConfigurations);
        this.getLaunches().forEach((f) => {
          f.workspace && u && a.push(u.provideDebugConfigurations(f.workspace.uri, r.token).then((b) => b.map((m) => ({
            label: m.name,
            description: f.name,
            config: m,
            buttons: [{
              iconClass: C.asClassName(jr),
              tooltip: c("editLaunchConfig", "Edit Debug Configuration in launch.json")
            }],
            launch: f
          }))));
        });
        const l = await Promise.all(a), h = Uo(l);
        s.items = h, s.busy = !1;
        const p = await o;
        if (n.dispose(), !p) {
          r.cancel();
          return;
        }
        return p;
      }
    }));
  }
  getAllConfigurations() {
    const e = [];
    for (const t of this.launches)
      for (const i of t.getConfigurationNames()) {
        const n = t.getConfiguration(i) || t.getCompound(i);
        n && e.push({ launch: t, name: i, presentation: n.presentation });
      }
    return Ho(e);
  }
  removeRecentDynamicConfigurations(e, t) {
    const i = this.getRecentDynamicConfigurations().filter((n) => n.name !== e || n.type !== t);
    this.storageService.store(Ei, JSON.stringify(i), 1, 0), this.selectedConfiguration.name === e && this.selectedType === t && this.selectedDynamic ? this.selectConfiguration(void 0, void 0) : this._onDidSelectConfigurationName.fire();
  }
  getRecentDynamicConfigurations() {
    return JSON.parse(this.storageService.get(Ei, 1, "[]"));
  }
  registerListeners() {
    this.toDispose.push(ne.any(this.contextService.onDidChangeWorkspaceFolders, this.contextService.onDidChangeWorkbenchState)(() => {
      this.initLaunches(), this.selectConfiguration(void 0), this.setCompoundSchemaValues();
    })), this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
      e.affectsConfiguration("launch") && (await this.selectConfiguration(void 0), this.setCompoundSchemaValues());
    })), this.toDispose.push(this.adapterManager.onDidDebuggersExtPointRead(() => {
      this.setCompoundSchemaValues();
    }));
  }
  initLaunches() {
    this.launches = this.contextService.getWorkspace().folders.map(
      (e) => this.instantiationService.createInstance(sn, this, this.adapterManager, e)
    ), this.contextService.getWorkbenchState() === 3 && this.launches.push(this.instantiationService.createInstance(Jt, this, this.adapterManager)), this.launches.push(this.instantiationService.createInstance(Yt, this, this.adapterManager)), this.selectedLaunch && this.launches.indexOf(this.selectedLaunch) === -1 && this.selectConfiguration(void 0);
  }
  setCompoundSchemaValues() {
    const e = tt.properties.compounds.items.properties.configurations, t = this.launches.map((n) => n.getConfigurationNames(!0)).reduce((n, s) => n.concat(s), []);
    e.items.oneOf[0].enum = t, e.items.oneOf[1].properties.name.enum = t;
    const i = this.contextService.getWorkspace().folders.map((n) => n.name);
    e.items.oneOf[1].properties.folder.enum = i, Xr.registerSchema(yt, tt);
  }
  getLaunches() {
    return this.launches;
  }
  getLaunch(e) {
    if (ee.isUri(e))
      return this.launches.find((t) => t.workspace && this.uriIdentityService.extUri.isEqual(t.workspace.uri, e));
  }
  get selectedConfiguration() {
    return {
      launch: this.selectedLaunch,
      name: this.selectedName,
      getConfig: this.getSelectedConfig,
      type: this.selectedType
    };
  }
  get onDidSelectConfiguration() {
    return this._onDidSelectConfigurationName.event;
  }
  getWorkspaceLaunch() {
    if (this.contextService.getWorkbenchState() === 3)
      return this.launches[this.launches.length - 1];
  }
  async selectConfiguration(e, t, i, n) {
    if (typeof e > "u") {
      const l = this.historyService.getLastActiveWorkspaceRoot();
      e = this.getLaunch(l), (!e || e.getConfigurationNames().length === 0) && (e = this.launches.find((h) => !!(h && h.getConfigurationNames().length)) || e || this.launches[0]);
    }
    const s = this.selectedLaunch, o = this.selectedName, r = this.selectedDynamic;
    this.selectedLaunch = e, this.selectedLaunch ? this.storageService.store(Di, this.selectedLaunch.uri.toString(), 1, 1) : this.storageService.remove(Di, 1);
    const a = e ? e.getConfigurationNames() : [];
    this.getSelectedConfig = () => {
      const l = this.selectedName ? e == null ? void 0 : e.getConfiguration(this.selectedName) : void 0;
      return Promise.resolve(l || i);
    };
    let u = i == null ? void 0 : i.type;
    if (t && a.indexOf(t) >= 0)
      this.setSelectedLaunchName(t);
    else if (n && n.type) {
      if (u = n.type, !i) {
        const h = (await this.getDynamicProviders()).filter((p) => p.type === u);
        this.getSelectedConfig = async () => {
          const p = await Promise.all(h.map((b) => b.getProvider())), f = p.length > 0 ? p[0] : void 0;
          if (f && e && e.workspace) {
            const b = new Me(), S = (await f.provideDebugConfigurations(e.workspace.uri, b.token)).find((N) => N.name === t);
            if (S)
              return S;
          }
        };
      }
      this.setSelectedLaunchName(t);
      let l = this.getRecentDynamicConfigurations();
      t && n.type && (l.unshift({ name: t, type: n.type }), l = Le(l, (h) => `${h.name} : ${h.type}`), this.storageService.store(Ei, JSON.stringify(l), 1, 0));
    } else if (!this.selectedName || a.indexOf(this.selectedName) === -1) {
      const l = a.length ? a[0] : void 0;
      this.setSelectedLaunchName(l);
    }
    !i && e && this.selectedName && (i = e.getConfiguration(this.selectedName), u = i == null ? void 0 : i.type), this.selectedType = (n == null ? void 0 : n.type) || (i == null ? void 0 : i.type), this.selectedDynamic = !!n, this.storageService.store(ho, n ? this.selectedType : void 0, 1, 1), u ? this.debugConfigurationTypeContext.set(u) : this.debugConfigurationTypeContext.reset(), (this.selectedLaunch !== s || this.selectedName !== o || r !== this.selectedDynamic) && this._onDidSelectConfigurationName.fire();
  }
  setSelectedLaunchName(e) {
    this.selectedName = e, this.selectedName ? this.storageService.store(yi, this.selectedName, 1, 1) : this.storageService.remove(yi, 1);
  }
  dispose() {
    this.toDispose = z(this.toDispose);
  }
};
nn = E([
  g(1, Qe),
  g(2, G),
  g(3, Ie),
  g(4, re),
  g(5, ri),
  g(6, Dt),
  g(7, Fa),
  g(8, Je),
  g(9, W)
], nn);
class vs {
  constructor(e, t) {
    this.configurationManager = e, this.adapterManager = t;
  }
  getCompound(e) {
    const t = this.getConfig();
    if (!(!t || !t.compounds))
      return t.compounds.find((i) => i.name === e);
  }
  getConfigurationNames(e = !1) {
    const t = this.getConfig();
    if (!t || !Array.isArray(t.configurations) && !Array.isArray(t.compounds))
      return [];
    {
      const i = [];
      return t.configurations && i.push(...t.configurations.filter((n) => n && typeof n.name == "string")), e ? i.map((n) => n.name) : (t.compounds && i.push(...t.compounds.filter((n) => typeof n.name == "string" && n.configurations && n.configurations.length)), Ho(i).map((n) => n.name));
    }
  }
  getConfiguration(e) {
    const t = nt(this.getConfig());
    if (!t || !t.configurations)
      return;
    const i = t.configurations.find((n) => n && n.name === e);
    return i && (this instanceof Yt ? i.__configurationTarget = 2 : this instanceof Jt ? i.__configurationTarget = 5 : i.__configurationTarget = 6), i;
  }
  async getInitialConfigurationContent(e, t, i, n) {
    let s = "";
    const o = t ? this.adapterManager.getEnabledDebugger(t) : await this.adapterManager.guessDebugger(!0);
    if (o) {
      const r = i ? await this.configurationManager.provideDebugConfigurations(e, o.type, n || qa.None) : [];
      s = await o.getInitialConfigurationContent(r);
    }
    return s;
  }
  get hidden() {
    return !1;
  }
}
let sn = class extends vs {
  constructor(e, t, i, n, s, o, r) {
    super(e, t), this.workspace = i, this.fileService = n, this.textFileService = s, this.editorService = o, this.configurationService = r;
  }
  get uri() {
    return Ha(this.workspace.uri, "/.vscode/launch.json");
  }
  get name() {
    return this.workspace.name;
  }
  getConfig() {
    return this.configurationService.inspect("launch", { resource: this.workspace.uri }).workspaceFolderValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, suppressInitialConfigs: i }, n) {
    const s = this.uri;
    let o = !1, r = "";
    try {
      r = (await this.fileService.readFile(s)).value.toString();
    } catch {
      if (r = await this.getInitialConfigurationContent(this.workspace.uri, t, !i, n), !r)
        return { editor: null, created: !1 };
      o = !0;
      try {
        await this.textFileService.write(s, r);
      } catch (p) {
        throw new Error(c("DebugConfig.failed", "Unable to create 'launch.json' file inside the '.vscode' folder ({0}).", p.message));
      }
    }
    const a = r.indexOf(`"${this.configurationManager.selectedConfiguration.name}"`);
    let u = 1;
    for (let p = 0; p < a; p++)
      r.charAt(p) === `
` && u++;
    const l = u > 1 ? { startLineNumber: u, startColumn: 4 } : void 0, h = await this.editorService.openEditor({
      resource: s,
      options: {
        selection: l,
        preserveFocus: e,
        pinned: o,
        revealIfVisible: !0
      }
    }, si);
    return {
      editor: ai(h),
      created: o
    };
  }
  async writeConfiguration(e) {
    const t = nt(this.getConfig());
    t.configurations || (t.configurations = []), t.configurations.push(e), await this.configurationService.updateValue("launch", t, { resource: this.workspace.uri }, 6);
  }
};
sn = E([
  g(3, Kn),
  g(4, Un),
  g(5, se),
  g(6, G)
], sn);
let Jt = class extends vs {
  constructor(e, t, i, n, s) {
    super(e, t), this.editorService = i, this.configurationService = n, this.contextService = s;
  }
  get workspace() {
  }
  get uri() {
    return this.contextService.getWorkspace().configuration;
  }
  get name() {
    return c("workspace", "workspace");
  }
  getConfig() {
    return this.configurationService.inspect("launch").workspaceValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, useInitialConfigs: i }, n) {
    if (!!!this.getConfig()) {
      const r = await this.getInitialConfigurationContent(void 0, t, i, n);
      if (r)
        await this.configurationService.updateValue("launch", $a(r), 5);
      else
        return { editor: null, created: !1 };
    }
    const o = await this.editorService.openEditor({
      resource: this.contextService.getWorkspace().configuration,
      options: { preserveFocus: e }
    }, si);
    return {
      editor: ai(o),
      created: !1
    };
  }
};
Jt = E([
  g(2, se),
  g(3, G),
  g(4, Qe)
], Jt);
let Yt = class extends vs {
  constructor(e, t, i, n) {
    super(e, t), this.configurationService = i, this.preferencesService = n;
  }
  get workspace() {
  }
  get uri() {
    return this.preferencesService.userSettingsResource;
  }
  get name() {
    return c("user settings", "user settings");
  }
  get hidden() {
    return !0;
  }
  getConfig() {
    return this.configurationService.inspect("launch").userValue;
  }
  async openConfigFile({ preserveFocus: e, type: t, useInitialContent: i }) {
    const n = await this.preferencesService.openUserSettings({ jsonEditor: !0, preserveFocus: e, revealSetting: { key: "launch" } });
    return {
      editor: ai(n),
      created: !1
    };
  }
};
Yt = E([
  g(2, G),
  g(3, Va)
], Yt);
const gl = /range=([0-9]+):([0-9]+)/;
class pl {
  constructor(e) {
    this.debugService = e, this.memoryFdCounter = 0, this.fdMemory = /* @__PURE__ */ new Map(), this.changeEmitter = new v(), this.onDidChangeCapabilities = ne.None, this.onDidChangeFile = this.changeEmitter.event, this.capabilities = 1028, e.onDidEndSession((t) => {
      for (const [i, n] of this.fdMemory)
        n.session === t && this.close(i);
    });
  }
  watch(e, t) {
    if (t.recursive)
      return $o(() => {
      });
    const { session: i, memoryReference: n, offset: s } = this.parseUri(e), o = new oe();
    return o.add(i.onDidChangeState(() => {
      (i.state === 3 || i.state === 0) && this.changeEmitter.fire([{ type: 2, resource: e }]);
    })), o.add(i.onDidInvalidateMemory((r) => {
      r.body.memoryReference === n && (s && (r.body.offset >= s.toOffset || r.body.offset + r.body.count < s.fromOffset) || this.changeEmitter.fire([{ resource: e, type: 0 }]));
    })), o;
  }
  stat(e) {
    const { readOnly: t } = this.parseUri(e);
    return Promise.resolve({
      type: Ka.File,
      mtime: 0,
      ctime: 0,
      size: 0,
      permissions: t ? za.Readonly : void 0
    });
  }
  mkdir() {
    throw he("Not allowed", ge.NoPermissions);
  }
  readdir() {
    throw he("Not allowed", ge.NoPermissions);
  }
  delete() {
    throw he("Not allowed", ge.NoPermissions);
  }
  rename() {
    throw he("Not allowed", ge.NoPermissions);
  }
  open(e, t) {
    const { session: i, memoryReference: n, offset: s } = this.parseUri(e), o = this.memoryFdCounter++;
    let r = i.getMemory(n);
    return s && (r = new fl(r, s)), this.fdMemory.set(o, { session: i, region: r }), Promise.resolve(o);
  }
  close(e) {
    var t;
    return (t = this.fdMemory.get(e)) == null || t.region.dispose(), this.fdMemory.delete(e), Promise.resolve();
  }
  async writeFile(e, t) {
    const { offset: i } = this.parseUri(e);
    if (!i)
      throw he("Range must be present to read a file", ge.FileNotFound);
    const n = await this.open(e, { create: !1 });
    try {
      await this.write(n, i.fromOffset, t, 0, t.length);
    } finally {
      this.close(n);
    }
  }
  async readFile(e) {
    const { offset: t } = this.parseUri(e);
    if (!t)
      throw he("Range must be present to read a file", ge.FileNotFound);
    const i = new Uint8Array(t.toOffset - t.fromOffset), n = await this.open(e, { create: !1 });
    try {
      return await this.read(n, t.fromOffset, i, 0, i.length), i;
    } finally {
      this.close(n);
    }
  }
  async read(e, t, i, n, s) {
    const o = this.fdMemory.get(e);
    if (!o)
      throw he("No file with that descriptor open", ge.Unavailable);
    const r = await o.region.read(t, s);
    let a = 0;
    for (const u of r)
      switch (u.type) {
        case 1:
          return a;
        case 2:
          if (a > 0)
            return a;
          throw he(u.error, ge.Unknown);
        case 0: {
          const l = Math.max(0, t - u.offset), h = u.data.slice(l, Math.min(u.data.byteLength, l + (s - a)));
          i.set(h.buffer, n + a), a += h.byteLength;
          break;
        }
        default:
          Ga();
      }
    return a;
  }
  write(e, t, i, n, s) {
    const o = this.fdMemory.get(e);
    if (!o)
      throw he("No file with that descriptor open", ge.Unavailable);
    return o.region.write(t, Ri.wrap(i).slice(n, n + s));
  }
  parseUri(e) {
    if (e.scheme !== Gt)
      throw he(`Cannot open file with scheme ${e.scheme}`, ge.FileNotFound);
    const t = this.debugService.getModel().getSession(e.authority);
    if (!t)
      throw he("Debug session not found", ge.FileNotFound);
    let i;
    const n = gl.exec(e.query);
    n && (i = { fromOffset: Number(n[1]), toOffset: Number(n[2]) });
    const [, s] = e.path.split("/");
    return {
      session: t,
      offset: i,
      readOnly: !t.capabilities.supportsWriteMemoryRequest,
      sessionId: e.authority,
      memoryReference: decodeURIComponent(s)
    };
  }
}
class fl extends ae {
  constructor(e, t) {
    super(), this.parent = e, this.range = t, this.invalidateEmitter = new v(), this.onDidInvalidate = this.invalidateEmitter.event, this.width = this.range.toOffset - this.range.fromOffset, this.writable = e.writable, this._register(e), this._register(e.onDidInvalidate((i) => {
      const n = Ps(i.fromOffset - t.fromOffset, 0, this.width), s = Ps(i.toOffset - t.fromOffset, 0, this.width);
      s > n && this.invalidateEmitter.fire({ fromOffset: n, toOffset: s });
    }));
  }
  read(e, t) {
    if (e < 0)
      throw new RangeError(`Invalid fromOffset: ${e}`);
    return this.parent.read(this.range.fromOffset + e, this.range.fromOffset + Math.min(t, this.width));
  }
  write(e, t) {
    return this.parent.write(this.range.fromOffset + e, t);
  }
}
let on = class {
  constructor(e, t, i, n, s, o, r, a) {
    this.dbgr = t, this.sessionId = i, this.name = n, this.extensionHostDebugService = s, this.openerService = o, this.notificationService = r, this.dialogSerivce = a, this.allThreadsContinued = !0, this._readyForBreakpoints = !1, this.debugAdapterStopped = !1, this.inShutdown = !1, this.terminated = !1, this.firedAdapterExitEvent = !1, this.startTime = 0, this.didReceiveStoppedEvent = !1, this._onDidInitialize = new v(), this._onDidStop = new v(), this._onDidContinued = new v(), this._onDidTerminateDebugee = new v(), this._onDidExitDebugee = new v(), this._onDidThread = new v(), this._onDidOutput = new v(), this._onDidBreakpoint = new v(), this._onDidLoadedSource = new v(), this._onDidProgressStart = new v(), this._onDidProgressUpdate = new v(), this._onDidProgressEnd = new v(), this._onDidInvalidated = new v(), this._onDidInvalidateMemory = new v(), this._onDidCustomEvent = new v(), this._onDidEvent = new v(), this._onDidExitAdapter = new v(), this.toDispose = [], this.debugAdapter = e, this._capabilities = /* @__PURE__ */ Object.create(null), this.toDispose.push(this.debugAdapter.onError((u) => {
      this.shutdown(u);
    })), this.toDispose.push(this.debugAdapter.onExit((u) => {
      u !== 0 ? this.shutdown(new Error(`exit code: ${u}`)) : this.shutdown();
    })), this.debugAdapter.onEvent((u) => {
      switch (u.event) {
        case "initialized":
          this._readyForBreakpoints = !0, this._onDidInitialize.fire(u);
          break;
        case "loadedSource":
          this._onDidLoadedSource.fire(u);
          break;
        case "capabilities":
          if (u.body) {
            const l = u.body.capabilities;
            this.mergeCapabilities(l);
          }
          break;
        case "stopped":
          this.didReceiveStoppedEvent = !0, this._onDidStop.fire(u);
          break;
        case "continued":
          this.allThreadsContinued = u.body.allThreadsContinued !== !1, this._onDidContinued.fire(u);
          break;
        case "thread":
          this._onDidThread.fire(u);
          break;
        case "output":
          this._onDidOutput.fire(u);
          break;
        case "breakpoint":
          this._onDidBreakpoint.fire(u);
          break;
        case "terminated":
          this._onDidTerminateDebugee.fire(u);
          break;
        case "exit":
          this._onDidExitDebugee.fire(u);
          break;
        case "progressStart":
          this._onDidProgressStart.fire(u);
          break;
        case "progressUpdate":
          this._onDidProgressUpdate.fire(u);
          break;
        case "progressEnd":
          this._onDidProgressEnd.fire(u);
          break;
        case "invalidated":
          this._onDidInvalidated.fire(u);
          break;
        case "memory":
          this._onDidInvalidateMemory.fire(u);
          break;
        case "process":
          break;
        case "module":
          break;
        default:
          this._onDidCustomEvent.fire(u);
          break;
      }
      this._onDidEvent.fire(u);
    }), this.debugAdapter.onRequest((u) => this.dispatchRequest(u));
  }
  get isInShutdown() {
    return this.inShutdown;
  }
  get onDidExitAdapter() {
    return this._onDidExitAdapter.event;
  }
  get capabilities() {
    return this._capabilities;
  }
  get readyForBreakpoints() {
    return this._readyForBreakpoints;
  }
  get onDidInitialize() {
    return this._onDidInitialize.event;
  }
  get onDidStop() {
    return this._onDidStop.event;
  }
  get onDidContinued() {
    return this._onDidContinued.event;
  }
  get onDidTerminateDebugee() {
    return this._onDidTerminateDebugee.event;
  }
  get onDidExitDebugee() {
    return this._onDidExitDebugee.event;
  }
  get onDidThread() {
    return this._onDidThread.event;
  }
  get onDidOutput() {
    return this._onDidOutput.event;
  }
  get onDidBreakpoint() {
    return this._onDidBreakpoint.event;
  }
  get onDidLoadedSource() {
    return this._onDidLoadedSource.event;
  }
  get onDidCustomEvent() {
    return this._onDidCustomEvent.event;
  }
  get onDidProgressStart() {
    return this._onDidProgressStart.event;
  }
  get onDidProgressUpdate() {
    return this._onDidProgressUpdate.event;
  }
  get onDidProgressEnd() {
    return this._onDidProgressEnd.event;
  }
  get onDidInvalidated() {
    return this._onDidInvalidated.event;
  }
  get onDidInvalidateMemory() {
    return this._onDidInvalidateMemory.event;
  }
  get onDidEvent() {
    return this._onDidEvent.event;
  }
  async start() {
    if (!this.debugAdapter)
      return Promise.reject(new Error(c("noDebugAdapterStart", "No debug adapter, can not start debug session.")));
    await this.debugAdapter.startSession(), this.startTime = (/* @__PURE__ */ new Date()).getTime();
  }
  async initialize(e) {
    const t = await this.send("initialize", e, void 0, void 0, !1);
    return t && this.mergeCapabilities(t.body), t;
  }
  disconnect(e) {
    const t = this.capabilities.supportTerminateDebuggee ? e.terminateDebuggee : void 0, i = this.capabilities.supportTerminateDebuggee && this.capabilities.supportSuspendDebuggee ? e.suspendDebuggee : void 0;
    return this.shutdown(void 0, e.restart, t, i);
  }
  async launchOrAttach(e) {
    const t = await this.send(e.request, e, void 0, void 0, !1);
    return t && this.mergeCapabilities(t.body), t;
  }
  terminate(e = !1) {
    return this.capabilities.supportsTerminateRequest ? this.terminated ? this.disconnect({ terminateDebuggee: !0, restart: e }) : (this.terminated = !0, this.send("terminate", { restart: e }, void 0)) : Promise.reject(new Error("terminated not supported"));
  }
  restart(e) {
    return this.capabilities.supportsRestartRequest ? this.send("restart", e) : Promise.reject(new Error("restart not supported"));
  }
  async next(e) {
    const t = await this.send("next", e);
    return this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async stepIn(e) {
    const t = await this.send("stepIn", e);
    return this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async stepOut(e) {
    const t = await this.send("stepOut", e);
    return this.fireSimulatedContinuedEvent(e.threadId), t;
  }
  async continue(e) {
    const t = await this.send("continue", e);
    return t && t.body && t.body.allThreadsContinued !== void 0 && (this.allThreadsContinued = t.body.allThreadsContinued), this.fireSimulatedContinuedEvent(e.threadId, this.allThreadsContinued), t;
  }
  pause(e) {
    return this.send("pause", e);
  }
  terminateThreads(e) {
    return this.capabilities.supportsTerminateThreadsRequest ? this.send("terminateThreads", e) : Promise.reject(new Error("terminateThreads not supported"));
  }
  setVariable(e) {
    return this.capabilities.supportsSetVariable ? this.send("setVariable", e) : Promise.reject(new Error("setVariable not supported"));
  }
  setExpression(e) {
    return this.capabilities.supportsSetExpression ? this.send("setExpression", e) : Promise.reject(new Error("setExpression not supported"));
  }
  async restartFrame(e, t) {
    if (this.capabilities.supportsRestartFrame) {
      const i = await this.send("restartFrame", e);
      return this.fireSimulatedContinuedEvent(t), i;
    }
    return Promise.reject(new Error("restartFrame not supported"));
  }
  stepInTargets(e) {
    return this.capabilities.supportsStepInTargetsRequest ? this.send("stepInTargets", e) : Promise.reject(new Error("stepInTargets not supported"));
  }
  completions(e, t) {
    return this.capabilities.supportsCompletionsRequest ? this.send("completions", e, t) : Promise.reject(new Error("completions not supported"));
  }
  setBreakpoints(e) {
    return this.send("setBreakpoints", e);
  }
  setFunctionBreakpoints(e) {
    return this.capabilities.supportsFunctionBreakpoints ? this.send("setFunctionBreakpoints", e) : Promise.reject(new Error("setFunctionBreakpoints not supported"));
  }
  dataBreakpointInfo(e) {
    return this.capabilities.supportsDataBreakpoints ? this.send("dataBreakpointInfo", e) : Promise.reject(new Error("dataBreakpointInfo not supported"));
  }
  setDataBreakpoints(e) {
    return this.capabilities.supportsDataBreakpoints ? this.send("setDataBreakpoints", e) : Promise.reject(new Error("setDataBreakpoints not supported"));
  }
  setExceptionBreakpoints(e) {
    return this.send("setExceptionBreakpoints", e);
  }
  breakpointLocations(e) {
    return this.capabilities.supportsBreakpointLocationsRequest ? this.send("breakpointLocations", e) : Promise.reject(new Error("breakpointLocations is not supported"));
  }
  configurationDone() {
    return this.capabilities.supportsConfigurationDoneRequest ? this.send("configurationDone", null) : Promise.reject(new Error("configurationDone not supported"));
  }
  stackTrace(e, t) {
    return this.send("stackTrace", e, t);
  }
  exceptionInfo(e) {
    return this.capabilities.supportsExceptionInfoRequest ? this.send("exceptionInfo", e) : Promise.reject(new Error("exceptionInfo not supported"));
  }
  scopes(e, t) {
    return this.send("scopes", e, t);
  }
  variables(e, t) {
    return this.send("variables", e, t);
  }
  source(e) {
    return this.send("source", e);
  }
  loadedSources(e) {
    return this.capabilities.supportsLoadedSourcesRequest ? this.send("loadedSources", e) : Promise.reject(new Error("loadedSources not supported"));
  }
  threads() {
    return this.send("threads", null);
  }
  evaluate(e) {
    return this.send("evaluate", e);
  }
  async stepBack(e) {
    if (this.capabilities.supportsStepBack) {
      const t = await this.send("stepBack", e);
      return this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("stepBack not supported"));
  }
  async reverseContinue(e) {
    if (this.capabilities.supportsStepBack) {
      const t = await this.send("reverseContinue", e);
      return this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("reverseContinue not supported"));
  }
  gotoTargets(e) {
    return this.capabilities.supportsGotoTargetsRequest ? this.send("gotoTargets", e) : Promise.reject(new Error("gotoTargets is not supported"));
  }
  async goto(e) {
    if (this.capabilities.supportsGotoTargetsRequest) {
      const t = await this.send("goto", e);
      return this.fireSimulatedContinuedEvent(e.threadId), t;
    }
    return Promise.reject(new Error("goto is not supported"));
  }
  async setInstructionBreakpoints(e) {
    return this.capabilities.supportsInstructionBreakpoints ? await this.send("setInstructionBreakpoints", e) : Promise.reject(new Error("setInstructionBreakpoints is not supported"));
  }
  async disassemble(e) {
    return this.capabilities.supportsDisassembleRequest ? await this.send("disassemble", e) : Promise.reject(new Error("disassemble is not supported"));
  }
  async readMemory(e) {
    return this.capabilities.supportsReadMemoryRequest ? await this.send("readMemory", e) : Promise.reject(new Error("readMemory is not supported"));
  }
  async writeMemory(e) {
    return this.capabilities.supportsWriteMemoryRequest ? await this.send("writeMemory", e) : Promise.reject(new Error("writeMemory is not supported"));
  }
  cancel(e) {
    return this.send("cancel", e);
  }
  custom(e, t) {
    return this.send(e, t);
  }
  async shutdown(e, t = !1, i = void 0, n = void 0) {
    if (!this.inShutdown)
      if (this.inShutdown = !0, this.debugAdapter)
        try {
          const s = { restart: t };
          typeof i == "boolean" && (s.terminateDebuggee = i), typeof n == "boolean" && (s.suspendDebuggee = n), await this.send("disconnect", s, void 0, 2e3);
        } catch {
        } finally {
          await this.stopAdapter(e);
        }
      else
        return this.stopAdapter(e);
  }
  async stopAdapter(e) {
    try {
      if (this.debugAdapter) {
        const t = this.debugAdapter;
        this.debugAdapter = null, await t.stopSession(), this.debugAdapterStopped = !0;
      }
    } finally {
      this.fireAdapterExitEvent(e);
    }
  }
  fireAdapterExitEvent(e) {
    if (!this.firedAdapterExitEvent) {
      this.firedAdapterExitEvent = !0;
      const t = {
        emittedStopped: this.didReceiveStoppedEvent,
        sessionLengthInSeconds: ((/* @__PURE__ */ new Date()).getTime() - this.startTime) / 1e3
      };
      e && !this.debugAdapterStopped && (t.error = e), this._onDidExitAdapter.fire(t);
    }
  }
  async dispatchRequest(e) {
    const t = {
      type: "response",
      seq: 0,
      command: e.command,
      request_seq: e.seq,
      success: !0
    }, i = (n) => this.debugAdapter && this.debugAdapter.sendResponse(n);
    if (e.command === "launchVSCode")
      try {
        let n = await this.launchVsCode(e.arguments);
        if (!n.success) {
          const { confirmed: s } = await this.dialogSerivce.confirm({
            type: Ko.Warning,
            message: c(
              "canNotStart",
              "The debugger needs to open a new tab or window for the debuggee but the browser prevented this. You must give permission to continue."
            ),
            primaryButton: c({ key: "continue", comment: ["&& denotes a mnemonic"] }, "&&Continue")
          });
          s ? n = await this.launchVsCode(e.arguments) : (t.success = !1, i(t), await this.shutdown());
        }
        t.body = {
          rendererDebugPort: n.rendererDebugPort
        }, i(t);
      } catch (n) {
        t.success = !1, t.message = n.message, i(t);
      }
    else if (e.command === "runInTerminal")
      try {
        const n = await this.dbgr.runInTerminal(e.arguments, this.sessionId), s = t;
        s.body = {}, typeof n == "number" && (s.body.shellProcessId = n), i(s);
      } catch (n) {
        t.success = !1, t.message = n.message, i(t);
      }
    else if (e.command === "startDebugging")
      try {
        const n = e.arguments, s = {
          ...n.configuration,
          request: n.request,
          type: this.dbgr.type,
          name: n.configuration.name || this.name
        };
        await this.dbgr.startDebugging(s, this.sessionId) || (t.success = !1, t.message = "Failed to start debugging"), i(t);
      } catch (n) {
        t.success = !1, t.message = n.message, i(t);
      }
    else
      t.success = !1, t.message = `unknown request '${e.command}'`, i(t);
  }
  launchVsCode(e) {
    const t = [];
    for (const i of e.args) {
      const n = (i.prefix || "") + (i.path || ""), s = /^--(.+)=(.+)$/.exec(n);
      if (s && s.length === 3) {
        const o = s[1];
        let r = s[2];
        (o === "file-uri" || o === "folder-uri") && !Ni(i.path) && (r = Ni(r) ? r : ee.file(r).toString()), t.push(`--${o}=${r}`);
      } else
        t.push(n);
    }
    return e.env && t.push(`--extensionEnvironment=${JSON.stringify(e.env)}`), this.extensionHostDebugService.openExtensionDevelopmentHostWindow(t, !!e.debugRenderer);
  }
  send(e, t, i, n, s = !0) {
    return new Promise((o, r) => {
      if (!this.debugAdapter) {
        this.inShutdown ? o(void 0) : r(new Error(c(
          "noDebugAdapter",
          "No debugger available found. Can not send '{0}'.",
          e
        )));
        return;
      }
      let a;
      const u = this.debugAdapter.sendRequest(e, t, (l) => {
        a == null || a.dispose(), l.success ? o(l) : r(l);
      }, n);
      i && (a = i.onCancellationRequested(() => {
        a.dispose(), this.capabilities.supportsCancelRequest && this.cancel({ requestId: u });
      }));
    }).then(void 0, (o) => Promise.reject(this.handleErrorResponse(o, s)));
  }
  handleErrorResponse(e, t) {
    var a;
    if (e.command === "canceled" && e.message === "canceled")
      return new ja();
    const i = (a = e == null ? void 0 : e.body) == null ? void 0 : a.error, n = (e == null ? void 0 : e.message) || "", s = i ? Xa(i.format, !1, i.variables) : n, o = i == null ? void 0 : i.url;
    if (i && o) {
      const u = i.urlLabel ? i.urlLabel : c("moreInfo", "More Info"), l = ee.parse(o), h = l.scheme === Pe.command ? "debug.moreInfo.command" : "debug.moreInfo";
      return zo(s, [Ja({ id: h, label: u, run: () => this.openerService.open(l, { allowCommands: !0 }) })]);
    }
    t && i && i.format && i.showUser && this.notificationService.error(s);
    const r = new Go(s);
    return r.showUser = i == null ? void 0 : i.showUser, r;
  }
  mergeCapabilities(e) {
    e && (this._capabilities = Hn(this._capabilities, e));
  }
  fireSimulatedContinuedEvent(e, t = !1) {
    this._onDidContinued.fire({
      type: "event",
      event: "continued",
      body: {
        threadId: e,
        allThreadsContinued: t
      },
      seq: void 0
    });
  }
  dispose() {
    z(this.toDispose);
  }
};
on = E([
  g(4, qo),
  g(5, zn),
  g(6, Re),
  g(7, Et)
], on);
const go = 1e4;
let bl = 0;
const Ii = () => `topReplElement:${bl++}`;
class $t {
  constructor(e, t, i, n, s, o) {
    this.session = e, this.id = t, this.value = i, this.severity = n, this.sourceData = s, this.expression = o, this._count = 1, this._onDidChangeCount = new v();
  }
  toString(e = !1) {
    let t = this.value;
    for (let n = 1; n < this.count; n++)
      t += (t.endsWith(`
`) ? "" : `
`) + this.value;
    const i = this.sourceData && e ? ` ${this.sourceData.source.name}` : "";
    return t + i;
  }
  getId() {
    return this.id;
  }
  getChildren() {
    var e;
    return ((e = this.expression) == null ? void 0 : e.getChildren()) || Promise.resolve([]);
  }
  set count(e) {
    this._count = e, this._onDidChangeCount.fire();
  }
  get count() {
    return this._count;
  }
  get onDidChangeCount() {
    return this._onDidChangeCount.event;
  }
  get hasChildren() {
    var e;
    return !!((e = this.expression) != null && e.hasChildren);
  }
}
class ml {
  constructor(e, t, i) {
    this.expr = e, this.severity = t, this.sourceData = i, this.id = le(), this.hasChildren = e.hasChildren;
  }
  getChildren() {
    return this.expr.getChildren();
  }
  toString() {
    return this.expr.toString();
  }
  getId() {
    return this.id;
  }
}
class Sl {
  constructor(e) {
    this.value = e, this.id = le();
  }
  toString() {
    return this.value;
  }
  getId() {
    return this.id;
  }
}
class Jr extends Y {
  get available() {
    return this._available;
  }
  constructor() {
    super(void 0, void 0, 0, le()), this._available = !0;
  }
  async evaluateExpression(e, t, i, n) {
    const s = await super.evaluateExpression(e, t, i, n);
    return this._available = s, s;
  }
  toString() {
    return `${this.value}`;
  }
}
class Ve {
  constructor(e, t, i) {
    this.name = e, this.autoExpand = t, this.sourceData = i, this.children = [], this.ended = !1, this.id = `replGroup:${Ve.COUNTER++}`;
  }
  get hasChildren() {
    return !0;
  }
  getId() {
    return this.id;
  }
  toString(e = !1) {
    const t = e && this.sourceData ? ` ${this.sourceData.source.name}` : "";
    return this.name + t;
  }
  addChild(e) {
    const t = this.children.length ? this.children[this.children.length - 1] : void 0;
    t instanceof Ve && !t.hasEnded ? t.addChild(e) : this.children.push(e);
  }
  getChildren() {
    return this.children;
  }
  end() {
    const e = this.children.length ? this.children[this.children.length - 1] : void 0;
    e instanceof Ve && !e.hasEnded ? e.end() : this.ended = !0;
  }
  get hasEnded() {
    return this.ended;
  }
}
Ve.COUNTER = 0;
function vl(d, e) {
  return !d && !e ? !0 : d && e ? d.column === e.column && d.lineNumber === e.lineNumber && d.source.uri.toString() === e.source.uri.toString() : !1;
}
class ws {
  constructor(e) {
    this.configurationService = e, this.replElements = [], this._onDidChangeElements = new v(), this.onDidChangeElements = this._onDidChangeElements.event;
  }
  getReplElements() {
    return this.replElements;
  }
  async addReplExpression(e, t, i) {
    this.addReplElement(new Sl(i));
    const n = new Jr();
    await n.evaluateExpression(i, e, t, "repl"), this.addReplElement(n);
  }
  appendToRepl(e, { output: t, expression: i, sev: n, source: s }) {
    const o = "\x1B[2J", r = t.lastIndexOf(o);
    if (r !== -1 && (this.removeReplExpressions(), this.appendToRepl(e, { output: c("consoleCleared", "Console was cleared"), sev: ye.Ignore }), t = t.substring(r + o.length)), i) {
      this.addReplElement(t ? new $t(e, Ii(), t, n, s, i) : new ml(i, n, s));
      return;
    }
    const a = this.replElements.length ? this.replElements[this.replElements.length - 1] : void 0;
    if (a instanceof $t && a.severity === n) {
      const l = this.configurationService.getValue("debug");
      if (a.value === t && vl(a.sourceData, s) && l.console.collapseIdenticalLines) {
        a.count++;
        return;
      }
      if (!a.value.endsWith(`
`) && !a.value.endsWith(`\r
`) && a.count === 1) {
        this.replElements[this.replElements.length - 1] = new $t(e, Ii(), a.value + t, n, s), this._onDidChangeElements.fire();
        return;
      }
    }
    const u = new $t(e, Ii(), t, n, s);
    this.addReplElement(u);
  }
  startGroup(e, t, i) {
    const n = new Ve(e, t, i);
    this.addReplElement(n);
  }
  endGroup() {
    const e = this.replElements[this.replElements.length - 1];
    e instanceof Ve && e.end();
  }
  addReplElement(e) {
    const t = this.replElements.length ? this.replElements[this.replElements.length - 1] : void 0;
    t instanceof Ve && !t.hasEnded ? t.addChild(e) : (this.replElements.push(e), this.replElements.length > go && this.replElements.splice(0, this.replElements.length - go)), this._onDidChangeElements.fire();
  }
  removeReplExpressions() {
    this.replElements.length > 0 && (this.replElements = [], this._onDidChangeElements.fire());
  }
  clone() {
    const e = new ws(this.configurationService);
    return e.replElements = this.replElements.slice(), e;
  }
}
let rn = class {
  constructor(e, t, i, n, s, o, r, a, u, l, h, p, f, b, m, S, N, P, L) {
    this.id = e, this._configuration = t, this.root = i, this.model = n, this.debugService = o, this.telemetryService = r, this.hostService = a, this.configurationService = u, this.paneCompositeService = l, this.workspaceContextService = h, this.productService = p, this.notificationService = f, this.uriIdentityService = m, this.instantiationService = S, this.customEndpointTelemetryService = N, this.workbenchEnvironmentService = P, this.logService = L, this.initialized = !1, this.sources = /* @__PURE__ */ new Map(), this.threads = /* @__PURE__ */ new Map(), this.threadIds = [], this.cancellationMap = /* @__PURE__ */ new Map(), this.rawListeners = [], this.stoppedDetails = [], this._onDidChangeState = new v(), this._onDidEndAdapter = new v(), this._onDidLoadedSource = new v(), this._onDidCustomEvent = new v(), this._onDidProgressStart = new v(), this._onDidProgressUpdate = new v(), this._onDidProgressEnd = new v(), this._onDidInvalidMemory = new v(), this._onDidChangeREPLElements = new v(), this._onDidChangeName = new v(), this._options = s || {}, this.parentSession = this._options.parentSession, this.hasSeparateRepl() ? this.repl = new ws(this.configurationService) : this.repl = this.parentSession.repl;
    const V = new oe(), _ = V.add(new Za());
    _.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire()), b && V.add(b.onWillShutdown(() => {
      this.shutdown(), z(V);
    }));
    const T = this._options.compoundRoot;
    T && V.add(T.onDidSessionStop(() => this.terminate())), this.passFocusScheduler = new fe(() => {
      var ke;
      if (this.debugService.getModel().getSessions().some((D) => D.state === 2) || this.getAllThreads().some((D) => D.stopped))
        if (typeof this.lastContinuedThreadId == "number") {
          const D = this.debugService.getViewModel().focusedThread;
          if (D && D.threadId === this.lastContinuedThreadId && !D.stopped) {
            const j = (ke = this.getStoppedDetails()) == null ? void 0 : ke.threadId, gt = typeof j == "number" ? this.getThread(j) : void 0;
            this.debugService.focusStackFrame(void 0, gt);
          }
        } else {
          const D = this.debugService.getViewModel().focusedSession;
          D && D.getId() === this.getId() && D.state !== 2 && this.debugService.focusStackFrame(void 0);
        }
    }, 800);
    const ie = this._options.parentSession;
    ie && V.add(ie.onDidEndAdapter(() => {
      var ke;
      !this.hasSeparateRepl() && ((ke = this.raw) == null ? void 0 : ke.isInShutdown) === !1 && (this.repl = this.repl.clone(), _.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire()), this.parentSession = void 0);
    }));
  }
  getId() {
    return this.id;
  }
  setSubId(e) {
    this._subId = e;
  }
  getMemory(e) {
    return new Iu(e, this);
  }
  get subId() {
    return this._subId;
  }
  get configuration() {
    return this._configuration.resolved;
  }
  get unresolvedConfiguration() {
    return this._configuration.unresolved;
  }
  get lifecycleManagedByParent() {
    return !!this._options.lifecycleManagedByParent;
  }
  get compact() {
    return !!this._options.compact;
  }
  get saveBeforeRestart() {
    var e;
    return this._options.saveBeforeRestart ?? !((e = this._options) != null && e.parentSession);
  }
  get compoundRoot() {
    return this._options.compoundRoot;
  }
  get suppressDebugStatusbar() {
    return this._options.suppressDebugStatusbar ?? !1;
  }
  get suppressDebugToolbar() {
    return this._options.suppressDebugToolbar ?? !1;
  }
  get suppressDebugView() {
    return this._options.suppressDebugView ?? !1;
  }
  get autoExpandLazyVariables() {
    return this.configurationService.getValue("debug").autoExpandLazyVariables;
  }
  setConfiguration(e) {
    this._configuration = e;
  }
  getLabel() {
    return this.workspaceContextService.getWorkspace().folders.length > 1 && this.root ? `${this.name} (${je(this.root.uri)})` : this.name;
  }
  setName(e) {
    this._name = e, this._onDidChangeName.fire(e);
  }
  get name() {
    return this._name || this.configuration.name;
  }
  get state() {
    if (!this.initialized)
      return 1;
    if (!this.raw)
      return 0;
    const e = this.debugService.getViewModel().focusedThread;
    return e && e.session === this ? e.stopped ? 2 : 3 : this.getAllThreads().some((t) => t.stopped) ? 2 : 3;
  }
  get capabilities() {
    return this.raw ? this.raw.capabilities : /* @__PURE__ */ Object.create(null);
  }
  get onDidChangeState() {
    return this._onDidChangeState.event;
  }
  get onDidEndAdapter() {
    return this._onDidEndAdapter.event;
  }
  get onDidChangeReplElements() {
    return this._onDidChangeREPLElements.event;
  }
  get onDidChangeName() {
    return this._onDidChangeName.event;
  }
  get onDidCustomEvent() {
    return this._onDidCustomEvent.event;
  }
  get onDidLoadedSource() {
    return this._onDidLoadedSource.event;
  }
  get onDidProgressStart() {
    return this._onDidProgressStart.event;
  }
  get onDidProgressUpdate() {
    return this._onDidProgressUpdate.event;
  }
  get onDidProgressEnd() {
    return this._onDidProgressEnd.event;
  }
  get onDidInvalidateMemory() {
    return this._onDidInvalidMemory.event;
  }
  async initialize(e) {
    this.raw && await this.shutdown();
    try {
      const t = await e.createDebugAdapter(this);
      this.raw = this.instantiationService.createInstance(on, t, e, this.id, this.configuration.name), await this.raw.start(), this.registerListeners(), await this.raw.initialize({
        clientID: "vscode",
        clientName: this.productService.nameLong,
        adapterID: this.configuration.type,
        pathFormat: "path",
        linesStartAt1: !0,
        columnsStartAt1: !0,
        supportsVariableType: !0,
        supportsVariablePaging: !0,
        supportsRunInTerminalRequest: !0,
        locale: ed,
        supportsProgressReporting: !0,
        supportsInvalidatedEvent: !0,
        supportsMemoryReferences: !0,
        supportsArgsCanBeInterpretedByShell: !0,
        supportsMemoryEvent: !0,
        supportsStartDebuggingRequest: !0
      }), this.initialized = !0, this._onDidChangeState.fire(), this.debugService.setExceptionBreakpointsForSession(this, this.raw && this.raw.capabilities.exceptionBreakpointFilters || []);
    } catch (t) {
      throw this.initialized = !0, this._onDidChangeState.fire(), await this.shutdown(), t;
    }
  }
  async launchOrAttach(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "launch or attach"));
    if (this.parentSession && this.parentSession.state === 0)
      throw td();
    e.__sessionId = this.getId();
    try {
      await this.raw.launchOrAttach(e);
    } catch (t) {
      throw this.shutdown(), t;
    }
  }
  async terminate(e = !1) {
    var t;
    this.raw || this.onDidExitAdapter(), this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.terminate(e) : this.raw && (this.raw.capabilities.supportsTerminateRequest && this._configuration.resolved.request === "launch" ? await this.raw.terminate(e) : await this.raw.disconnect({ restart: e, terminateDebuggee: !0 })), e || (t = this._options.compoundRoot) == null || t.sessionStopped();
  }
  async disconnect(e = !1, t = !1) {
    var i;
    this.raw || this.onDidExitAdapter(), this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.disconnect(e, t) : this.raw && await this.raw.disconnect({ restart: e, terminateDebuggee: !1, suspendDebuggee: t }), e || (i = this._options.compoundRoot) == null || i.sessionStopped();
  }
  async restart() {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "restart"));
    this.cancelAllRequests(), this._options.lifecycleManagedByParent && this.parentSession ? await this.parentSession.restart() : await this.raw.restart({ arguments: this.configuration });
  }
  async sendBreakpoints(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "breakpoints"));
    if (!this.raw.readyForBreakpoints)
      return Promise.resolve(void 0);
    const n = this.getRawSource(e);
    t.length && !n.adapterData && (n.adapterData = t[0].adapterData), n.path && (n.path = id(n.path));
    const s = await this.raw.setBreakpoints({
      source: n,
      lines: t.map((o) => o.sessionAgnosticData.lineNumber),
      breakpoints: t.map(
        (o) => ({ line: o.sessionAgnosticData.lineNumber, column: o.sessionAgnosticData.column, condition: o.condition, hitCondition: o.hitCondition, logMessage: o.logMessage })
      ),
      sourceModified: i
    });
    if (s && s.body) {
      const o = /* @__PURE__ */ new Map();
      for (let r = 0; r < t.length; r++)
        o.set(t[r].getId(), s.body.breakpoints[r]);
      this.model.setBreakpointSessionData(this.getId(), this.capabilities, o);
    }
  }
  async sendFunctionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "function breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setFunctionBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let n = 0; n < e.length; n++)
          i.set(e[n].getId(), t.body.breakpoints[n]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async sendExceptionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "exception breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = this.capabilities.supportsExceptionFilterOptions ? {
        filters: [],
        filterOptions: e.map((n) => n.condition ? { filterId: n.filter, condition: n.condition } : { filterId: n.filter })
      } : { filters: e.map((n) => n.filter) }, i = await this.raw.setExceptionBreakpoints(t);
      if (i && i.body && i.body.breakpoints) {
        const n = /* @__PURE__ */ new Map();
        for (let s = 0; s < e.length; s++)
          n.set(e[s].getId(), i.body.breakpoints[s]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, n);
      }
    }
  }
  async dataBreakpointInfo(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "data breakpoints info"));
    if (!this.raw.readyForBreakpoints)
      throw new Error(c("sessionNotReadyForBreakpoints", "Session is not ready for breakpoints"));
    const i = await this.raw.dataBreakpointInfo({ name: e, variablesReference: t });
    return i == null ? void 0 : i.body;
  }
  async sendDataBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "data breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setDataBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let n = 0; n < e.length; n++)
          i.set(e[n].getId(), t.body.breakpoints[n]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async sendInstructionBreakpoints(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "instruction breakpoints"));
    if (this.raw.readyForBreakpoints) {
      const t = await this.raw.setInstructionBreakpoints({ breakpoints: e });
      if (t && t.body) {
        const i = /* @__PURE__ */ new Map();
        for (let n = 0; n < e.length; n++)
          i.set(e[n].getId(), t.body.breakpoints[n]);
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, i);
      }
    }
  }
  async breakpointsLocations(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "breakpoints locations"));
    const i = this.getRawSource(e), n = await this.raw.breakpointLocations({ source: i, line: t });
    if (!n || !n.body || !n.body.breakpoints)
      return [];
    const s = n.body.breakpoints.map((o) => ({ lineNumber: o.line, column: o.column || 1 }));
    return Le(s, (o) => `${o.lineNumber}:${o.column}`);
  }
  getDebugProtocolBreakpoint(e) {
    return this.model.getDebugProtocolBreakpoint(e, this.getId());
  }
  customRequest(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", e));
    return this.raw.custom(e, t);
  }
  stackTrace(e, t, i, n) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stackTrace"));
    const s = this.getNewCancellationToken(e, n);
    return this.raw.stackTrace({ threadId: e, startFrame: t, levels: i }, s);
  }
  async exceptionInfo(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "exceptionInfo"));
    const t = await this.raw.exceptionInfo({ threadId: e });
    if (t)
      return {
        id: t.body.exceptionId,
        description: t.body.description,
        breakMode: t.body.breakMode,
        details: t.body.details
      };
  }
  scopes(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "scopes"));
    const i = this.getNewCancellationToken(t);
    return this.raw.scopes({ frameId: e }, i);
  }
  variables(e, t, i, n, s) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "variables"));
    const o = t ? this.getNewCancellationToken(t) : void 0;
    return this.raw.variables({ variablesReference: e, filter: i, start: n, count: s }, o);
  }
  evaluate(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "evaluate"));
    return this.raw.evaluate({ expression: e, frameId: t, context: i });
  }
  async restartFrame(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "restartFrame"));
    await this.raw.restartFrame({ frameId: e }, t);
  }
  setLastSteppingGranularity(e, t) {
    const i = this.getThread(e);
    i && (i.lastSteppingGranularity = t);
  }
  async next(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "next"));
    this.setLastSteppingGranularity(e, t), await this.raw.next({ threadId: e, granularity: t });
  }
  async stepIn(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepIn"));
    this.setLastSteppingGranularity(e, i), await this.raw.stepIn({ threadId: e, targetId: t, granularity: i });
  }
  async stepOut(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepOut"));
    this.setLastSteppingGranularity(e, t), await this.raw.stepOut({ threadId: e, granularity: t });
  }
  async stepBack(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "stepBack"));
    this.setLastSteppingGranularity(e, t), await this.raw.stepBack({ threadId: e, granularity: t });
  }
  async continue(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "continue"));
    await this.raw.continue({ threadId: e });
  }
  async reverseContinue(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "reverse continue"));
    await this.raw.reverseContinue({ threadId: e });
  }
  async pause(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "pause"));
    await this.raw.pause({ threadId: e });
  }
  async terminateThreads(e) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "terminateThreads"));
    await this.raw.terminateThreads({ threadIds: e });
  }
  setVariable(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "setVariable"));
    return this.raw.setVariable({ variablesReference: e, name: t, value: i });
  }
  setExpression(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "setExpression"));
    return this.raw.setExpression({ expression: t, value: i, frameId: e });
  }
  gotoTargets(e, t, i) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "gotoTargets"));
    return this.raw.gotoTargets({ source: e, line: t, column: i });
  }
  goto(e, t) {
    if (!this.raw)
      throw new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "goto"));
    return this.raw.goto({ threadId: e, targetId: t });
  }
  loadSource(e) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "loadSource"
      )));
    const t = this.getSourceForUri(e);
    let i;
    if (t)
      i = t.raw;
    else {
      const n = qt.getEncodedDebugData(e);
      i = { path: n.path, sourceReference: n.sourceReference };
    }
    return this.raw.source({ sourceReference: i.sourceReference || 0, source: i });
  }
  async getLoadedSources() {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "getLoadedSources"
      )));
    const e = await this.raw.loadedSources({});
    return e && e.body && e.body.sources ? e.body.sources.map((t) => this.getSource(t)) : [];
  }
  async completions(e, t, i, n, s, o) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "completions"
      )));
    const r = this.getNewCancellationToken(t, o);
    return this.raw.completions({
      frameId: e,
      text: i,
      column: n.column,
      line: n.lineNumber
    }, r);
  }
  async stepInTargets(e) {
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "stepInTargets"
      )));
    const t = await this.raw.stepInTargets({ frameId: e });
    return t == null ? void 0 : t.body.targets;
  }
  async cancel(e) {
    return this.raw ? this.raw.cancel({ progressId: e }) : Promise.reject(new Error(c("noDebugAdapter", "No debugger available, can not send '{0}'", "cancel")));
  }
  async disassemble(e, t, i, n) {
    var o;
    if (!this.raw)
      return Promise.reject(new Error(c(
        "noDebugAdapter",
        "No debugger available, can not send '{0}'",
        "disassemble"
      )));
    const s = await this.raw.disassemble({ memoryReference: e, offset: t, instructionOffset: i, instructionCount: n, resolveSymbols: !0 });
    return (o = s == null ? void 0 : s.body) == null ? void 0 : o.instructions;
  }
  readMemory(e, t, i) {
    return this.raw ? this.raw.readMemory({ count: i, memoryReference: e, offset: t }) : Promise.reject(new Error(c(
      "noDebugAdapter",
      "No debugger available, can not send '{0}'",
      "readMemory"
    )));
  }
  writeMemory(e, t, i, n) {
    return this.raw ? this.raw.writeMemory({ memoryReference: e, offset: t, allowPartial: n, data: i }) : Promise.reject(new Error(c(
      "noDebugAdapter",
      "No debugger available, can not send '{0}'",
      "disassemble"
    )));
  }
  getThread(e) {
    return this.threads.get(e);
  }
  getAllThreads() {
    const e = [];
    return this.threadIds.forEach((t) => {
      const i = this.threads.get(t);
      i && e.push(i);
    }), e;
  }
  clearThreads(e, t = void 0) {
    if (t != null) {
      const i = this.threads.get(t);
      i && (i.clearCallStack(), i.stoppedDetails = void 0, i.stopped = !1, e && this.threads.delete(t));
    } else
      this.threads.forEach((i) => {
        i.clearCallStack(), i.stoppedDetails = void 0, i.stopped = !1;
      }), e && (this.threads.clear(), this.threadIds = [], Y.allValues.clear());
  }
  getStoppedDetails() {
    return this.stoppedDetails.length >= 1 ? this.stoppedDetails[0] : void 0;
  }
  rawUpdate(e) {
    this.threadIds = [], e.threads.forEach((i) => {
      if (this.threadIds.push(i.id), !this.threads.has(i.id))
        this.threads.set(i.id, new Du(this, i.name, i.id));
      else if (i.name) {
        const n = this.threads.get(i.id);
        n && (n.name = i.name);
      }
    }), this.threads.forEach((i) => {
      this.threadIds.indexOf(i.threadId) === -1 && this.threads.delete(i.threadId);
    });
    const t = e.stoppedDetails;
    if (t)
      if (t.allThreadsStopped)
        this.threads.forEach((i) => {
          var n;
          i.stoppedDetails = i.threadId === t.threadId ? t : { reason: (n = i.stoppedDetails) == null ? void 0 : n.reason }, i.stopped = !0, i.clearCallStack();
        });
      else {
        const i = typeof t.threadId == "number" ? this.threads.get(t.threadId) : void 0;
        i && (i.stoppedDetails = t, i.clearCallStack(), i.stopped = !0);
      }
  }
  async fetchThreads(e) {
    if (this.raw) {
      const t = await this.raw.threads();
      t && t.body && t.body.threads && this.model.rawUpdate({
        sessionId: this.getId(),
        threads: t.body.threads,
        stoppedDetails: e
      });
    }
  }
  initializeForTest(e) {
    this.raw = e, this.registerListeners();
  }
  registerListeners() {
    if (!this.raw)
      return;
    this.rawListeners.push(this.raw.onDidInitialize(async () => {
      jt(c("debuggingStarted", "Debugging started."));
      const t = async () => {
        var i;
        if (this.raw && this.raw.capabilities.supportsConfigurationDoneRequest)
          try {
            await this.raw.configurationDone();
          } catch (n) {
            this.notificationService.error(n), (i = this.raw) == null || i.disconnect({});
          }
      };
      try {
        await this.debugService.sendAllBreakpoints(this);
      } finally {
        await t(), await this.fetchThreads();
      }
    })), this.rawListeners.push(this.raw.onDidStop(async (t) => {
      this.passFocusScheduler.cancel(), this.stoppedDetails.push(t.body), await this.fetchThreads(t.body);
      const i = this.debugService.getViewModel().focusedThread, n = i !== void 0 && i.session === this && !this.threads.has(i.threadId);
      n && this.debugService.focusStackFrame(void 0, void 0);
      const s = typeof t.body.threadId == "number" ? this.getThread(t.body.threadId) : void 0;
      if (s) {
        const o = this.model.refreshTopOfCallstack(s), r = async () => {
          if (n || !t.body.preserveFocusHint && s.getCallStack().length) {
            const u = this.debugService.getViewModel().focusedStackFrame;
            if (!u || u.thread.session === this) {
              const l = !this.configurationService.getValue("debug").focusEditorOnBreak;
              await this.debugService.focusStackFrame(void 0, s, void 0, { preserveFocus: l });
            }
            s.stoppedDetails && (s.stoppedDetails.reason === "breakpoint" && this.configurationService.getValue("debug").openDebug === "openOnDebugBreak" && !this.suppressDebugView && await this.paneCompositeService.openPaneComposite(di, 0), this.configurationService.getValue("debug").focusWindowOnBreak && !this.workbenchEnvironmentService.extensionTestsLocationURI && await this.hostService.focus({ force: !0 }));
          }
        };
        await o.topCallStack, r(), await o.wholeCallStack;
        const a = this.debugService.getViewModel().focusedStackFrame;
        (!a || !a.source || a.source.presentationHint === "deemphasize" || a.presentationHint === "deemphasize") && r();
      }
      this._onDidChangeState.fire();
    })), this.rawListeners.push(this.raw.onDidThread((t) => {
      if (t.body.reason === "started")
        this.fetchThreadsScheduler || (this.fetchThreadsScheduler = new fe(() => {
          this.fetchThreads();
        }, 100), this.rawListeners.push(this.fetchThreadsScheduler)), this.fetchThreadsScheduler.isScheduled() || this.fetchThreadsScheduler.schedule();
      else if (t.body.reason === "exited") {
        this.model.clearThreads(this.getId(), !0, t.body.threadId);
        const i = this.debugService.getViewModel(), n = i.focusedThread;
        this.passFocusScheduler.cancel(), n && t.body.threadId === n.threadId && this.debugService.focusStackFrame(void 0, void 0, i.focusedSession, { explicit: !1 });
      }
    })), this.rawListeners.push(this.raw.onDidTerminateDebugee(async (t) => {
      jt(c("debuggingStopped", "Debugging stopped.")), t.body && t.body.restart ? await this.debugService.restartSession(this, t.body.restart) : this.raw && await this.raw.disconnect({ terminateDebuggee: !1 });
    })), this.rawListeners.push(this.raw.onDidContinued((t) => {
      const i = t.body.allThreadsContinued !== !1 ? void 0 : t.body.threadId;
      if (typeof i == "number") {
        this.stoppedDetails = this.stoppedDetails.filter((s) => s.threadId !== i);
        const n = this.cancellationMap.get(i);
        this.cancellationMap.delete(i), n == null || n.forEach((s) => s.cancel());
      } else
        this.stoppedDetails = [], this.cancelAllRequests();
      this.lastContinuedThreadId = i, this.passFocusScheduler.schedule(), this.model.clearThreads(this.getId(), !1, i), this._onDidChangeState.fire();
    }));
    const e = new Jo();
    this.rawListeners.push(this.raw.onDidOutput(async (t) => {
      const i = t.body.category === "stderr" ? ye.Error : t.body.category === "console" ? ye.Warning : ye.Info;
      if (t.body.variablesReference) {
        const n = t.body.source && t.body.line ? {
          lineNumber: t.body.line,
          column: t.body.column ? t.body.column : 1,
          source: this.getSource(t.body.source)
        } : void 0, o = new Y(this, void 0, t.body.variablesReference, le()).getChildren();
        e.queue(async () => {
          const r = await o;
          if (r.length === 1) {
            this.appendToRepl({ output: t.body.output, expression: r[0], sev: i, source: n }, t.body.category === "important");
            return;
          }
          r.forEach((a) => {
            a.name = null, this.appendToRepl({ output: "", expression: a, sev: i, source: n }, t.body.category === "important");
          });
        });
        return;
      }
      e.queue(async () => {
        if (!t.body || !this.raw)
          return;
        if (t.body.category === "telemetry") {
          const s = this.raw.dbgr.getCustomTelemetryEndpoint();
          if (s && this.telemetryService.telemetryLevel !== 0) {
            let o = t.body.data;
            !s.sendErrorTelemetry && t.body.data && (o = nd(t.body.data)), this.customEndpointTelemetryService.publicLog(s, t.body.output, o);
          }
          return;
        }
        const n = t.body.source && t.body.line ? {
          lineNumber: t.body.line,
          column: t.body.column ? t.body.column : 1,
          source: this.getSource(t.body.source)
        } : void 0;
        if (t.body.group === "start" || t.body.group === "startCollapsed") {
          const s = t.body.group === "start";
          this.repl.startGroup(t.body.output || "", s, n);
          return;
        }
        t.body.group === "end" && (this.repl.endGroup(), !t.body.output) || typeof t.body.output == "string" && this.appendToRepl({ output: t.body.output, sev: i, source: n }, t.body.category === "important");
      });
    })), this.rawListeners.push(this.raw.onDidBreakpoint((t) => {
      const i = t.body && t.body.breakpoint ? t.body.breakpoint.id : void 0, n = this.model.getBreakpoints().find((a) => a.getIdFromAdapter(this.getId()) === i), s = this.model.getFunctionBreakpoints().find((a) => a.getIdFromAdapter(this.getId()) === i), o = this.model.getDataBreakpoints().find((a) => a.getIdFromAdapter(this.getId()) === i), r = this.model.getExceptionBreakpoints().find((a) => a.getIdFromAdapter(this.getId()) === i);
      if (t.body.reason === "new" && t.body.breakpoint.source && t.body.breakpoint.line) {
        const a = this.getSource(t.body.breakpoint.source), u = this.model.addBreakpoints(a.uri, [{
          column: t.body.breakpoint.column,
          enabled: !0,
          lineNumber: t.body.breakpoint.line
        }], !1);
        if (u.length === 1) {
          const l = /* @__PURE__ */ new Map([[u[0].getId(), t.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, l);
        }
      }
      if (t.body.reason === "removed" && (n && this.model.removeBreakpoints([n]), s && this.model.removeFunctionBreakpoints(s.getId()), o && this.model.removeDataBreakpoints(o.getId())), t.body.reason === "changed") {
        if (n) {
          n.column || (t.body.breakpoint.column = void 0);
          const a = /* @__PURE__ */ new Map([[n.getId(), t.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, a);
        }
        if (s) {
          const a = /* @__PURE__ */ new Map([[s.getId(), t.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, a);
        }
        if (o) {
          const a = /* @__PURE__ */ new Map([[o.getId(), t.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, a);
        }
        if (r) {
          const a = /* @__PURE__ */ new Map([[r.getId(), t.body.breakpoint]]);
          this.model.setBreakpointSessionData(this.getId(), this.capabilities, a);
        }
      }
    })), this.rawListeners.push(this.raw.onDidLoadedSource((t) => {
      this._onDidLoadedSource.fire({
        reason: t.body.reason,
        source: this.getSource(t.body.source)
      });
    })), this.rawListeners.push(this.raw.onDidCustomEvent((t) => {
      this._onDidCustomEvent.fire(t);
    })), this.rawListeners.push(this.raw.onDidProgressStart((t) => {
      this._onDidProgressStart.fire(t);
    })), this.rawListeners.push(this.raw.onDidProgressUpdate((t) => {
      this._onDidProgressUpdate.fire(t);
    })), this.rawListeners.push(this.raw.onDidProgressEnd((t) => {
      this._onDidProgressEnd.fire(t);
    })), this.rawListeners.push(this.raw.onDidInvalidateMemory((t) => {
      this._onDidInvalidMemory.fire(t);
    })), this.rawListeners.push(this.raw.onDidInvalidated(async (t) => {
      t.body.areas && t.body.areas.length === 1 && (t.body.areas[0] === "variables" || t.body.areas[0] === "watch") || (this.cancelAllRequests(), this.model.clearThreads(this.getId(), !0), await this.fetchThreads(this.getStoppedDetails()));
      const i = this.debugService.getViewModel();
      i.focusedSession === this && i.updateViews();
    })), this.rawListeners.push(this.raw.onDidExitAdapter((t) => this.onDidExitAdapter(t)));
  }
  onDidExitAdapter(e) {
    this.initialized = !0, this.model.setBreakpointSessionData(this.getId(), this.capabilities, void 0), this.shutdown(), this._onDidEndAdapter.fire(e);
  }
  shutdown() {
    var e;
    z(this.rawListeners), this.raw && (this.raw.disconnect({}), this.raw.dispose(), this.raw = void 0), (e = this.fetchThreadsScheduler) == null || e.dispose(), this.fetchThreadsScheduler = void 0, this.passFocusScheduler.cancel(), this.passFocusScheduler.dispose(), this.model.clearThreads(this.getId(), !0), this._onDidChangeState.fire();
  }
  getSourceForUri(e) {
    return this.sources.get(this.uriIdentityService.asCanonicalUri(e).toString());
  }
  getSource(e) {
    let t = new qt(e, this.getId(), this.uriIdentityService, this.logService);
    const i = t.uri.toString(), n = this.sources.get(i);
    return n ? (t = n, t.raw = Hn(t.raw, e), t.raw && e && (t.raw.presentationHint = e.presentationHint)) : this.sources.set(i, t), t;
  }
  getRawSource(e) {
    const t = this.getSourceForUri(e);
    if (t)
      return t.raw;
    {
      const i = qt.getEncodedDebugData(e);
      return { name: i.name, path: i.path, sourceReference: i.sourceReference };
    }
  }
  getNewCancellationToken(e, t) {
    const i = new Me(t), n = this.cancellationMap.get(e) || [];
    return n.push(i), this.cancellationMap.set(e, n), i.token;
  }
  cancelAllRequests() {
    this.cancellationMap.forEach((e) => e.forEach((t) => t.cancel())), this.cancellationMap.clear();
  }
  getReplElements() {
    return this.repl.getReplElements();
  }
  hasSeparateRepl() {
    return !this.parentSession || this._options.repl !== "mergeWithParent";
  }
  removeReplExpressions() {
    this.repl.removeReplExpressions();
  }
  async addReplExpression(e, t) {
    await this.repl.addReplExpression(this, e, t), this.debugService.getViewModel().updateViews();
  }
  appendToRepl(e, t) {
    this.repl.appendToRepl(this, e), t && this.notificationService.notify({ message: e.toString(), severity: e.sev, source: this.name });
  }
};
rn = E([
  g(5, w),
  g(6, Bt),
  g(7, jo),
  g(8, G),
  g(9, Xo),
  g(10, Qe),
  g(11, Ya),
  g(12, Re),
  g(13, Vn),
  g(14, Je),
  g(15, re),
  g(16, Qa),
  g(17, Pn),
  g(18, It)
], rn);
var Qt;
(function(d) {
  d.MARKERS_CONTAINER_ID = "workbench.panel.markers", d.MARKERS_VIEW_ID = "workbench.panel.markers.view", d.MARKERS_VIEW_STORAGE_ID = "workbench.panel.markers", d.MARKER_COPY_ACTION_ID = "problems.action.copy", d.MARKER_COPY_MESSAGE_ACTION_ID = "problems.action.copyMessage", d.RELATED_INFORMATION_COPY_MESSAGE_ACTION_ID = "problems.action.copyRelatedInformationMessage", d.FOCUS_PROBLEMS_FROM_FILTER = "problems.action.focusProblemsFromFilter", d.MARKERS_VIEW_FOCUS_FILTER = "problems.action.focusFilter", d.MARKERS_VIEW_CLEAR_FILTER_TEXT = "problems.action.clearFilterText", d.MARKERS_VIEW_SHOW_MULTILINE_MESSAGE = "problems.action.showMultilineMessage", d.MARKERS_VIEW_SHOW_SINGLELINE_MESSAGE = "problems.action.showSinglelineMessage", d.MARKER_OPEN_ACTION_ID = "problems.action.open", d.MARKER_OPEN_SIDE_ACTION_ID = "problems.action.openToSide", d.MARKER_SHOW_PANEL_ID = "workbench.action.showErrorsWarnings", d.MARKER_SHOW_QUICK_FIX = "problems.action.showQuickFixes", d.TOGGLE_MARKERS_VIEW_ACTION_ID = "workbench.actions.view.toggleProblems";
})(Qt || (Qt = {}));
function _i(d, e) {
  return (t, i = null, n) => {
    const s = e((o) => {
      if (d(o))
        return s.dispose(), t.call(i, o);
    }, null, n);
    return s;
  };
}
const po = "debug.taskerrorchoice";
let an = class {
  constructor(e, t, i, n, s, o, r) {
    this.taskService = e, this.markerService = t, this.configurationService = i, this.viewsService = n, this.dialogService = s, this.storageService = o, this.commandService = r, this.canceled = !1;
  }
  cancel() {
    this.canceled = !0;
  }
  async runTaskAndCheckErrors(e, t) {
    try {
      this.canceled = !1;
      const i = await this.runTask(e, t);
      if (this.canceled || i && i.exitCode === void 0)
        return 0;
      const n = t ? this.markerService.read({ severities: rd.Error, take: 2 }).length : 0, s = i && i.exitCode === 0, o = i && i.exitCode !== 0, r = this.configurationService.getValue("debug").onTaskErrors;
      if (s || r === "debugAnyway" || n === 0 && !o)
        return 1;
      if (r === "showErrors")
        return await this.viewsService.openView(Qt.MARKERS_VIEW_ID, !0), Promise.resolve(0);
      if (r === "abort")
        return Promise.resolve(0);
      const a = typeof t == "string" ? t : t ? t.name : "", u = n > 1 ? c(
        "preLaunchTaskErrors",
        "Errors exist after running preLaunchTask '{0}'.",
        a
      ) : n === 1 ? c(
        "preLaunchTaskError",
        "Error exists after running preLaunchTask '{0}'.",
        a
      ) : i && typeof i.exitCode == "number" ? c(
        "preLaunchTaskExitCode",
        "The preLaunchTask '{0}' terminated with exit code {1}.",
        a,
        i.exitCode
      ) : c(
        "preLaunchTaskTerminated",
        "The preLaunchTask '{0}' terminated.",
        a
      );
      let l;
      (function(m) {
        m[m.DebugAnyway = 1] = "DebugAnyway", m[m.ShowErrors = 2] = "ShowErrors", m[m.Cancel = 0] = "Cancel";
      })(l || (l = {}));
      const { result: h, checkboxChecked: p } = await this.dialogService.prompt({
        type: ye.Warning,
        message: u,
        buttons: [
          {
            label: c(
              { key: "debugAnyway", comment: ["&& denotes a mnemonic"] },
              "&&Debug Anyway"
            ),
            run: () => l.DebugAnyway
          },
          {
            label: c({ key: "showErrors", comment: ["&& denotes a mnemonic"] }, "&&Show Errors"),
            run: () => l.ShowErrors
          }
        ],
        cancelButton: {
          label: c("abort", "Abort"),
          run: () => l.Cancel
        },
        checkbox: {
          label: c("remember", "Remember my choice in user settings")
        }
      }), f = h === l.DebugAnyway, b = h === l.Cancel;
      return p && this.configurationService.updateValue("debug.onTaskErrors", h === l.DebugAnyway ? "debugAnyway" : b ? "abort" : "showErrors"), b ? Promise.resolve(0) : f ? 1 : (await this.viewsService.openView(Qt.MARKERS_VIEW_ID, !0), Promise.resolve(0));
    } catch (i) {
      const n = this.taskService.configureAction(), s = JSON.parse(this.storageService.get(po, 1, "{}"));
      let o = -1, r;
      if (function(a) {
        a[a.DebugAnyway = 0] = "DebugAnyway", a[a.ConfigureTask = 1] = "ConfigureTask", a[a.Cancel = 2] = "Cancel";
      }(r || (r = {})), s[i.message] !== void 0)
        o = s[i.message];
      else {
        const { result: a, checkboxChecked: u } = await this.dialogService.prompt({
          type: ye.Error,
          message: i.message,
          buttons: [
            {
              label: c(
                { key: "debugAnyway", comment: ["&& denotes a mnemonic"] },
                "&&Debug Anyway"
              ),
              run: () => r.DebugAnyway
            },
            {
              label: n.label,
              run: () => r.ConfigureTask
            }
          ],
          cancelButton: {
            run: () => r.Cancel
          },
          checkbox: {
            label: c("rememberTask", "Remember my choice for this task")
          }
        });
        o = a, u && (s[i.message] = o, this.storageService.store(po, JSON.stringify(s), 1, 0));
      }
      return o === r.ConfigureTask && await n.run(), o === r.DebugAnyway ? 1 : 0;
    }
  }
  async runTask(e, t) {
    if (!t)
      return Promise.resolve(null);
    if (!e)
      return Promise.reject(new Error(c(
        "invalidTaskReference",
        "Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",
        typeof t == "string" ? t : t.type
      )));
    const i = await this.taskService.getTask(e, t);
    if (!i) {
      const r = typeof t == "string" ? c("DebugTaskNotFoundWithTaskId", "Could not find the task '{0}'.", t) : c("DebugTaskNotFound", "Could not find the specified task.");
      return Promise.reject(zo(r, [new J(
        Xt,
        Or,
        void 0,
        !0,
        () => this.commandService.executeCommand(Xt)
      )]));
    }
    let n = !1;
    const s = new Promise((r, a) => _i((u) => (u.kind === "inactive" || u.kind === "processEnded" && u.exitCode === void 0) && u.taskId === i._id, this.taskService.onDidStateChange)((u) => {
      n = !0, r(u.kind === "processEnded" ? { exitCode: u.exitCode } : null);
    })), o = this.taskService.getActiveTasks().then(async (r) => {
      if (r.find((u) => u._id === i._id))
        return (await this.taskService.getBusyTasks()).find((l) => l._id === i._id) ? (n = !0, s) : Promise.resolve(null);
      _i((u) => (u.kind === "active" || u.kind === "dependsOnStarted") && u.taskId === i._id, this.taskService.onDidStateChange)(() => {
        n = !0;
      });
      const a = this.taskService.run(i);
      return i.configurationProperties.isBackground ? s : a.then(ai);
    });
    return new Promise((r, a) => {
      const u = new Promise(
        (l) => _i((h) => h.kind === "acquiredInput" && h.taskId === i._id, this.taskService.onDidStateChange)(() => {
          l();
        })
      );
      o.then((l) => {
        n = !0, r(l);
      }, (l) => a(l)), u.then(() => {
        const l = i.configurationProperties.isBackground ? 5e3 : 1e4;
        setTimeout(() => {
          if (!n) {
            const h = typeof t == "string" ? c(
              "taskNotTrackedWithTaskId",
              "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
              t
            ) : c(
              "taskNotTracked",
              "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
              JSON.stringify(t)
            );
            a({ severity: ye.Error, message: h });
          }
        }, l);
      });
    });
  }
};
an = E([
  g(0, sd),
  g(1, od),
  g(2, G),
  g(3, st),
  g(4, Et),
  g(5, ri),
  g(6, _e)
], an);
class wl {
  constructor() {
    this.stopped = !1, this.stopEmitter = new v(), this.onDidSessionStop = this.stopEmitter.event;
  }
  sessionStopped() {
    this.stopped || (this.stopped = !0, this.stopEmitter.fire());
  }
}
const xi = "debug.breakpoint", Bi = "debug.functionbreakpoint", Ti = "debug.databreakpoint", Ai = "debug.exceptionbreakpoint", Li = "debug.watchexpressions", fo = "debug.chosenenvironment", bo = "debug.uxstate";
let dn = class {
  constructor(e, t, i, n) {
    this.storageService = e, this.textFileService = t, this.uriIdentityService = i, this.logService = n;
  }
  loadDebugUxState() {
    return this.storageService.get(bo, 1, "default");
  }
  storeDebugUxState(e) {
    this.storageService.store(bo, e, 1, 0);
  }
  loadBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(xi, 1, "[]")).map((t) => new Be(ee.parse(t.uri.external || t.source.uri.external), t.lineNumber, t.column, t.enabled, t.condition, t.hitCondition, t.logMessage, t.adapterData, this.textFileService, this.uriIdentityService, this.logService));
    } catch {
    }
    return e || [];
  }
  loadFunctionBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Bi, 1, "[]")).map((t) => new De(t.name, t.enabled, t.hitCondition, t.condition, t.logMessage));
    } catch {
    }
    return e || [];
  }
  loadExceptionBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Ai, 1, "[]")).map((t) => new qi(
        t.filter,
        t.label,
        t.enabled,
        t.supportsCondition,
        t.condition,
        t.description,
        t.conditionDescription,
        !!t.fallback
      ));
    } catch {
    }
    return e || [];
  }
  loadDataBreakpoints() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Ti, 1, "[]")).map((t) => new Te(
        t.description,
        t.dataId,
        !0,
        t.enabled,
        t.hitCondition,
        t.condition,
        t.logMessage,
        t.accessTypes,
        t.accessType
      ));
    } catch {
    }
    return e || [];
  }
  loadWatchExpressions() {
    let e;
    try {
      e = JSON.parse(this.storageService.get(Li, 1, "[]")).map((t) => new $(t.name, t.id));
    } catch {
    }
    return e || [];
  }
  loadChosenEnvironments() {
    return JSON.parse(this.storageService.get(fo, 1, "{}"));
  }
  storeChosenEnvironments(e) {
    this.storageService.store(fo, JSON.stringify(e), 1, 0);
  }
  storeWatchExpressions(e) {
    e.length ? this.storageService.store(Li, JSON.stringify(e.map((t) => ({ name: t.name, id: t.getId() }))), 1, 0) : this.storageService.remove(Li, 1);
  }
  storeBreakpoints(e) {
    const t = e.getBreakpoints();
    t.length ? this.storageService.store(xi, JSON.stringify(t), 1, 0) : this.storageService.remove(xi, 1);
    const i = e.getFunctionBreakpoints();
    i.length ? this.storageService.store(Bi, JSON.stringify(i), 1, 0) : this.storageService.remove(Bi, 1);
    const n = e.getDataBreakpoints().filter((o) => o.canPersist);
    n.length ? this.storageService.store(Ti, JSON.stringify(n), 1, 0) : this.storageService.remove(Ti, 1);
    const s = e.getExceptionBreakpoints();
    s.length ? this.storageService.store(Ai, JSON.stringify(s), 1, 0) : this.storageService.remove(Ai, 1);
  }
};
dn = E([
  g(0, ri),
  g(1, Un),
  g(2, Je),
  g(3, It)
], dn);
let cn = class {
  constructor(e, t) {
    this.model = e, this.telemetryService = t;
  }
  logDebugSessionStart(e, t) {
    const i = e.getMainExtensionDescriptor();
    this.telemetryService.publicLog("debugSessionStart", {
      type: e.type,
      breakpointCount: this.model.getBreakpoints().length,
      exceptionBreakpoints: this.model.getExceptionBreakpoints(),
      watchExpressionsCount: this.model.getWatchExpressions().length,
      extensionName: i.identifier.value,
      isBuiltin: i.isBuiltin,
      launchJsonExists: t
    });
  }
  logDebugSessionStop(e, t) {
    const i = this.model.getBreakpoints();
    this.telemetryService.publicLog("debugSessionStop", {
      type: e && e.configuration.type,
      success: t.emittedStopped || i.length === 0,
      sessionLengthInSeconds: t.sessionLengthInSeconds,
      breakpointCount: i.length,
      watchExpressionsCount: this.model.getWatchExpressions().length
    });
  }
};
cn = E([
  g(1, Bt)
], cn);
class kl {
  constructor(e) {
    this.contextKeyService = e, this.firstSessionStart = !0, this._onDidFocusSession = new v(), this._onDidFocusStackFrame = new v(), this._onDidSelectExpression = new v(), this._onDidEvaluateLazyExpression = new v(), this._onWillUpdateViews = new v(), e.bufferChangeEvents(() => {
      this.expressionSelectedContextKey = Wo.bindTo(e), this.loadedScriptsSupportedContextKey = ad.bindTo(e), this.stepBackSupportedContextKey = Gn.bindTo(e), this.focusedSessionIsAttach = me.bindTo(e), this.restartFrameSupportedContextKey = dd.bindTo(e), this.stepIntoTargetsSupported = Oo.bindTo(e), this.jumpToCursorSupported = No.bindTo(e), this.setVariableSupported = cd.bindTo(e), this.setExpressionSupported = ud.bindTo(e), this.multiSessionDebug = Yo.bindTo(e), this.terminateDebuggeeSupported = ot.bindTo(e), this.suspendDebuggeeSupported = Oi.bindTo(e), this.disassembleRequestSupported = ld.bindTo(e), this.focusedStackFrameHasInstructionPointerReference = hd.bindTo(e);
    });
  }
  getId() {
    return "root";
  }
  get focusedSession() {
    return this._focusedSession;
  }
  get focusedThread() {
    return this._focusedThread;
  }
  get focusedStackFrame() {
    return this._focusedStackFrame;
  }
  setFocus(e, t, i, n) {
    const s = this._focusedStackFrame !== e, o = this._focusedSession !== i;
    this._focusedStackFrame = e, this._focusedThread = t, this._focusedSession = i, this.contextKeyService.bufferChangeEvents(() => {
      this.loadedScriptsSupportedContextKey.set(i ? !!i.capabilities.supportsLoadedSourcesRequest : !1), this.stepBackSupportedContextKey.set(i ? !!i.capabilities.supportsStepBack : !1), this.restartFrameSupportedContextKey.set(i ? !!i.capabilities.supportsRestartFrame : !1), this.stepIntoTargetsSupported.set(i ? !!i.capabilities.supportsStepInTargetsRequest : !1), this.jumpToCursorSupported.set(i ? !!i.capabilities.supportsGotoTargetsRequest : !1), this.setVariableSupported.set(i ? !!i.capabilities.supportsSetVariable : !1), this.setExpressionSupported.set(i ? !!i.capabilities.supportsSetExpression : !1), this.terminateDebuggeeSupported.set(i ? !!i.capabilities.supportTerminateDebuggee : !1), this.suspendDebuggeeSupported.set(i ? !!i.capabilities.supportSuspendDebuggee : !1), this.disassembleRequestSupported.set(!!(i != null && i.capabilities.supportsDisassembleRequest)), this.focusedStackFrameHasInstructionPointerReference.set(!!(e != null && e.instructionPointerReference));
      const r = !!i && gd(i);
      this.focusedSessionIsAttach.set(r);
    }), o && this._onDidFocusSession.fire(i), s && this._onDidFocusStackFrame.fire({ stackFrame: e, explicit: n });
  }
  get onDidFocusSession() {
    return this._onDidFocusSession.event;
  }
  get onDidFocusStackFrame() {
    return this._onDidFocusStackFrame.event;
  }
  getSelectedExpression() {
    return this.selectedExpression;
  }
  setSelectedExpression(e, t) {
    this.selectedExpression = e ? { expression: e, settingWatch: t } : void 0, this.expressionSelectedContextKey.set(!!e), this._onDidSelectExpression.fire(this.selectedExpression);
  }
  get onDidSelectExpression() {
    return this._onDidSelectExpression.event;
  }
  get onDidEvaluateLazyExpression() {
    return this._onDidEvaluateLazyExpression.event;
  }
  updateViews() {
    this._onWillUpdateViews.fire();
  }
  get onWillUpdateViews() {
    return this._onWillUpdateViews.event;
  }
  isMultiSessionView() {
    return !!this.multiSessionDebug.get();
  }
  setMultiSessionView(e) {
    this.multiSessionDebug.set(e);
  }
  async evaluateLazyExpression(e) {
    await e.evaluateLazy(), this._onDidEvaluateLazyExpression.fire(e);
  }
}
let vt = class {
  constructor(e, t, i, n, s, o, r, a, u, l, h, p, f, b, m, S, N, P, L, V) {
    this.editorService = e, this.paneCompositeService = t, this.viewsService = i, this.viewDescriptorService = n, this.notificationService = s, this.dialogService = o, this.layoutService = r, this.contextService = a, this.contextKeyService = u, this.lifecycleService = l, this.instantiationService = h, this.extensionService = p, this.fileService = f, this.configurationService = b, this.extensionHostDebugService = m, this.activityService = S, this.commandService = N, this.quickInputService = P, this.workspaceTrustRequestService = L, this.uriIdentityService = V, this.disposables = new oe(), this.initializing = !1, this.sessionCancellationTokens = /* @__PURE__ */ new Map(), this.haveDoneLazySetup = !1, this.breakpointsToSendOnResourceSaved = /* @__PURE__ */ new Set(), this._onDidChangeState = new v(), this._onDidNewSession = new v(), this._onWillNewSession = new v(), this._onDidEndSession = new v(), this.adapterManager = this.instantiationService.createInstance(Ui, { onDidNewSession: this.onDidNewSession }), this.disposables.add(this.adapterManager), this.configurationManager = this.instantiationService.createInstance(nn, this.adapterManager), this.disposables.add(this.configurationManager), this.debugStorage = this.instantiationService.createInstance(dn), this.chosenEnvironments = this.debugStorage.loadChosenEnvironments(), this.model = this.instantiationService.createInstance(Ki, this.debugStorage), this.telemetry = this.instantiationService.createInstance(cn, this.model), this.viewModel = new kl(u), this.taskRunner = this.instantiationService.createInstance(an), this.disposables.add(this.fileService.onDidFilesChange((_) => this.onFileChanges(_))), this.disposables.add(this.lifecycleService.onWillShutdown(this.dispose, this)), this.disposables.add(this.extensionHostDebugService.onAttachSession((_) => {
      const T = this.model.getSession(_.sessionId, !0);
      T && (T.configuration.request = "attach", T.configuration.port = _.port, T.setSubId(_.subId), this.launchOrAttachToSession(T));
    })), this.disposables.add(this.extensionHostDebugService.onTerminateSession((_) => {
      const T = this.model.getSession(_.sessionId);
      T && T.subId === _.subId && T.disconnect();
    })), this.disposables.add(this.viewModel.onDidFocusStackFrame(() => {
      this.onStateChange();
    })), this.disposables.add(this.viewModel.onDidFocusSession((_) => {
      this.onStateChange(), _ && this.setExceptionBreakpointFallbackSession(_.getId());
    })), this.disposables.add(ne.any(this.adapterManager.onDidRegisterDebugger, this.configurationManager.onDidSelectConfiguration)(() => {
      const _ = this.state !== 0 || this.configurationManager.getAllConfigurations().length > 0 && this.adapterManager.hasEnabledDebuggers() ? "default" : "simple";
      this.debugUx.set(_), this.debugStorage.storeDebugUxState(_);
    })), this.disposables.add(this.model.onDidChangeCallStack(() => {
      var T;
      const _ = this.model.getSessions().filter((ie) => !ie.parentSession).length;
      if ((T = this.activity) == null || T.dispose(), _ > 0) {
        const ie = this.viewDescriptorService.getViewContainerByViewId(bd);
        ie && (this.activity = this.activityService.showViewContainerActivity(ie.id, { badge: new md(_, (ke) => ke === 1 ? c("1activeSession", "1 active session") : c("nActiveSessions", "{0} active sessions", ke)) }));
      }
    })), this.disposables.add(e.onDidActiveEditorChange(() => {
      this.contextKeyService.bufferChangeEvents(() => {
        var _;
        e.activeEditor === ce.instance ? this.disassemblyViewFocus.set(!0) : (_ = this.disassemblyViewFocus) == null || _.reset();
      });
    })), this.disposables.add(this.lifecycleService.onBeforeShutdown(() => {
      var _;
      for (const T of e.editors)
        ((_ = T.resource) == null ? void 0 : _.scheme) === Gt && T.dispose();
    })), this.initContextKeys(u);
  }
  initContextKeys(e) {
    queueMicrotask(() => {
      e.bufferChangeEvents(() => {
        this.debugType = Sd.bindTo(e), this.debugState = q.bindTo(e), this.hasDebugged = vd.bindTo(e), this.inDebugMode = Oe.bindTo(e), this.debugUx = wd.bindTo(e), this.debugUx.set(this.debugStorage.loadDebugUxState()), this.breakpointsExist = Tt.bindTo(e), this.disassemblyViewFocus = _t.bindTo(e);
      });
      const t = () => this.breakpointsExist.set(!!(this.model.getBreakpoints().length || this.model.getDataBreakpoints().length || this.model.getFunctionBreakpoints().length));
      t(), this.disposables.add(this.model.onDidChangeBreakpoints(() => t()));
    });
  }
  getModel() {
    return this.model;
  }
  getViewModel() {
    return this.viewModel;
  }
  getConfigurationManager() {
    return this.configurationManager;
  }
  getAdapterManager() {
    return this.adapterManager;
  }
  sourceIsNotAvailable(e) {
    this.model.sourceIsNotAvailable(e);
  }
  dispose() {
    this.disposables.dispose();
  }
  get state() {
    const e = this.viewModel.focusedSession;
    return e ? e.state : this.initializing ? 1 : 0;
  }
  get initializingOptions() {
    return this._initializingOptions;
  }
  startInitializingState(e) {
    this.initializing || (this.initializing = !0, this._initializingOptions = e, this.onStateChange());
  }
  endInitializingState() {
    this.initializing && (this.initializing = !1, this._initializingOptions = void 0, this.onStateChange());
  }
  cancelTokens(e) {
    if (e) {
      const t = this.sessionCancellationTokens.get(e);
      t && (t.cancel(), this.sessionCancellationTokens.delete(e));
    } else
      this.sessionCancellationTokens.forEach((t) => t.cancel()), this.sessionCancellationTokens.clear();
  }
  onStateChange() {
    const e = this.state;
    this.previousState !== e && (this.contextKeyService.bufferChangeEvents(() => {
      this.debugState.set(kd(e)), this.inDebugMode.set(e !== 0);
      const t = e !== 0 && e !== 1 || this.adapterManager.hasEnabledDebuggers() && this.configurationManager.selectedConfiguration.name ? "default" : "simple";
      this.debugUx.set(t), this.debugStorage.storeDebugUxState(t);
    }), this.previousState = e, this._onDidChangeState.fire(e));
  }
  get onDidChangeState() {
    return this._onDidChangeState.event;
  }
  get onDidNewSession() {
    return this._onDidNewSession.event;
  }
  get onWillNewSession() {
    return this._onWillNewSession.event;
  }
  get onDidEndSession() {
    return this._onDidEndSession.event;
  }
  lazySetup() {
    this.haveDoneLazySetup || (this.disposables.add(this.fileService.registerProvider(Gt, new pl(this))), this.haveDoneLazySetup = !0);
  }
  async startDebugging(e, t, i, n = !(i != null && i.parentSession)) {
    const s = i && i.noDebug ? c(
      "runTrust",
      "Running executes build tasks and program code from your workspace."
    ) : c(
      "debugTrust",
      "Debugging executes build tasks and program code from your workspace."
    );
    if (!await this.workspaceTrustRequestService.requestWorkspaceTrust({ message: s }))
      return !1;
    this.lazySetup(), this.startInitializingState(i), this.hasDebugged.set(!0);
    try {
      await this.extensionService.activateByEvent("onDebug"), n && await Fs(this.configurationService, this.editorService), await this.extensionService.whenInstalledExtensionsRegistered();
      let r, a;
      if (t || (t = this.configurationManager.selectedConfiguration.name), typeof t == "string" && e ? (r = e.getConfiguration(t), a = e.getCompound(t)) : typeof t != "string" && (r = t), a) {
        if (!a.configurations)
          throw new Error(c({ key: "compoundMustHaveConfigurations", comment: ['compound indicates a "compounds" configuration item', '"configurations" is an attribute and should not be localized'] }, 'Compound must have "configurations" attribute set in order to start multiple configurations.'));
        if (a.preLaunchTask && await this.taskRunner.runTaskAndCheckErrors((e == null ? void 0 : e.workspace) || this.contextService.getWorkspace(), a.preLaunchTask) === 0)
          return this.endInitializingState(), !1;
        a.stopAll && (i = { ...i, compoundRoot: new wl() });
        const h = (await Promise.all(a.configurations.map((p) => {
          const f = typeof p == "string" ? p : p.name;
          if (f === a.name)
            return Promise.resolve(!1);
          let b;
          if (typeof p == "string") {
            const m = this.configurationManager.getLaunches().filter((S) => !!S.getConfiguration(f));
            if (m.length === 1)
              b = m[0];
            else if (e && m.length > 1 && m.indexOf(e) >= 0)
              b = e;
            else
              throw new Error(m.length === 0 ? c("noConfigurationNameInWorkspace", "Could not find launch configuration '{0}' in the workspace.", f) : c("multipleConfigurationNamesInWorkspace", "There are multiple launch configurations '{0}' in the workspace. Use folder name to qualify the configuration.", f));
          } else if (p.folder) {
            const m = this.configurationManager.getLaunches().filter((S) => S.workspace && S.workspace.name === p.folder && !!S.getConfiguration(p.name));
            if (m.length === 1)
              b = m[0];
            else
              throw new Error(c("noFolderWithName", "Can not find folder with name '{0}' for configuration '{1}' in compound '{2}'.", p.folder, p.name, a.name));
          }
          return this.createSession(b, b.getConfiguration(f), i);
        }))).every((p) => !!p);
        return this.endInitializingState(), h;
      }
      if (t && !r) {
        const l = e ? c(
          "configMissing",
          "Configuration '{0}' is missing in 'launch.json'.",
          typeof t == "string" ? t : t.name
        ) : c(
          "launchJsonDoesNotExist",
          "'launch.json' does not exist for passed workspace folder."
        );
        throw new Error(l);
      }
      const u = await this.createSession(e, r, i);
      return this.endInitializingState(), u;
    } catch (r) {
      return this.notificationService.error(r), this.endInitializingState(), Promise.reject(r);
    }
  }
  async createSession(e, t, i) {
    let n;
    t ? n = t.type : t = /* @__PURE__ */ Object.create(null), (i && i.noDebug || i && typeof i.noDebug > "u" && i.parentSession && i.parentSession.configuration.noDebug) && (t.noDebug = !0);
    const s = nt(t);
    let o, r;
    n || (r = this.editorService.activeEditor, r && r.resource && (n = this.chosenEnvironments[r.resource.toString()]), n || (o = await this.adapterManager.guessDebugger(!1), o && (n = o.type)));
    const a = new Me(), u = le();
    this.sessionCancellationTokens.set(u, a);
    const l = await this.configurationManager.resolveConfigurationByProviders(e && e.workspace ? e.workspace.uri : void 0, n, t, a.token);
    if (l && l.type)
      try {
        let h = await this.substituteVariables(e, l);
        if (!h || a.token.isCancellationRequested)
          return !1;
        const p = (e == null ? void 0 : e.workspace) || this.contextService.getWorkspace();
        if (await this.taskRunner.runTaskAndCheckErrors(p, h.preLaunchTask) === 0)
          return !1;
        const b = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(e && e.workspace ? e.workspace.uri : void 0, n, h, a.token);
        if (!b)
          return e && n && b === null && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0, type: n }, a.token), !1;
        h = b;
        const m = this.adapterManager.getDebugger(h.type);
        if (!m || l.request !== "attach" && l.request !== "launch") {
          let N;
          l.request !== "attach" && l.request !== "launch" ? N = l.request ? c(
            "debugRequestNotSupported",
            "Attribute '{0}' has an unsupported value '{1}' in the chosen debug configuration.",
            "request",
            l.request
          ) : c(
            "debugRequesMissing",
            "Attribute '{0}' is missing from the chosen debug configuration.",
            "request"
          ) : N = h.type ? c(
            "debugTypeNotSupported",
            "Configured debug type '{0}' is not supported.",
            h.type
          ) : c(
            "debugTypeMissing",
            "Missing property 'type' for the chosen launch configuration."
          );
          const P = [];
          return P.push(new J("installAdditionalDebuggers", c(
            { key: "installAdditionalDebuggers", comment: ['Placeholder is the debug type, so for example "node", "python"'] },
            "Install {0} Extension",
            h.type
          ), void 0, !0, async () => this.commandService.executeCommand("debug.installAdditionalDebuggers", h == null ? void 0 : h.type))), await this.showError(N, P), !1;
        }
        if (!m.enabled)
          return await this.showError(To(m.type), []), !1;
        const S = await this.doCreateSession(u, e == null ? void 0 : e.workspace, { resolved: h, unresolved: s }, i);
        return S && o && r && r.resource && (this.chosenEnvironments[r.resource.toString()] = o.type, this.debugStorage.storeChosenEnvironments(this.chosenEnvironments)), S;
      } catch (h) {
        return h && h.message ? await this.showError(h.message) : this.contextService.getWorkbenchState() === 1 && await this.showError(c(
          "noFolderWorkspaceDebugError",
          "The active file can not be debugged. Make sure it is saved and that you have a debug extension installed for that file type."
        )), e && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0 }, a.token), !1;
      }
    return e && n && l === null && !a.token.isCancellationRequested && await e.openConfigFile({ preserveFocus: !0, type: n }, a.token), !1;
  }
  async doCreateSession(e, t, i, n) {
    const s = this.instantiationService.createInstance(rn, e, i, t, this.model, n);
    if (n != null && n.startedByUser && this.model.getSessions().some((r) => r.getLabel() === s.getLabel()) && i.resolved.suppressMultipleSessionWarning !== !0 && !(await this.dialogService.confirm({ message: c(
      "multipleSession",
      "'{0}' is already running. Do you want to start another instance?",
      s.getLabel()
    ) })).confirmed)
      return !1;
    this.model.addSession(s), this.registerSessionListeners(s), this._onWillNewSession.fire(s);
    const o = this.configurationService.getValue("debug").openDebug;
    !i.resolved.noDebug && (o === "openOnSessionStart" || o !== "neverOpen" && this.viewModel.firstSessionStart) && !s.suppressDebugView && await this.paneCompositeService.openPaneComposite(di, 0);
    try {
      await this.launchOrAttachToSession(s);
      const r = s.configuration.internalConsoleOptions || this.configurationService.getValue("debug").internalConsoleOptions;
      (r === "openOnSessionStart" || this.viewModel.firstSessionStart && r === "openOnFirstSessionStart") && this.viewsService.openView(Fe, !1), this.viewModel.firstSessionStart = !1;
      const a = this.configurationService.getValue("debug").showSubSessionsInToolBar, u = this.model.getSessions();
      return (a ? u : u.filter((h) => !h.parentSession)).length > 1 && this.viewModel.setMultiSessionView(!0), this._onDidNewSession.fire(s), !0;
    } catch (r) {
      if (er(r) || (s && s.getReplElements().length > 0 && this.viewsService.openView(Fe, !1), s.configuration && s.configuration.request === "attach" && s.configuration.__autoAttach))
        return !1;
      const a = r instanceof Error ? r.message : r;
      return r.showUser !== !1 && await this.showError(a, Cd(r) ? r.actions : []), !1;
    }
  }
  async launchOrAttachToSession(e, t = !1) {
    const i = this.adapterManager.getDebugger(e.configuration.type);
    try {
      await e.initialize(i), await e.launchOrAttach(e.configuration);
      const n = !!e.root && !!this.configurationService.getValue("launch", { resource: e.root.uri });
      await this.telemetry.logDebugSessionStart(i, n), (t || !this.viewModel.focusedSession || e.parentSession === this.viewModel.focusedSession && e.compact) && await this.focusStackFrame(void 0, void 0, e);
    } catch (n) {
      return this.viewModel.focusedSession === e && await this.focusStackFrame(void 0), Promise.reject(n);
    }
  }
  registerSessionListeners(e) {
    const t = new fe(() => {
      e.state === 3 && this.viewModel.focusedSession === e && this.viewModel.setFocus(void 0, this.viewModel.focusedThread, e, !1);
    }, 200);
    this.disposables.add(e.onDidChangeState(() => {
      e.state === 3 && this.viewModel.focusedSession === e && t.schedule(), e === this.viewModel.focusedSession && this.onStateChange();
    })), this.disposables.add(e.onDidEndAdapter(async (i) => {
      i && (i.error && this.notificationService.error(c(
        "debugAdapterCrash",
        "Debug adapter process has terminated unexpectedly ({0})",
        i.error.message || i.error.toString()
      )), this.telemetry.logDebugSessionStop(e, i));
      const n = Vs(e);
      if (n && n.state === 3 && n.configuration.noDebug && this.extensionHostDebugService.close(n.getId()), e.configuration.postDebugTask) {
        const o = e.root ?? this.contextService.getWorkspace();
        try {
          await this.taskRunner.runTask(o, e.configuration.postDebugTask);
        } catch (r) {
          this.notificationService.error(r);
        }
      }
      this.endInitializingState(), this.cancelTokens(e.getId()), this._onDidEndSession.fire(e);
      const s = this.viewModel.focusedSession;
      if (s && s.getId() === e.getId()) {
        const { session: o, thread: r, stackFrame: a } = mo(this.model, void 0, void 0, void 0, s);
        this.viewModel.setFocus(a, r, o, !1);
      }
      if (this.model.getSessions().length === 0 && (this.viewModel.setMultiSessionView(!1), this.layoutService.isVisible("workbench.parts.sidebar") && this.configurationService.getValue("debug").openExplorerOnEnd && this.paneCompositeService.openPaneComposite(yd, 0), this.model.getDataBreakpoints().filter((r) => !r.canPersist).forEach((r) => this.model.removeDataBreakpoints(r.getId())), this.configurationService.getValue("debug").console.closeOnEnd)) {
        const r = this.viewDescriptorService.getViewContainerByViewId(Fe);
        r && this.viewsService.isViewContainerVisible(r.id) && this.viewsService.closeViewContainer(r.id);
      }
      this.model.removeExceptionBreakpointsForSession(e.getId());
    }));
  }
  async restartSession(e, t) {
    e.saveBeforeRestart && await Fs(this.configurationService, this.editorService);
    const i = !!t, n = async () => {
      if (i)
        return Promise.resolve(1);
      const h = e.root || this.contextService.getWorkspace();
      await this.taskRunner.runTask(h, e.configuration.preRestartTask), await this.taskRunner.runTask(h, e.configuration.postDebugTask);
      const p = await this.taskRunner.runTaskAndCheckErrors(h, e.configuration.preLaunchTask);
      return p !== 1 ? p : this.taskRunner.runTaskAndCheckErrors(h, e.configuration.postRestartTask);
    }, s = Vs(e);
    if (s) {
      await n() === 1 && this.extensionHostDebugService.reload(s.getId());
      return;
    }
    let o = !1, r;
    const a = e.root ? this.configurationManager.getLaunch(e.root.uri) : void 0;
    a && (r = a.getConfiguration(e.configuration.name), r && !Dd(r, e.unresolvedConfiguration) && (r.type = e.configuration.type, r.noDebug = e.configuration.noDebug, o = !0));
    let u = e.configuration;
    if (a && o && r) {
      const h = new Me();
      this.sessionCancellationTokens.set(e.getId(), h);
      const p = await this.configurationManager.resolveConfigurationByProviders(a.workspace ? a.workspace.uri : void 0, r.type, r, h.token);
      p ? (u = await this.substituteVariables(a, p), u && !h.token.isCancellationRequested && (u = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(a && a.workspace ? a.workspace.uri : void 0, r.type, u, h.token))) : u = p;
    }
    if (u && e.setConfiguration({ resolved: u, unresolved: r }), e.configuration.__restart = t, e.capabilities.supportsRestartRequest) {
      await n() === 1 && await e.restart();
      return;
    }
    const l = !!this.viewModel.focusedSession && e.getId() === this.viewModel.focusedSession.getId();
    return i ? await e.disconnect(!0) : await e.terminate(!0), new Promise((h, p) => {
      setTimeout(async () => {
        if (await n() === 1) {
          if (!u)
            return h(void 0);
          try {
            await this.launchOrAttachToSession(e, l), this._onDidNewSession.fire(e), h(void 0);
          } catch (b) {
            p(b);
          }
        }
      }, 300);
    });
  }
  async stopSession(e, t = !1, i = !1) {
    if (e)
      return t ? e.disconnect(void 0, i) : e.terminate();
    const n = this.model.getSessions();
    return n.length === 0 && (this.taskRunner.cancel(), await this.quickInputService.cancel(), this.endInitializingState(), this.cancelTokens(void 0)), Promise.all(n.map((s) => t ? s.disconnect(void 0, i) : s.terminate()));
  }
  async substituteVariables(e, t) {
    const i = this.adapterManager.getDebugger(t.type);
    if (i) {
      let n;
      if (e && e.workspace)
        n = e.workspace;
      else {
        const s = this.contextService.getWorkspace().folders;
        s.length === 1 && (n = s[0]);
      }
      try {
        return await i.substituteVariables(n, t);
      } catch (s) {
        this.showError(s.message, void 0, !!(e != null && e.getConfiguration(t.name)));
        return;
      }
    }
    return Promise.resolve(t);
  }
  async showError(e, t = [], i = !0) {
    const n = new J(
      Xt,
      Or,
      void 0,
      !0,
      () => this.commandService.executeCommand(Xt)
    ), s = t.filter((o) => o.id.endsWith(".command")).length > 0 ? t : [...t, ...i ? [n] : []];
    await this.dialogService.prompt({
      type: ye.Error,
      message: e,
      buttons: s.map((o) => ({
        label: o.label,
        run: () => o.run()
      })),
      cancelButton: !0
    });
  }
  async focusStackFrame(e, t, i, n) {
    const { stackFrame: s, thread: o, session: r } = mo(this.model, e, t, i);
    if (s) {
      const a = await s.openInEditor(this.editorService, (n == null ? void 0 : n.preserveFocus) ?? !0, n == null ? void 0 : n.sideBySide, n == null ? void 0 : n.pinned);
      if (a && a.input !== ce.instance) {
        const u = a.getControl();
        if (s && Ae(u) && u.hasModel()) {
          const l = u.getModel(), h = s.range.startLineNumber;
          if (h >= 1 && h <= l.getLineCount()) {
            const p = u.getModel().getLineContent(h);
            Ed(c(
              { key: "debuggingPaused", comment: ['First placeholder is the file line content, second placeholder is the reason why debugging is stopped, for example "breakpoint", third is the stack frame name, and last is the line number.'] },
              "{0}, debugging paused {1}, {2}:{3}",
              p,
              o && o.stoppedDetails ? `, reason ${o.stoppedDetails.reason}` : "",
              s.source ? s.source.name : "",
              s.range.startLineNumber
            ));
          }
        }
      }
    }
    r ? this.debugType.set(r.configuration.type) : this.debugType.reset(), this.viewModel.setFocus(s, o, r, !!(n != null && n.explicit));
  }
  addWatchExpression(e) {
    const t = this.model.addWatchExpression(e);
    e || this.viewModel.setSelectedExpression(t, !1), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  renameWatchExpression(e, t) {
    this.model.renameWatchExpression(e, t), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  moveWatchExpression(e, t) {
    this.model.moveWatchExpression(e, t), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  removeWatchExpressions(e) {
    this.model.removeWatchExpressions(e), this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
  }
  canSetBreakpointsIn(e) {
    return this.adapterManager.canSetBreakpointsIn(e);
  }
  async enableOrDisableBreakpoints(e, t) {
    t ? (this.model.setEnablement(t, e), this.debugStorage.storeBreakpoints(this.model), t instanceof Be ? await this.sendBreakpoints(t.originalUri) : t instanceof De ? await this.sendFunctionBreakpoints() : t instanceof Te ? await this.sendDataBreakpoints() : t instanceof it ? await this.sendInstructionBreakpoints() : await this.sendExceptionBreakpoints()) : (this.model.enableOrDisableAllBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendAllBreakpoints()), this.debugStorage.storeBreakpoints(this.model);
  }
  async addBreakpoints(e, t, i = !0) {
    const n = this.model.addBreakpoints(e, t);
    return i && n.forEach((s) => jt(c(
      "breakpointAdded",
      "Added breakpoint, line {0}, file {1}",
      s.lineNumber,
      e.fsPath
    ))), this.debugStorage.storeBreakpoints(this.model), await this.sendBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), n;
  }
  async updateBreakpoints(e, t, i) {
    this.model.updateBreakpoints(t), this.debugStorage.storeBreakpoints(this.model), i ? this.breakpointsToSendOnResourceSaved.add(e) : (await this.sendBreakpoints(e), this.debugStorage.storeBreakpoints(this.model));
  }
  async removeBreakpoints(e) {
    const t = this.model.getBreakpoints().filter((n) => !e || n.getId() === e);
    t.forEach((n) => jt(c(
      "breakpointRemoved",
      "Removed breakpoint, line {0}, file {1}",
      n.lineNumber,
      n.uri.fsPath
    )));
    const i = Le(t, (n) => n.originalUri.toString()).map((n) => n.originalUri);
    this.model.removeBreakpoints(t), this.debugStorage.storeBreakpoints(this.model), await Promise.all(i.map((n) => this.sendBreakpoints(n)));
  }
  setBreakpointsActivated(e) {
    return this.model.setBreakpointsActivated(e), this.sendAllBreakpoints();
  }
  addFunctionBreakpoint(e, t) {
    this.model.addFunctionBreakpoint(e || "", t);
  }
  async updateFunctionBreakpoint(e, t) {
    this.model.updateFunctionBreakpoint(e, t), this.debugStorage.storeBreakpoints(this.model), await this.sendFunctionBreakpoints();
  }
  async removeFunctionBreakpoints(e) {
    this.model.removeFunctionBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendFunctionBreakpoints();
  }
  async addDataBreakpoint(e, t, i, n, s) {
    this.model.addDataBreakpoint(e, t, i, n, s), this.debugStorage.storeBreakpoints(this.model), await this.sendDataBreakpoints(), this.debugStorage.storeBreakpoints(this.model);
  }
  async removeDataBreakpoints(e) {
    this.model.removeDataBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendDataBreakpoints();
  }
  async addInstructionBreakpoint(e, t, i, n) {
    this.model.addInstructionBreakpoint(e, t, i, n), this.debugStorage.storeBreakpoints(this.model), await this.sendInstructionBreakpoints(), this.debugStorage.storeBreakpoints(this.model);
  }
  async removeInstructionBreakpoints(e) {
    this.model.removeInstructionBreakpoints(e), this.debugStorage.storeBreakpoints(this.model), await this.sendInstructionBreakpoints();
  }
  setExceptionBreakpointFallbackSession(e) {
    this.model.setExceptionBreakpointFallbackSession(e), this.debugStorage.storeBreakpoints(this.model);
  }
  setExceptionBreakpointsForSession(e, t) {
    this.model.setExceptionBreakpointsForSession(e.getId(), t), this.debugStorage.storeBreakpoints(this.model);
  }
  async setExceptionBreakpointCondition(e, t) {
    this.model.setExceptionBreakpointCondition(e, t), this.debugStorage.storeBreakpoints(this.model), await this.sendExceptionBreakpoints();
  }
  async sendAllBreakpoints(e) {
    const t = Le(this.model.getBreakpoints(), (i) => i.originalUri.toString()).map((i) => this.sendBreakpoints(i.originalUri, !1, e));
    e != null && e.capabilities.supportsConfigurationDoneRequest ? await Promise.all([
      ...t,
      this.sendFunctionBreakpoints(e),
      this.sendDataBreakpoints(e),
      this.sendInstructionBreakpoints(e),
      this.sendExceptionBreakpoints(e)
    ]) : (await Promise.all(t), await this.sendFunctionBreakpoints(e), await this.sendDataBreakpoints(e), await this.sendInstructionBreakpoints(e), await this.sendExceptionBreakpoints(e));
  }
  async sendBreakpoints(e, t = !1, i) {
    const n = this.model.getBreakpoints({ originalUri: e, enabledOnly: !0 });
    await ft(this.model, i, async (s) => {
      s.configuration.noDebug || await s.sendBreakpoints(e, n, t);
    });
  }
  async sendFunctionBreakpoints(e) {
    const t = this.model.getFunctionBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await ft(this.model, e, async (i) => {
      i.capabilities.supportsFunctionBreakpoints && !i.configuration.noDebug && await i.sendFunctionBreakpoints(t);
    });
  }
  async sendDataBreakpoints(e) {
    const t = this.model.getDataBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await ft(this.model, e, async (i) => {
      i.capabilities.supportsDataBreakpoints && !i.configuration.noDebug && await i.sendDataBreakpoints(t);
    });
  }
  async sendInstructionBreakpoints(e) {
    const t = this.model.getInstructionBreakpoints().filter((i) => i.enabled && this.model.areBreakpointsActivated());
    await ft(this.model, e, async (i) => {
      i.capabilities.supportsInstructionBreakpoints && !i.configuration.noDebug && await i.sendInstructionBreakpoints(t);
    });
  }
  sendExceptionBreakpoints(e) {
    return ft(this.model, e, async (t) => {
      const i = this.model.getExceptionBreakpointsForSession(t.getId()).filter((n) => n.enabled);
      t.capabilities.supportsConfigurationDoneRequest && (!t.capabilities.exceptionBreakpointFilters || t.capabilities.exceptionBreakpointFilters.length === 0) || t.configuration.noDebug || await t.sendExceptionBreakpoints(i);
    });
  }
  onFileChanges(e) {
    const t = this.model.getBreakpoints().filter((n) => e.contains(n.originalUri, 2));
    t.length && this.model.removeBreakpoints(t);
    const i = [];
    for (const n of this.breakpointsToSendOnResourceSaved)
      e.contains(n, 0) && i.push(n);
    for (const n of i)
      this.breakpointsToSendOnResourceSaved.delete(n), this.sendBreakpoints(n, !0);
  }
  async runTo(e, t, i) {
    let n, s = this.getViewModel().focusedThread;
    const o = async () => {
      if (!!!this.getModel().getBreakpoints({ column: i, lineNumber: t, uri: e }).length) {
        const u = await this.addAndValidateBreakpoints(e, t, i);
        u.thread && (s = u.thread), u.breakpoint && (n = u.breakpoint);
      }
      return { threadToContinue: s, breakpointToRemove: n };
    }, r = (a) => a === 2 || a === 0 ? (n && this.removeBreakpoints(n.getId()), !0) : !1;
    if (await o(), this.state === 0) {
      const { launch: a, name: u, getConfig: l } = this.getConfigurationManager().selectedConfiguration, h = await l(), p = h ? Object.assign(nt(h), {}) : u, f = this.onDidChangeState((b) => {
        r(b) && f.dispose();
      });
      await this.startDebugging(a, p, void 0, !0);
    }
    if (this.state === 2) {
      const a = this.getViewModel().focusedSession;
      if (!a || !s)
        return;
      const u = s.session.onDidChangeState(() => {
        r(a.state) && u.dispose();
      });
      await s.continue();
    }
  }
  async addAndValidateBreakpoints(e, t, i) {
    const n = this.getModel(), s = this.getViewModel(), o = await this.addBreakpoints(e, [{ lineNumber: t, column: i }], !1), r = o == null ? void 0 : o[0];
    if (!r)
      return { breakpoint: void 0, thread: s.focusedThread };
    if (!r.verified) {
      let l;
      await Id(new Promise((h) => {
        l = n.onDidChangeBreakpoints(() => {
          r.verified && h();
        });
      }), 2e3), l.dispose();
    }
    let a = s.focusedThread, u = 0;
    for (const l of r.sessionsThatVerified) {
      const h = n.getSession(l);
      if (!h)
        continue;
      const p = h.getAllThreads().filter((f) => f.stopped);
      if (u < 3 && s.focusedThread && p.includes(s.focusedThread) && (a = s.focusedThread, u = 3), u < 2) {
        const f = p.find((b) => {
          const m = b.getTopStackFrame();
          return m && this.uriIdentityService.extUri.isEqual(m.source.uri, e);
        });
        f && (a = f, u = 2);
      }
      u < 1 && (a = p[0], u = 2);
    }
    return { thread: a, breakpoint: r };
  }
};
vt = E([
  g(0, se),
  g(1, Xo),
  g(2, st),
  g(3, Qo),
  g(4, Re),
  g(5, Et),
  g(6, Zo),
  g(7, Qe),
  g(8, W),
  g(9, Vn),
  g(10, re),
  g(11, Dt),
  g(12, Kn),
  g(13, G),
  g(14, qo),
  g(15, pd),
  g(16, _e),
  g(17, Ie),
  g(18, fd),
  g(19, Je)
], vt);
function mo(d, e, t, i, n) {
  if (!i)
    if (e || t)
      i = e ? e.thread.session : t.session;
    else {
      const s = d.getSessions();
      i = s.find((r) => r.state === 2) || s.find((r) => r !== n && r !== (n == null ? void 0 : n.parentSession)) || (s.length ? s[0] : void 0);
    }
  if (!t)
    if (e)
      t = e.thread;
    else {
      const s = i ? i.getAllThreads() : void 0;
      t = s && s.find((r) => r.stopped) || (s && s.length ? s[0] : void 0);
    }
  return !e && t && (e = t.getTopStackFrame()), { session: i, thread: t, stackFrame: e };
}
async function ft(d, e, t) {
  e ? await t(e) : await Promise.all(d.getSessions().map((i) => t(i)));
}
class Cl {
  constructor() {
    this.referenceProvider = new M(this._score.bind(this)), this.renameProvider = new M(this._score.bind(this)), this.codeActionProvider = new M(this._score.bind(this)), this.definitionProvider = new M(this._score.bind(this)), this.typeDefinitionProvider = new M(this._score.bind(this)), this.declarationProvider = new M(this._score.bind(this)), this.implementationProvider = new M(this._score.bind(this)), this.documentSymbolProvider = new M(this._score.bind(this)), this.inlayHintsProvider = new M(this._score.bind(this)), this.colorProvider = new M(this._score.bind(this)), this.codeLensProvider = new M(this._score.bind(this)), this.documentFormattingEditProvider = new M(this._score.bind(this)), this.documentRangeFormattingEditProvider = new M(this._score.bind(this)), this.onTypeFormattingEditProvider = new M(this._score.bind(this)), this.signatureHelpProvider = new M(this._score.bind(this)), this.hoverProvider = new M(this._score.bind(this)), this.documentHighlightProvider = new M(this._score.bind(this)), this.selectionRangeProvider = new M(this._score.bind(this)), this.foldingRangeProvider = new M(this._score.bind(this)), this.linkProvider = new M(this._score.bind(this)), this.inlineCompletionsProvider = new M(this._score.bind(this)), this.completionProvider = new M(this._score.bind(this)), this.linkedEditingRangeProvider = new M(this._score.bind(this)), this.inlineValuesProvider = new M(this._score.bind(this)), this.evaluatableExpressionProvider = new M(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new M(this._score.bind(this)), this.documentSemanticTokensProvider = new M(this._score.bind(this)), this.documentOnDropEditProvider = new M(this._score.bind(this)), this.documentPasteEditProvider = new M(this._score.bind(this));
  }
  setNotebookTypeResolver(e) {
    this._notebookTypeResolver = e;
  }
  _score(e) {
    var t;
    return (t = this._notebookTypeResolver) == null ? void 0 : t.call(this, e);
  }
}
class hi extends _d {
  constructor(e, t, i, n, s, o, r, a, u, l) {
    super({
      getFolderUri: (h) => {
        const p = o.getWorkspace().folders.filter((f) => f.name === h).pop();
        return p ? p.uri : void 0;
      },
      getWorkspaceFolderCount: () => o.getWorkspace().folders.length,
      getConfigurationValue: (h, p) => n.getValue(p, h ? { resource: h } : {}),
      getAppRoot: () => e.getAppRoot(),
      getExecPath: () => e.getExecPath(),
      getFilePath: () => {
        const h = Ws.getOriginalUri(i.activeEditor, {
          supportSideBySide: Us.PRIMARY,
          filterByScheme: [Pe.file, Pe.vscodeUserData, this.pathService.defaultUriScheme]
        });
        if (h)
          return this.labelService.getUriLabel(h, { noPrefix: !0 });
      },
      getWorkspaceFolderPathForFile: () => {
        const h = Ws.getOriginalUri(i.activeEditor, {
          supportSideBySide: Us.PRIMARY,
          filterByScheme: [Pe.file, Pe.vscodeUserData, this.pathService.defaultUriScheme]
        });
        if (!h)
          return;
        const p = o.getWorkspaceFolder(h);
        if (p)
          return this.labelService.getUriLabel(p.uri, { noPrefix: !0 });
      },
      getSelectedText: () => {
        const h = i.activeTextEditorControl;
        let p = null;
        if (Ae(h))
          p = h;
        else if (xd(h)) {
          const m = h.getOriginalEditor(), S = h.getModifiedEditor();
          p = m.hasWidgetFocus() ? m : S;
        }
        const f = p == null ? void 0 : p.getModel(), b = p == null ? void 0 : p.getSelection();
        if (f && b)
          return f.getValueInRange(b);
      },
      getLineNumber: () => {
        const h = i.activeTextEditorControl;
        if (Ae(h)) {
          const p = h.getSelection();
          if (p) {
            const f = p.positionLineNumber;
            return String(f);
          }
        }
      },
      getExtension: (h) => l.getExtension(h)
    }, a, u.userHome().then((h) => h.path), t), this.configurationService = n, this.commandService = s, this.workspaceContextService = o, this.quickInputService = r, this.labelService = a, this.pathService = u, this.userInputAccessQueue = new Jo();
  }
  async resolveWithInteractionReplace(e, t, i, n, s) {
    return t = await this.resolveAnyAsync(e, t), this.resolveWithInteraction(e, t, i, n, s).then((o) => o ? o.size > 0 ? this.resolveAnyAsync(e, t, Object.fromEntries(o)) : t : null);
  }
  async resolveWithInteraction(e, t, i, n, s) {
    const o = await this.resolveAnyMap(e, t);
    t = o.newConfig;
    const r = o.resolvedVariables;
    return this.resolveWithInputAndCommands(e, t, n, i, s).then((a) => {
      if (this.updateMapping(a, r))
        return r;
    });
  }
  updateMapping(e, t) {
    if (!e)
      return !1;
    for (const [i, n] of Object.entries(e))
      t.set(i, n);
    return !0;
  }
  async resolveWithInputAndCommands(e, t, i, n, s) {
    var u, l, h;
    if (!t)
      return Promise.resolve(void 0);
    let o = [];
    if (this.workspaceContextService.getWorkbenchState() !== 1 && n) {
      const p = e ? { resource: e.uri } : {}, f = this.configurationService.inspect(n, p);
      if (f && (f.userValue || f.workspaceValue || f.workspaceFolderValue))
        switch (s) {
          case 2:
            o = (u = f.userValue) == null ? void 0 : u.inputs;
            break;
          case 5:
            o = (l = f.workspaceValue) == null ? void 0 : l.inputs;
            break;
          default:
            o = (h = f.workspaceFolderValue) == null ? void 0 : h.inputs;
        }
      else {
        const b = this.configurationService.getValue(n, p);
        b && (o = b.inputs);
      }
    }
    const r = [];
    this.findVariables(t, r);
    const a = /* @__PURE__ */ Object.create(null);
    for (const p of r) {
      const [f, b] = p.split(":", 2);
      let m;
      switch (f) {
        case "input":
          m = await this.showUserInput(b, o);
          break;
        case "command": {
          const S = (i ? i[b] : void 0) || b;
          if (m = await this.commandService.executeCommand(S, t), typeof m != "string" && !$e(m))
            throw new Error(c("commandVariable.noStringType", "Cannot substitute command variable '{0}' because command did not return a result of type string.", S));
          break;
        }
        default:
          this._contributedVariables.has(p) && (m = await this._contributedVariables.get(p)());
      }
      if (typeof m == "string")
        a[p] = m;
      else
        return;
    }
    return a;
  }
  findVariables(e, t) {
    if (typeof e == "string") {
      let i;
      for (; (i = hi.INPUT_OR_COMMAND_VARIABLES_PATTERN.exec(e)) !== null; )
        if (i.length === 4) {
          const n = i[1];
          t.indexOf(n) < 0 && t.push(n);
        }
      for (const n of this._contributedVariables.keys())
        t.indexOf(n) < 0 && e.indexOf("${" + n + "}") >= 0 && t.push(n);
    } else if (Array.isArray(e))
      for (const i of e)
        this.findVariables(i, t);
    else if (e)
      for (const i of Object.values(e))
        this.findVariables(i, t);
  }
  showUserInput(e, t) {
    if (!t)
      return Promise.reject(new Error(c(
        "inputVariable.noInputSection",
        "Variable '{0}' must be defined in an '{1}' section of the debug or task configuration.",
        e,
        "input"
      )));
    const i = t.filter((n) => n.id === e).pop();
    if (i) {
      const n = (s) => {
        throw new Error(c("inputVariable.missingAttribute", "Input variable '{0}' is of type '{1}' and must include '{2}'.", e, i.type, s));
      };
      switch (i.type) {
        case "promptString": {
          pe(i.description) || n("description");
          const s = { prompt: i.description, ignoreFocusLost: !0 };
          return i.default && (s.value = i.default), i.password && (s.password = i.password), this.userInputAccessQueue.queue(() => this.quickInputService.input(s)).then((o) => o);
        }
        case "pickString": {
          if (pe(i.description) || n("description"), Array.isArray(i.options))
            for (const r of i.options)
              !pe(r) && !pe(r.value) && n("value");
          else
            n("options");
          const s = new Array();
          for (const r of i.options) {
            const a = pe(r) ? r : r.value, u = pe(r) ? void 0 : r.label, l = {
              label: u ? `${u}: ${a}` : a,
              value: a
            };
            a === i.default ? (l.description = c("inputVariable.defaultInputValue", "(Default)"), s.unshift(l)) : s.push(l);
          }
          const o = { placeHolder: i.description, matchOnDetail: !0, ignoreFocusLost: !0 };
          return this.userInputAccessQueue.queue(() => this.quickInputService.pick(s, o, void 0)).then((r) => {
            if (r)
              return r.value;
          });
        }
        case "command":
          return pe(i.command) || n("command"), this.userInputAccessQueue.queue(() => this.commandService.executeCommand(i.command, i.args)).then((s) => {
            if (typeof s == "string" || $e(s))
              return s;
            throw new Error(c("inputVariable.command.noStringType", "Cannot substitute input variable '{0}' because command '{1}' did not return a result of type string.", e, i.command));
          });
        default:
          throw new Error(c("inputVariable.unknownType", "Input variable '{0}' can only be of type 'promptString', 'pickString', or 'command'.", e));
      }
    }
    return Promise.reject(new Error(c(
      "inputVariable.undefinedVariable",
      "Undefined input variable '{0}' encountered. Remove or define '{0}' to continue.",
      e
    )));
  }
}
hi.INPUT_OR_COMMAND_VARIABLES_PATTERN = /\${((input|command):(.*?))}/g;
let un = class extends hi {
  constructor(e, t, i, n, s, o, r, a) {
    super({ getAppRoot: () => {
    }, getExecPath: () => {
    } }, Promise.resolve(/* @__PURE__ */ Object.create(null)), e, t, i, n, s, o, r, a);
  }
};
un = E([
  g(0, se),
  g(1, G),
  g(2, _e),
  g(3, Qe),
  g(4, Ie),
  g(5, Ye),
  g(6, tr),
  g(7, Dt)
], un);
class yl {
  constructor() {
    this._registeredGutterActionsGenerators = /* @__PURE__ */ new Set();
  }
  registerGutterActionsGenerator(e) {
    return this._registeredGutterActionsGenerators.add(e), {
      dispose: () => {
        this._registeredGutterActionsGenerators.delete(e);
      }
    };
  }
  getGutterActionsGenerators() {
    return Array.from(this._registeredGutterActionsGenerators.values());
  }
}
Ee.add("gutterActionsRegistry", new yl());
const Yr = Ee.as("gutterActionsRegistry");
let wt = class extends ae {
  constructor(e, t, i, n, s) {
    super(), this.editor = e, this.contextMenuService = t, this.menuService = i, this.contextKeyService = n, this.instantiationService = s, this._register(this.editor.onMouseDown((o) => this.doShow(o, !1)));
  }
  show(e) {
    this.doShow(e, !0);
  }
  doShow(e, t) {
    const i = this.editor.getModel();
    if (!e.event.rightButton && !(Ce && e.event.leftButton && e.event.ctrlKey) && !t || e.target.type !== 3 && e.target.type !== 2 || !e.target.position || !i)
      return;
    const n = { x: e.event.posx, y: e.event.posy }, s = e.target.position.lineNumber, o = this.contextKeyService.createOverlay([["editorLineNumber", s]]), r = this.menuService.createMenu(y.EditorLineNumberContext, o), a = [];
    this.instantiationService.invokeFunction((u) => {
      for (const h of Yr.getGutterActionsGenerators()) {
        const p = /* @__PURE__ */ new Map();
        h({ lineNumber: s, editor: this.editor, accessor: u }, {
          push: (f, b = "navigation") => {
            const m = p.get(b) ?? [];
            m.push(f), p.set(b, m);
          }
        });
        for (const [f, b] of p.entries())
          a.push([f, b]);
      }
      a.sort((h, p) => h[0].localeCompare(p[0]));
      const l = r.getActions({ arg: { lineNumber: s, uri: i.uri }, shouldForwardArgs: !0 });
      if (a.push(...l), e.target.type === 3) {
        const h = this.editor.getSelections(), p = {
          startLineNumber: s,
          endLineNumber: s,
          startColumn: 1,
          endColumn: i.getLineLength(s) + 1
        };
        (h == null ? void 0 : h.some((b) => !b.isEmpty() && b.intersectRanges(p) !== null)) || this.editor.setSelection(p, "api");
      }
      this.contextMenuService.showContextMenu({
        getAnchor: () => n,
        getActions: () => ir.join(...a.map((h) => h[1])),
        onHide: () => r.dispose()
      });
    });
  }
};
wt.ID = "workbench.contrib.editorLineNumberContextMenu";
wt = E([
  g(1, At),
  g(2, Lt),
  g(3, W),
  g(4, re)
], wt);
rt(wt.ID, wt, 1);
class kt extends ae {
  get ariaHeaderLabel() {
    return this._ariaHeaderLabel;
  }
  set ariaHeaderLabel(e) {
    this._ariaHeaderLabel = e, this.header.setAttribute("aria-label", this.ariaHeaderLabel);
  }
  get draggableElement() {
    return this.header;
  }
  get dropTargetElement() {
    return this.element;
  }
  get dropBackground() {
    return this.styles.dropBackground;
  }
  get minimumBodySize() {
    return this._minimumBodySize;
  }
  set minimumBodySize(e) {
    this._minimumBodySize = e, this._onDidChange.fire(void 0);
  }
  get maximumBodySize() {
    return this._maximumBodySize;
  }
  set maximumBodySize(e) {
    this._maximumBodySize = e, this._onDidChange.fire(void 0);
  }
  get headerSize() {
    return this.headerVisible ? kt.HEADER_SIZE : 0;
  }
  get minimumSize() {
    const e = this.headerSize, i = !this.headerVisible || this.isExpanded() ? this.minimumBodySize : 0;
    return e + i;
  }
  get maximumSize() {
    const e = this.headerSize, i = !this.headerVisible || this.isExpanded() ? this.maximumBodySize : 0;
    return e + i;
  }
  constructor(e) {
    super(), this.expandedSize = void 0, this._headerVisible = !0, this._bodyRendered = !1, this.styles = {
      dropBackground: void 0,
      headerBackground: void 0,
      headerBorder: void 0,
      headerForeground: void 0,
      leftBorder: void 0
    }, this.animationTimer = void 0, this._onDidChange = this._register(new v()), this.onDidChange = this._onDidChange.event, this._onDidChangeExpansionState = this._register(new v()), this.onDidChangeExpansionState = this._onDidChangeExpansionState.event, this.orthogonalSize = 0, this._expanded = typeof e.expanded > "u" ? !0 : !!e.expanded, this._orientation = typeof e.orientation > "u" ? 0 : e.orientation, this._ariaHeaderLabel = c("viewSection", "{0} Section", e.title), this._minimumBodySize = typeof e.minimumBodySize == "number" ? e.minimumBodySize : this._orientation === 1 ? 200 : 120, this._maximumBodySize = typeof e.maximumBodySize == "number" ? e.maximumBodySize : Number.POSITIVE_INFINITY, this.element = O(".pane");
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(e) {
    var t;
    return this._expanded === !!e ? !1 : ((t = this.element) == null || t.classList.toggle("expanded", e), this._expanded = !!e, this.updateHeader(), e ? (this._bodyRendered || (this.renderBody(this.body), this._bodyRendered = !0), typeof this.animationTimer == "number" && clearTimeout(this.animationTimer), k(this.element, this.body)) : this.animationTimer = window.setTimeout(() => {
      this.body.remove();
    }, 200), this._onDidChangeExpansionState.fire(e), this._onDidChange.fire(e ? this.expandedSize : void 0), !0);
  }
  get headerVisible() {
    return this._headerVisible;
  }
  set headerVisible(e) {
    this._headerVisible !== !!e && (this._headerVisible = !!e, this.updateHeader(), this._onDidChange.fire(void 0));
  }
  get orientation() {
    return this._orientation;
  }
  set orientation(e) {
    this._orientation !== e && (this._orientation = e, this.element && (this.element.classList.toggle("horizontal", this.orientation === 1), this.element.classList.toggle("vertical", this.orientation === 0)), this.header && this.updateHeader());
  }
  render() {
    this.element.classList.toggle("expanded", this.isExpanded()), this.element.classList.toggle("horizontal", this.orientation === 1), this.element.classList.toggle("vertical", this.orientation === 0), this.header = O(".pane-header"), k(this.element, this.header), this.header.setAttribute("tabindex", "0"), this.header.setAttribute("role", "button"), this.header.setAttribute("aria-label", this.ariaHeaderLabel), this.renderHeader(this.header);
    const e = sr(this.header);
    this._register(e), this._register(e.onDidFocus(() => this.header.classList.add("focused"), null)), this._register(e.onDidBlur(() => this.header.classList.remove("focused"), null)), this.updateHeader();
    const t = this._register(new oe()), i = this._register(new or(this.header, "keydown")), n = ne.map(i.event, (s) => new We(s), t);
    this._register(ne.filter(n, (s) => s.keyCode === 3 || s.keyCode === 10, t)(() => this.setExpanded(!this.isExpanded()), null)), this._register(ne.filter(n, (s) => s.keyCode === 15, t)(() => this.setExpanded(!1), null)), this._register(ne.filter(n, (s) => s.keyCode === 17, t)(() => this.setExpanded(!0), null)), this._register(rr.addTarget(this.header)), [Z.CLICK, Td.Tap].forEach((s) => {
      this._register(H(this.header, s, (o) => {
        o.defaultPrevented || this.setExpanded(!this.isExpanded());
      }));
    }), this.body = k(this.element, O(".pane-body")), !this._bodyRendered && this.isExpanded() && (this.renderBody(this.body), this._bodyRendered = !0), this.isExpanded() || this.body.remove();
  }
  layout(e) {
    const t = this.headerVisible ? kt.HEADER_SIZE : 0, i = this._orientation === 0 ? this.orthogonalSize : e, n = this._orientation === 0 ? e - t : this.orthogonalSize - t;
    this.isExpanded() && (this.body.classList.toggle("wide", i >= 600), this.layoutBody(n, i), this.expandedSize = e);
  }
  style(e) {
    this.styles = e, this.header && this.updateHeader();
  }
  updateHeader() {
    const e = !this.headerVisible || this.isExpanded();
    this.header.style.lineHeight = `${this.headerSize}px`, this.header.classList.toggle("hidden", !this.headerVisible), this.header.classList.toggle("expanded", e), this.header.setAttribute("aria-expanded", String(e)), this.header.style.color = this.styles.headerForeground ?? "", this.header.style.backgroundColor = this.styles.headerBackground ?? "", this.header.style.borderTop = this.styles.headerBorder && this.orientation === 0 ? `1px solid ${this.styles.headerBorder}` : "", this.element.style.borderLeft = this.styles.leftBorder && this.orientation === 1 ? `1px solid ${this.styles.leftBorder}` : "";
  }
}
kt.HEADER_SIZE = 22;
class ks extends ae {
  constructor(e, t, i) {
    super(), this.pane = e, this.dnd = t, this.context = i, this.dragOverCounter = 0, this._onDidDrop = this._register(new v()), this.onDidDrop = this._onDidDrop.event, e.draggableElement.draggable = !0, this._register(H(e.draggableElement, "dragstart", (n) => this.onDragStart(n))), this._register(H(e.dropTargetElement, "dragenter", (n) => this.onDragEnter(n))), this._register(H(e.dropTargetElement, "dragleave", (n) => this.onDragLeave(n))), this._register(H(e.dropTargetElement, "dragend", (n) => this.onDragEnd(n))), this._register(H(e.dropTargetElement, "drop", (n) => this.onDrop(n)));
  }
  onDragStart(e) {
    var i;
    if (!this.dnd.canDrag(this.pane) || !e.dataTransfer) {
      e.preventDefault(), e.stopPropagation();
      return;
    }
    e.dataTransfer.effectAllowed = "move", Ad && ((i = e.dataTransfer) == null || i.setData(Ld.TEXT, this.pane.draggableElement.textContent || ""));
    const t = k(document.body, O(".monaco-drag-image", {}, this.pane.draggableElement.textContent || ""));
    e.dataTransfer.setDragImage(t, -10, -10), setTimeout(() => document.body.removeChild(t), 0), this.context.draggable = this;
  }
  onDragEnter(e) {
    !this.context.draggable || this.context.draggable === this || this.dnd.canDrop(this.context.draggable.pane, this.pane) && (this.dragOverCounter++, this.render());
  }
  onDragLeave(e) {
    !this.context.draggable || this.context.draggable === this || this.dnd.canDrop(this.context.draggable.pane, this.pane) && (this.dragOverCounter--, this.dragOverCounter === 0 && this.render());
  }
  onDragEnd(e) {
    this.context.draggable && (this.dragOverCounter = 0, this.render(), this.context.draggable = null);
  }
  onDrop(e) {
    this.context.draggable && (Md.stop(e), this.dragOverCounter = 0, this.render(), this.dnd.canDrop(this.context.draggable.pane, this.pane) && this.context.draggable !== this && this._onDidDrop.fire({ from: this.context.draggable.pane, to: this.pane }), this.context.draggable = null);
  }
  render() {
    let e = null;
    this.dragOverCounter > 0 && (e = this.pane.dropBackground ?? ks.DefaultDragOverBackgroundColor.toString()), this.pane.dropTargetElement.style.backgroundColor = e || "";
  }
}
ks.DefaultDragOverBackgroundColor = new nr(new Bd(128, 128, 128, 0.5));
var de;
(function(d) {
  (function(i) {
    i[i.None = 0] = "None", i[i.Done = 1] = "Done", i[i.Infinite = 2] = "Infinite", i[i.While = 3] = "While", i[i.Work = 4] = "Work";
  })(d.Type || (d.Type = {})), d.None = { type: 0 }, d.Done = { type: 1 }, d.Infinite = { type: 2 };
  class e {
    constructor(n, s, o) {
      this.whilePromise = n, this.whileStart = s, this.whileDelay = o, this.type = 3;
    }
  }
  d.While = e;
  class t {
    constructor(n, s) {
      this.total = n, this.worked = s, this.type = 4;
    }
  }
  d.Work = t;
})(de || (de = {}));
class Dl extends ae {
  constructor(e, t) {
    super(), this.progressBar = e, this.scope = t, this.progressState = de.None, this.registerListeners();
  }
  registerListeners() {
    this._register(this.scope.onDidChangeActive(() => {
      this.scope.isActive ? this.onDidScopeActivate() : this.onDidScopeDeactivate();
    }));
  }
  onDidScopeActivate() {
    if (this.progressState.type !== de.Done.type)
      if (this.progressState.type === 3) {
        let e;
        if (this.progressState.whileDelay > 0) {
          const t = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);
          t > 0 && (e = t);
        }
        this.doShowWhile(e);
      } else
        this.progressState.type === 2 ? this.progressBar.infinite().show() : this.progressState.type === 4 && (this.progressState.total && this.progressBar.total(this.progressState.total).show(), this.progressState.worked && this.progressBar.worked(this.progressState.worked).show());
  }
  onDidScopeDeactivate() {
    this.progressBar.stop().hide();
  }
  show(e, t) {
    return typeof e == "boolean" ? this.progressState = de.Infinite : this.progressState = new de.Work(e, void 0), this.scope.isActive && (this.progressState.type === 2 ? this.progressBar.infinite().show(t) : this.progressState.type === 4 && typeof this.progressState.total == "number" && this.progressBar.total(this.progressState.total).show(t)), {
      total: (i) => {
        this.progressState = new de.Work(i, this.progressState.type === 4 ? this.progressState.worked : void 0), this.scope.isActive && this.progressBar.total(i);
      },
      worked: (i) => {
        !this.scope.isActive || this.progressBar.hasTotal() ? (this.progressState = new de.Work(this.progressState.type === 4 ? this.progressState.total : void 0, this.progressState.type === 4 && typeof this.progressState.worked == "number" ? this.progressState.worked + i : i), this.scope.isActive && this.progressBar.worked(i)) : (this.progressState = de.Infinite, this.progressBar.infinite().show());
      },
      done: () => {
        this.progressState = de.Done, this.scope.isActive && this.progressBar.stop().hide();
      }
    };
  }
  async showWhile(e, t) {
    this.progressState.type === 3 && (e = Promise.all([e, this.progressState.whilePromise])), this.progressState = new de.While(e, t || 0, Date.now());
    try {
      this.doShowWhile(t), await e;
    } catch {
    } finally {
      (this.progressState.type !== 3 || this.progressState.whilePromise === e) && (this.progressState = de.None, this.scope.isActive && this.progressBar.stop().hide());
    }
  }
  doShowWhile(e) {
    this.scope.isActive && this.progressBar.infinite().show(e);
  }
}
class El extends ae {
  get isActive() {
    return this._isActive;
  }
  constructor(e, t) {
    super(), this.scopeId = e, this._isActive = t, this._onDidChangeActive = this._register(new v()), this.onDidChangeActive = this._onDidChangeActive.event;
  }
  onScopeOpened(e) {
    e === this.scopeId && (this._isActive || (this._isActive = !0, this._onDidChangeActive.fire()));
  }
  onScopeClosed(e) {
    e === this.scopeId && this._isActive && (this._isActive = !1, this._onDidChangeActive.fire());
  }
}
class Il extends ae {
  get primaryActions() {
    return this._primaryActions;
  }
  get secondaryActions() {
    return this._secondaryActions;
  }
  constructor(e, t, i, n) {
    super(), this.options = t, this.menuService = i, this.contextKeyService = n, this._primaryActions = [], this._secondaryActions = [], this._onDidChange = this._register(new v()), this.onDidChange = this._onDidChange.event, this.disposables = this._register(new oe()), this.menu = this._register(i.createMenu(e, n)), this._register(this.menu.onDidChange(() => this.updateActions())), this.updateActions();
  }
  updateActions() {
    this.disposables.clear(), this._primaryActions = [], this._secondaryActions = [], at(this.menu, this.options, { primary: this._primaryActions, secondary: this._secondaryActions }), this.disposables.add(this.updateSubmenus([...this._primaryActions, ...this._secondaryActions], {})), this._onDidChange.fire();
  }
  updateSubmenus(e, t) {
    const i = new oe();
    for (const n of e)
      if (n instanceof ar && !t[n.item.submenu.id]) {
        const s = t[n.item.submenu.id] = i.add(this.menuService.createMenu(n.item.submenu, this.contextKeyService));
        i.add(s.onDidChange(() => this.updateActions())), i.add(this.updateSubmenus(n.actions, t));
      }
    return i;
  }
}
let ln = class extends ae {
  constructor(e, t, i, n, s) {
    super(), this.menuId = e, this.contextMenuId = t, this.options = i, this.contextKeyService = n, this.menuService = s, this._onDidChange = this._register(new v()), this.onDidChange = this._onDidChange.event, this.menuActions = this._register(new Il(e, this.options, s, n)), this._register(this.menuActions.onDidChange(() => this._onDidChange.fire()));
  }
  getPrimaryActions() {
    return this.menuActions.primaryActions;
  }
  getSecondaryActions() {
    return this.menuActions.secondaryActions;
  }
  getContextMenuActions() {
    const e = [];
    if (this.contextMenuId) {
      const t = this.menuService.createMenu(this.contextMenuId, this.contextKeyService);
      at(t, this.options, { primary: [], secondary: e }), t.dispose();
    }
    return e;
  }
};
ln = E([
  g(3, W),
  g(4, Lt)
], ln);
const So = new J("viewpane.action.filter"), _l = x("view-pane-container-expanded", I.chevronDown, c(
  "viewPaneContainerExpandedIcon",
  "Icon for an expanded view pane container."
)), xl = x("view-pane-container-collapsed", I.chevronRight, c(
  "viewPaneContainerCollapsedIcon",
  "Icon for a collapsed view pane container."
)), vo = Ee.as(Nd.ViewsRegistry);
let hn = class {
  get contents() {
    const e = this.items.filter((t) => t.visible);
    return e.length === 0 && this.defaultItem ? [this.defaultItem.descriptor] : e.map((t) => t.descriptor);
  }
  constructor(e, t) {
    this.id = e, this.contextKeyService = t, this._onDidChange = new v(), this.onDidChange = this._onDidChange.event, this.items = [], this.disposables = new oe(), t.onDidChangeContext(this.onDidChangeContext, this, this.disposables), ne.filter(vo.onDidChangeViewWelcomeContent, (i) => i === this.id)(this.onDidChangeViewWelcomeContent, this, this.disposables), this.onDidChangeViewWelcomeContent();
  }
  onDidChangeViewWelcomeContent() {
    const e = vo.getViewWelcomeContent(this.id);
    this.items = [];
    for (const t of e)
      if (t.when === "default")
        this.defaultItem = { descriptor: t, visible: !0 };
      else {
        const i = t.when ? this.contextKeyService.contextMatchesRules(t.when) : !0;
        this.items.push({ descriptor: t, visible: i });
      }
    this._onDidChange.fire();
  }
  onDidChangeContext() {
    let e = !1;
    for (const t of this.items) {
      if (!t.descriptor.when || t.descriptor.when === "default")
        continue;
      const i = this.contextKeyService.contextMatchesRules(t.descriptor.when);
      t.visible !== i && (t.visible = i, e = !0);
    }
    e && this._onDidChange.fire();
  }
  dispose() {
    this.disposables.dispose();
  }
};
hn = E([
  g(1, W)
], hn);
let gn = class Qr extends kt {
  get title() {
    return this._title;
  }
  get titleDescription() {
    return this._titleDescription;
  }
  constructor(e, t, i, n, s, o, r, a, u, l) {
    super({ ...e, orientation: o.getViewLocationById(e.id) === 1 ? 1 : 0 }), this.keybindingService = t, this.contextMenuService = i, this.configurationService = n, this.contextKeyService = s, this.viewDescriptorService = o, this.instantiationService = r, this.openerService = a, this.themeService = u, this.telemetryService = l, this._onDidFocus = this._register(new v()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new v()), this.onDidBlur = this._onDidBlur.event, this._onDidChangeBodyVisibility = this._register(new v()), this.onDidChangeBodyVisibility = this._onDidChangeBodyVisibility.event, this._onDidChangeTitleArea = this._register(new v()), this.onDidChangeTitleArea = this._onDidChangeTitleArea.event, this._onDidChangeViewWelcomeState = this._register(new v()), this.onDidChangeViewWelcomeState = this._onDidChangeViewWelcomeState.event, this._isVisible = !1, this.showActionsAlways = !1, this.viewWelcomeDisposable = ae.None, this.id = e.id, this._title = e.title, this._titleDescription = e.titleDescription, this.showActionsAlways = !!e.showActionsAlways, this.scopedContextKeyService = this._register(s.createScoped(this.element)), this.scopedContextKeyService.createKey("view", this.id);
    const h = this.scopedContextKeyService.createKey("viewLocation", Hs(o.getViewLocationById(this.id)));
    this._register(ne.filter(o.onDidChangeLocation, (p) => p.views.some((f) => f.id === this.id))(() => h.set(Hs(o.getViewLocationById(this.id))))), this.menuActions = this._register(this.instantiationService.createChild(new dr([W, this.scopedContextKeyService])).createInstance(ln, e.titleMenuId ?? y.ViewTitle, y.ViewTitleContext, { shouldForwardArgs: !e.donotForwardArgs })), this._register(this.menuActions.onDidChange(() => this.updateActions())), this.viewWelcomeController = new hn(this.id, s);
  }
  get headerVisible() {
    return super.headerVisible;
  }
  set headerVisible(e) {
    super.headerVisible = e, this.element.classList.toggle("merged-header", !e);
  }
  setVisible(e) {
    this._isVisible !== e && (this._isVisible = e, this.isExpanded() && this._onDidChangeBodyVisibility.fire(e));
  }
  isVisible() {
    return this._isVisible;
  }
  isBodyVisible() {
    return this._isVisible && this.isExpanded();
  }
  setExpanded(e) {
    const t = super.setExpanded(e);
    return t && this._onDidChangeBodyVisibility.fire(e), this.twistiesContainer && (this.twistiesContainer.classList.remove(...C.asClassNameArray(this.getTwistyIcon(!e))), this.twistiesContainer.classList.add(...C.asClassNameArray(this.getTwistyIcon(e)))), t;
  }
  render() {
    super.render();
    const e = sr(this.element);
    this._register(e), this._register(e.onDidFocus(() => this._onDidFocus.fire())), this._register(e.onDidBlur(() => this._onDidBlur.fire()));
  }
  renderHeader(e) {
    this.headerContainer = e, this.twistiesContainer = k(e, O(C.asCSSSelector(this.getTwistyIcon(this.isExpanded())))), this.renderHeaderTitle(e, this.title);
    const t = k(e, O(".actions"));
    t.classList.toggle("show", this.showActionsAlways), this.toolbar = this.instantiationService.createInstance(Rd, t, {
      orientation: 0,
      actionViewItemProvider: (s) => this.getActionViewItem(s),
      ariaLabel: c("viewToolbarAriaLabel", "{0} actions", this.title),
      getKeyBinding: (s) => this.keybindingService.lookupKeybinding(s.id),
      renderDropdownAsChildElement: !0,
      actionRunner: this.getActionRunner(),
      resetMenu: this.menuActions.menuId
    }), this._register(this.toolbar), this.setActions(), this._register(H(t, Z.CLICK, (s) => s.preventDefault()));
    const i = this.viewDescriptorService.getViewContainerByViewId(this.id);
    i ? this._register(this.viewDescriptorService.getViewContainerModel(i).onDidChangeContainerInfo(({ title: s }) => this.updateTitle(this.title))) : console.error(`View container model not found for view ${this.id}`);
    const n = ne.filter(this.configurationService.onDidChangeConfiguration, (s) => s.affectsConfiguration(Qr.AlwaysShowActionsConfig));
    this._register(n(this.updateActionsVisibility, this)), this.updateActionsVisibility();
  }
  getTwistyIcon(e) {
    return e ? _l : xl;
  }
  style(e) {
    super.style(e);
    const t = this.getIcon();
    if (this.iconContainer) {
      const i = Od(e.headerForeground, Ke(U));
      ee.isUri(t) ? (this.iconContainer.style.backgroundColor = i, this.iconContainer.style.color = "") : (this.iconContainer.style.color = i, this.iconContainer.style.backgroundColor = "");
    }
  }
  getIcon() {
    var e;
    return ((e = this.viewDescriptorService.getViewDescriptorById(this.id)) == null ? void 0 : e.containerIcon) || Pd;
  }
  renderHeaderTitle(e, t) {
    this.iconContainer = k(e, O(".icon", void 0));
    const i = this.getIcon();
    let n;
    if (ee.isUri(i)) {
      n = `view-${this.id.replace(/[\.\:]/g, "-")}`;
      const o = `.pane-header .icon.${n}`;
      Fd(o, `
				mask: ${$s(i)} no-repeat 50% 50%;
				mask-size: 24px;
				-webkit-mask: ${$s(i)} no-repeat 50% 50%;
				-webkit-mask-size: 16px;
			`);
    } else
      C.isThemeIcon(i) && (n = C.asClassName(i));
    n && this.iconContainer.classList.add(...n.split(" "));
    const s = this.calculateTitle(t);
    this.titleContainer = k(e, O("h3.title", { title: s }, s)), this._titleDescription && this.setTitleDescription(this._titleDescription), this.iconContainer.title = s, this.iconContainer.setAttribute("aria-label", s);
  }
  updateTitle(e) {
    const t = this.calculateTitle(e);
    this.titleContainer && (this.titleContainer.textContent = t, this.titleContainer.setAttribute("title", t)), this.iconContainer && (this.iconContainer.title = t, this.iconContainer.setAttribute("aria-label", t)), this._title = e, this._onDidChangeTitleArea.fire();
  }
  setTitleDescription(e) {
    this.titleDescriptionContainer ? (this.titleDescriptionContainer.textContent = e ?? "", this.titleDescriptionContainer.setAttribute("title", e ?? "")) : e && this.titleContainer && (this.titleDescriptionContainer = Vd(this.titleContainer, O("span.description", { title: e }, e)));
  }
  updateTitleDescription(e) {
    this.setTitleDescription(e), this._titleDescription = e, this._onDidChangeTitleArea.fire();
  }
  calculateTitle(e) {
    const t = this.viewDescriptorService.getViewContainerByViewId(this.id), i = this.viewDescriptorService.getViewContainerModel(t), n = this.viewDescriptorService.getViewDescriptorById(this.id);
    return !(this.viewDescriptorService.getDefaultContainerById(this.id) === t) && (n != null && n.containerTitle) && i.title !== n.containerTitle ? `${n.containerTitle}: ${e}` : e;
  }
  renderBody(e) {
    this.bodyContainer = e;
    const t = k(e, O(".welcome-view"));
    this.viewWelcomeContainer = O(".welcome-view-content", { tabIndex: 0 }), this.scrollableElement = this._register(new cr(this.viewWelcomeContainer, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3
    })), k(t, this.scrollableElement.getDomNode());
    const i = ne.any(this.viewWelcomeController.onDidChange, this.onDidChangeViewWelcomeState);
    this._register(i(this.updateViewWelcome, this)), this.updateViewWelcome();
  }
  layoutBody(e, t) {
    this.viewWelcomeContainer.style.height = `${e}px`, this.viewWelcomeContainer.style.width = `${t}px`, this.viewWelcomeContainer.classList.toggle("wide", t > 640), this.scrollableElement.scanDomNode();
  }
  onDidScrollRoot() {
  }
  getProgressIndicator() {
    if (this.progressBar === void 0 && (this.progressBar = this._register(new Wd(this.element, Ud)), this.progressBar.hide()), this.progressIndicator === void 0) {
      const e = this;
      this.progressIndicator = new Dl(
        Hd(this.progressBar),
        new class extends El {
          constructor() {
            super(e.id, e.isBodyVisible()), this._register(e.onDidChangeBodyVisibility((t) => t ? this.onScopeOpened(e.id) : this.onScopeClosed(e.id)));
          }
        }()
      );
    }
    return this.progressIndicator;
  }
  getProgressLocation() {
    return this.viewDescriptorService.getViewContainerByViewId(this.id).id;
  }
  getBackgroundColor() {
    switch (this.viewDescriptorService.getViewLocationById(this.id)) {
      case 1:
        return uu;
      case 0:
      case 2:
        return so;
    }
    return so;
  }
  focus() {
    this.shouldShowWelcome() ? this.viewWelcomeContainer.focus() : this.element && (this.element.focus(), this._onDidFocus.fire());
  }
  setActions() {
    if (this.toolbar) {
      const e = [...this.menuActions.getPrimaryActions()];
      this.shouldShowFilterInHeader() && e.unshift(So), this.toolbar.setActions(qs(e), qs(this.menuActions.getSecondaryActions())), this.toolbar.context = this.getActionsContext();
    }
  }
  updateActionsVisibility() {
    if (!this.headerContainer)
      return;
    const e = this.configurationService.getValue("workbench.view.alwaysShowHeaderActions");
    this.headerContainer.classList.toggle("actions-always-visible", e);
  }
  updateActions() {
    this.setActions(), this._onDidChangeTitleArea.fire();
  }
  getActionViewItem(e, t) {
    if (e.id === So.id) {
      const i = this;
      return new class extends Xn {
        constructor() {
          super(null, e);
        }
        setFocusable() {
        }
        get trapsArrowNavigation() {
          return !0;
        }
        render(n) {
          n.classList.add("viewpane-filter-container"), k(n, i.getFilterWidget().element);
        }
      }();
    }
    return ur(this.instantiationService, e, { ...t, menuAsChild: e instanceof ar });
  }
  getActionsContext() {
  }
  getActionRunner() {
  }
  getOptimalWidth() {
    return 0;
  }
  saveState() {
  }
  updateViewWelcome() {
    if (this.viewWelcomeDisposable.dispose(), !this.shouldShowWelcome()) {
      this.bodyContainer.classList.remove("welcome"), this.viewWelcomeContainer.innerText = "", this.scrollableElement.scanDomNode();
      return;
    }
    const e = this.viewWelcomeController.contents;
    if (e.length === 0) {
      this.bodyContainer.classList.remove("welcome"), this.viewWelcomeContainer.innerText = "", this.scrollableElement.scanDomNode();
      return;
    }
    const t = new oe();
    this.bodyContainer.classList.add("welcome"), this.viewWelcomeContainer.innerText = "";
    for (const { content: i, precondition: n } of e) {
      const s = i.split(`
`);
      for (let o of s) {
        if (o = o.trim(), !o)
          continue;
        const r = $d(o);
        if (r.nodes.length === 1 && typeof r.nodes[0] != "string") {
          const a = r.nodes[0], u = k(this.viewWelcomeContainer, O(".button-container")), l = new qd(
            u,
            { title: a.title, supportIcons: !0, ...Kd }
          );
          if (l.label = a.label, l.onDidClick((h) => {
            this.telemetryService.publicLog2("views.welcomeAction", { viewId: this.id, uri: a.href }), this.openerService.open(a.href, { allowCommands: !0 });
          }, null, t), t.add(l), n) {
            const h = () => l.enabled = this.contextKeyService.contextMatchesRules(n);
            h();
            const p = /* @__PURE__ */ new Set();
            n.keys().forEach((b) => p.add(b)), ne.filter(this.contextKeyService.onDidChangeContext, (b) => b.affectsSome(p))(h, null, t);
          }
        } else {
          const a = k(this.viewWelcomeContainer, O("p"));
          for (const u of r.nodes)
            if (typeof u == "string")
              k(a, document.createTextNode(u));
            else {
              const l = t.add(this.instantiationService.createInstance(zd, a, u, {}));
              if (n && u.href.startsWith("command:")) {
                const h = () => l.enabled = this.contextKeyService.contextMatchesRules(n);
                h();
                const p = /* @__PURE__ */ new Set();
                n.keys().forEach((b) => p.add(b)), ne.filter(this.contextKeyService.onDidChangeContext, (b) => b.affectsSome(p))(h, null, t);
              }
            }
        }
      }
    }
    this.scrollableElement.scanDomNode(), this.viewWelcomeDisposable = t;
  }
  shouldShowWelcome() {
    return !1;
  }
  getFilterWidget() {
  }
  shouldShowFilterInHeader() {
    return !1;
  }
};
gn.AlwaysShowActionsConfig = "workbench.view.alwaysShowHeaderActions";
gn = E([
  g(1, jn),
  g(2, At),
  g(3, G),
  g(4, W),
  g(5, Qo),
  g(6, re),
  g(7, zn),
  g(8, Mt),
  g(9, Bt)
], gn);
class gi extends He {
  constructor(e) {
    super(e), this.desc = e;
  }
  run(e, ...t) {
    const i = e.get(st).getActiveViewWithId(this.desc.viewId);
    if (i)
      return this.runInView(e, i, ...t);
  }
}
const X = O;
function pi(d) {
  const e = X("input");
  return e.type = "checkbox", e.tabIndex = -1, d.push(rr.ignoreTarget(e)), e;
}
const Cs = /* @__PURE__ */ new Map();
let pn = class Zr {
  constructor(e, t, i, n, s) {
    this.menu = e, this.breakpointSupportsCondition = t, this.breakpointItemType = i, this.debugService = n, this.labelService = s;
  }
  get templateId() {
    return Zr.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDispose = [], t.breakpoint = k(e, X(".breakpoint")), t.icon = X(".icon"), t.checkbox = pi(t.toDispose), t.toDispose.push(ct(t.checkbox, "change", (n) => {
      this.debugService.enableOrDisableBreakpoints(!t.context.enabled, t.context);
    })), k(t.breakpoint, t.icon), k(t.breakpoint, t.checkbox), t.name = k(t.breakpoint, X("span.name")), t.filePath = k(t.breakpoint, X("span.file-path")), t.actionBar = new ut(t.breakpoint), t.toDispose.push(t.actionBar);
    const i = k(t.breakpoint, X(".line-number-container"));
    return t.lineNumber = k(i, X("span.line-number.monaco-count-badge")), t;
  }
  renderElement(e, t, i) {
    i.context = e, i.breakpoint.classList.toggle("disabled", !this.debugService.getModel().areBreakpointsActivated()), i.name.textContent = je(e.uri), i.lineNumber.textContent = e.lineNumber.toString(), e.column && (i.lineNumber.textContent += `:${e.column}`), i.filePath.textContent = this.labelService.getUriLabel(Mo(e.uri), { relative: !0 }), i.checkbox.checked = e.enabled;
    const { message: n, icon: s } = ht(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), e, this.labelService);
    i.icon.className = C.asClassName(s), i.breakpoint.title = e.message || n || "", (this.debugService.state === 3 || this.debugService.state === 2) && !e.verified && i.breakpoint.classList.add("disabled");
    const r = [], a = this.debugService.getViewModel().focusedSession;
    this.breakpointSupportsCondition.set(!a || !!a.capabilities.supportsConditionalBreakpoints), this.breakpointItemType.set("breakpoint"), at(this.menu, { arg: e, shouldForwardArgs: !0 }, { primary: r, secondary: [] }, "inline"), i.actionBar.clear(), i.actionBar.push(r, { icon: !0, label: !1 }), Cs.set(e.getId(), i.actionBar.domNode);
  }
  disposeTemplate(e) {
    z(e.toDispose);
  }
};
pn.ID = "breakpoints";
pn = E([
  g(3, w),
  g(4, Ye)
], pn);
let fn = class ea {
  constructor(e, t, i, n, s) {
    this.menu = e, this.breakpointSupportsCondition = t, this.breakpointItemType = i, this.debugService = n, this.labelService = s;
  }
  get templateId() {
    return ea.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.toDispose = [], t.breakpoint = k(e, X(".breakpoint")), t.icon = X(".icon"), t.checkbox = pi(t.toDispose), t.toDispose.push(ct(t.checkbox, "change", (i) => {
      this.debugService.enableOrDisableBreakpoints(!t.context.enabled, t.context);
    })), k(t.breakpoint, t.icon), k(t.breakpoint, t.checkbox), t.name = k(t.breakpoint, X("span.name")), t.condition = k(t.breakpoint, X("span.condition")), t.actionBar = new ut(t.breakpoint), t.toDispose.push(t.actionBar), t;
  }
  renderElement(e, t, i) {
    i.context = e, i.name.textContent = e.name;
    const { icon: n, message: s } = ht(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), e, this.labelService);
    i.icon.className = C.asClassName(n), i.icon.title = s || "", i.checkbox.checked = e.enabled, i.breakpoint.title = s || "", e.condition && e.hitCondition ? i.condition.textContent = c(
      "expressionAndHitCount",
      "Expression: {0} | Hit Count: {1}",
      e.condition,
      e.hitCondition
    ) : i.condition.textContent = e.condition || e.hitCondition || "";
    const o = this.debugService.getViewModel().focusedSession;
    i.breakpoint.classList.toggle("disabled", o && !o.capabilities.supportsFunctionBreakpoints || !this.debugService.getModel().areBreakpointsActivated()), o && !o.capabilities.supportsFunctionBreakpoints && (i.breakpoint.title = c(
      "functionBreakpointsNotSupported",
      "Function breakpoints are not supported by this debug type"
    ));
    const r = [];
    this.breakpointSupportsCondition.set(!o || !!o.capabilities.supportsConditionalBreakpoints), this.breakpointItemType.set("functionBreakpoint"), at(this.menu, { arg: e, shouldForwardArgs: !0 }, { primary: r, secondary: [] }, "inline"), i.actionBar.clear(), i.actionBar.push(r, { icon: !0, label: !1 }), Cs.set(e.getId(), i.actionBar.domNode);
  }
  disposeTemplate(e) {
    z(e.toDispose);
  }
};
fn.ID = "functionbreakpoints";
fn = E([
  g(3, w),
  g(4, Ye)
], fn);
let bn = class ta {
  constructor(e, t) {
    this.debugService = e, this.labelService = t;
  }
  get templateId() {
    return ta.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.breakpoint = k(e, X(".breakpoint")), t.toDispose = [], t.icon = X(".icon"), t.checkbox = pi(t.toDispose), t.toDispose.push(ct(t.checkbox, "change", (i) => {
      this.debugService.enableOrDisableBreakpoints(!t.context.enabled, t.context);
    })), k(t.breakpoint, t.icon), k(t.breakpoint, t.checkbox), t.name = k(t.breakpoint, X("span.name")), t.accessType = k(t.breakpoint, X("span.access-type")), t;
  }
  renderElement(e, t, i) {
    i.context = e, i.name.textContent = e.description;
    const { icon: n, message: s } = ht(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), e, this.labelService);
    i.icon.className = C.asClassName(n), i.icon.title = s || "", i.checkbox.checked = e.enabled, i.breakpoint.title = s || "";
    const o = this.debugService.getViewModel().focusedSession;
    if (i.breakpoint.classList.toggle("disabled", o && !o.capabilities.supportsDataBreakpoints || !this.debugService.getModel().areBreakpointsActivated()), o && !o.capabilities.supportsDataBreakpoints && (i.breakpoint.title = c(
      "dataBreakpointsNotSupported",
      "Data breakpoints are not supported by this debug type"
    )), e.accessType) {
      const r = e.accessType === "read" ? c("read", "Read") : e.accessType === "write" ? c("write", "Write") : c("access", "Access");
      i.accessType.textContent = r;
    } else
      i.accessType.textContent = "";
  }
  disposeTemplate(e) {
    z(e.toDispose);
  }
};
bn.ID = "databreakpoints";
bn = E([
  g(0, w),
  g(1, Ye)
], bn);
let mn = class ia {
  constructor(e, t) {
    this.debugService = e, this.labelService = t;
  }
  get templateId() {
    return ia.ID;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.toDispose = [], t.breakpoint = k(e, X(".breakpoint")), t.icon = X(".icon"), t.checkbox = pi(t.toDispose), t.toDispose.push(ct(t.checkbox, "change", (i) => {
      this.debugService.enableOrDisableBreakpoints(!t.context.enabled, t.context);
    })), k(t.breakpoint, t.icon), k(t.breakpoint, t.checkbox), t.name = k(t.breakpoint, X("span.name")), t.address = k(t.breakpoint, X("span.file-path")), t.actionBar = new ut(t.breakpoint), t.toDispose.push(t.actionBar), t;
  }
  renderElement(e, t, i) {
    i.context = e, i.breakpoint.classList.toggle("disabled", !this.debugService.getModel().areBreakpointsActivated()), i.name.textContent = e.instructionReference, i.checkbox.checked = e.enabled;
    const { message: n, icon: s } = ht(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), e, this.labelService);
    i.icon.className = C.asClassName(s), i.breakpoint.title = e.message || n || "", (this.debugService.state === 3 || this.debugService.state === 2) && !e.verified && i.breakpoint.classList.add("disabled");
  }
  disposeTemplate(e) {
    z(e.toDispose);
  }
};
mn.ID = "instructionBreakpoints";
mn = E([
  g(0, w),
  g(1, Ye)
], mn);
function Bl(d, e, t, i, n, s) {
  if (d.uri.scheme === xe && n.state === 0)
    return Promise.resolve(void 0);
  const o = d.endLineNumber ? {
    startLineNumber: d.lineNumber,
    endLineNumber: d.endLineNumber,
    startColumn: d.column || 1,
    endColumn: d.endColumn || 1073741824
  } : {
    startLineNumber: d.lineNumber,
    startColumn: d.column || 1,
    endLineNumber: d.lineNumber,
    endColumn: d.column || 1073741824
  };
  return s.openEditor({
    resource: d.uri,
    options: {
      preserveFocus: t,
      selection: o,
      revealIfOpened: !0,
      selectionRevealType: 1,
      pinned: i
    }
  }, e ? Wn : si);
}
function ht(d, e, t, i) {
  const n = d === 3 || d === 2, s = t instanceof Te ? qr : t instanceof De ? Hr : t.logMessage ? Gi : mt;
  if (!t.enabled || !e)
    return {
      icon: s.disabled,
      message: t.logMessage ? c("disabledLogpoint", "Disabled Logpoint") : c("disabledBreakpoint", "Disabled Breakpoint")
    };
  const o = (a) => "message" in t && t.message ? a.concat(", " + t.message) : a;
  if (n && !t.verified)
    return {
      icon: s.unverified,
      message: "message" in t && t.message ? t.message : t.logMessage ? c("unverifiedLogpoint", "Unverified Logpoint") : c("unverifiedBreakpoint", "Unverified Breakpoint"),
      showAdapterUnverifiedMessage: !0
    };
  if (t instanceof Te)
    return t.supported ? {
      icon: s.regular,
      message: t.message || c("dataBreakpoint", "Data Breakpoint")
    } : {
      icon: s.unverified,
      message: c(
        "dataBreakpointUnsupported",
        "Data breakpoints not supported by this debug type"
      )
    };
  if (t instanceof De) {
    if (!t.supported)
      return {
        icon: s.unverified,
        message: c(
          "functionBreakpointUnsupported",
          "Function breakpoints not supported by this debug type"
        )
      };
    const a = [];
    return a.push(t.message || c("functionBreakpoint", "Function Breakpoint")), t.condition && a.push(c("expression", "Expression condition: {0}", t.condition)), t.hitCondition && a.push(c("hitCount", "Hit Count: {0}", t.hitCondition)), {
      icon: s.regular,
      message: o(a.join(`
`))
    };
  }
  if (t instanceof it) {
    if (!t.supported)
      return {
        icon: s.unverified,
        message: c(
          "instructionBreakpointUnsupported",
          "Instruction breakpoints not supported by this debug type"
        )
      };
    const a = [];
    return t.message ? a.push(t.message) : t.instructionReference ? a.push(c(
      "instructionBreakpointAtAddress",
      "Instruction breakpoint at address {0}",
      t.instructionReference
    )) : a.push(c("instructionBreakpoint", "Instruction breakpoint")), t.hitCondition && a.push(c("hitCount", "Hit Count: {0}", t.hitCondition)), {
      icon: s.regular,
      message: o(a.join(`
`))
    };
  }
  if (t.logMessage || t.condition || t.hitCondition) {
    const a = [];
    return t.supported ? (t.logMessage && a.push(c("logMessage", "Log Message: {0}", t.logMessage)), t.condition && a.push(c("expression", "Expression condition: {0}", t.condition)), t.hitCondition && a.push(c("hitCount", "Hit Count: {0}", t.hitCondition)), {
      icon: t.logMessage ? Gi.regular : $r.regular,
      message: o(a.join(`
`))
    }) : {
      icon: zr,
      message: c(
        "breakpointUnsupported",
        "Breakpoints of this type are not supported by the debugger"
      )
    };
  }
  const r = "message" in t && t.message ? t.message : t instanceof Be && i ? i.getUriLabel(t.uri) : c("breakpoint", "Breakpoint");
  return {
    icon: s.regular,
    message: r
  };
}
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.addFunctionBreakpointAction",
      title: {
        value: c("addFunctionBreakpoint", "Add Function Breakpoint"),
        original: "Add Function Breakpoint",
        mnemonicTitle: c(
          { key: "miFunctionBreakpoint", comment: ["&& denotes a mnemonic"] },
          "&&Function Breakpoint..."
        )
      },
      f1: !0,
      icon: ul,
      menu: [{
        id: y.ViewTitle,
        group: "navigation",
        order: 10,
        when: A.equals("view", dt)
      }, {
        id: y.MenubarNewBreakpointMenu,
        group: "1_breakpoints",
        order: 3,
        when: Q
      }]
    });
  }
  run(d) {
    d.get(w).addFunctionBreakpoint();
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.toggleBreakpointsActivatedAction",
      title: { value: c("activateBreakpoints", "Toggle Activate Breakpoints"), original: "Toggle Activate Breakpoints" },
      f1: !0,
      icon: hl,
      menu: {
        id: y.ViewTitle,
        group: "navigation",
        order: 20,
        when: A.equals("view", dt)
      }
    });
  }
  run(d) {
    const e = d.get(w);
    e.setBreakpointsActivated(!e.getModel().areBreakpointsActivated());
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.removeBreakpoint",
      title: c("removeBreakpoint", "Remove Breakpoint"),
      icon: I.removeClose,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "3_modification",
        order: 10,
        when: Ue.notEqualsTo("exceptionBreakpoint")
      }, {
        id: y.DebugBreakpointsContext,
        group: "inline",
        order: 20,
        when: Ue.notEqualsTo("exceptionBreakpoint")
      }]
    });
  }
  async run(d, e) {
    const t = d.get(w);
    e instanceof Be ? await t.removeBreakpoints(e.getId()) : e instanceof De ? await t.removeFunctionBreakpoints(e.getId()) : e instanceof Te ? await t.removeDataBreakpoints(e.getId()) : e instanceof it && await t.removeInstructionBreakpoints(e.instructionReference);
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.removeAllBreakpoints",
      title: {
        original: "Remove All Breakpoints",
        value: c("removeAllBreakpoints", "Remove All Breakpoints"),
        mnemonicTitle: c(
          { key: "miRemoveAllBreakpoints", comment: ["&& denotes a mnemonic"] },
          "Remove &&All Breakpoints"
        )
      },
      f1: !0,
      icon: ll,
      menu: [{
        id: y.ViewTitle,
        group: "navigation",
        order: 30,
        when: A.equals("view", dt)
      }, {
        id: y.DebugBreakpointsContext,
        group: "3_modification",
        order: 20,
        when: A.and(Tt, Ue.notEqualsTo("exceptionBreakpoint"))
      }, {
        id: y.MenubarDebugMenu,
        group: "5_breakpoints",
        order: 3,
        when: Q
      }]
    });
  }
  run(d) {
    const e = d.get(w);
    e.removeBreakpoints(), e.removeFunctionBreakpoints(), e.removeDataBreakpoints(), e.removeInstructionBreakpoints();
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.enableAllBreakpoints",
      title: {
        original: "Enable All Breakpoints",
        value: c("enableAllBreakpoints", "Enable All Breakpoints"),
        mnemonicTitle: c(
          { key: "miEnableAllBreakpoints", comment: ["&& denotes a mnemonic"] },
          "&&Enable All Breakpoints"
        )
      },
      f1: !0,
      precondition: Q,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "z_commands",
        order: 10,
        when: A.and(Tt, Ue.notEqualsTo("exceptionBreakpoint"))
      }, {
        id: y.MenubarDebugMenu,
        group: "5_breakpoints",
        order: 1,
        when: Q
      }]
    });
  }
  async run(d) {
    await d.get(w).enableOrDisableBreakpoints(!0);
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.disableAllBreakpoints",
      title: {
        original: "Disable All Breakpoints",
        value: c("disableAllBreakpoints", "Disable All Breakpoints"),
        mnemonicTitle: c(
          { key: "miDisableAllBreakpoints", comment: ["&& denotes a mnemonic"] },
          "Disable A&&ll Breakpoints"
        )
      },
      f1: !0,
      precondition: Q,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "z_commands",
        order: 20,
        when: A.and(Tt, Ue.notEqualsTo("exceptionBreakpoint"))
      }, {
        id: y.MenubarDebugMenu,
        group: "5_breakpoints",
        order: 2,
        when: Q
      }]
    });
  }
  async run(d) {
    await d.get(w).enableOrDisableBreakpoints(!1);
  }
});
ve(class extends He {
  constructor() {
    super({
      id: "workbench.debug.viewlet.action.reapplyBreakpointsAction",
      title: { value: c("reapplyAllBreakpoints", "Reapply All Breakpoints"), original: "Reapply All Breakpoints" },
      f1: !0,
      precondition: Oe,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "z_commands",
        order: 30,
        when: A.and(Tt, Ue.notEqualsTo("exceptionBreakpoint"))
      }]
    });
  }
  async run(d) {
    await d.get(w).setBreakpointsActivated(!0);
  }
});
ve(class extends gi {
  constructor() {
    super({
      id: "debug.editBreakpoint",
      viewId: dt,
      title: c("editCondition", "Edit Condition..."),
      icon: I.edit,
      precondition: lr,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "navigation",
        order: 10
      }, {
        id: y.DebugBreakpointsContext,
        group: "inline",
        order: 10
      }]
    });
  }
  async runInView(d, e, t) {
    var s;
    const i = d.get(w), n = d.get(se);
    if (t instanceof Be) {
      const o = await Bl(t, !1, !1, !0, i, n);
      if (o) {
        const r = o.getControl();
        Ae(r) && ((s = r.getContribution(ci)) == null || s.showBreakpointWidget(t.lineNumber, t.column));
      }
    } else if (t instanceof De) {
      const o = d.get(At), r = [
        new J("breakpoint.editCondition", c("editCondition", "Edit Condition..."), void 0, !0, async () => e.renderInputBox({ breakpoint: t, type: "condition" })),
        new J("breakpoint.editCondition", c("editHitCount", "Edit Hit Count..."), void 0, !0, async () => e.renderInputBox({ breakpoint: t, type: "hitCount" }))
      ], a = Cs.get(t.getId());
      a && o.showContextMenu({
        getActions: () => r,
        getAnchor: () => a,
        onHide: () => z(r)
      });
    } else
      e.renderInputBox({ breakpoint: t, type: "condition" });
  }
});
ve(class extends gi {
  constructor() {
    super({
      id: "debug.editFunctionBreakpoint",
      viewId: dt,
      title: c("editBreakpoint", "Edit Function Breakpoint..."),
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "1_breakpoints",
        order: 10,
        when: Ue.isEqualTo("functionBreakpoint")
      }]
    });
  }
  runInView(d, e, t) {
    e.renderInputBox({ breakpoint: t, type: "name" });
  }
});
ve(class extends gi {
  constructor() {
    super({
      id: "debug.editFunctionBreakpointHitCount",
      viewId: dt,
      title: c("editHitCount", "Edit Hit Count..."),
      precondition: lr,
      menu: [{
        id: y.DebugBreakpointsContext,
        group: "navigation",
        order: 20,
        when: Ue.isEqualTo("functionBreakpoint")
      }]
    });
  }
  runInView(d, e, t) {
    e.renderInputBox({ breakpoint: t, type: "hitCount" });
  }
});
class Zt extends ae {
  constructor(e) {
    super(), this._editor = e, this._altListeningMouse = !1, this._altMouseTriggered = !1, this._register(this._editor.onMouseDown((t) => {
      this._altListeningMouse && (this._altMouseTriggered = !0);
    })), this._register(this._editor.onKeyDown((t) => {
      t.equals(512) && (this._altListeningMouse || (this._altMouseTriggered = !1), this._altListeningMouse = !0);
    })), this._register(this._editor.onKeyUp((t) => {
      t.equals(512) && (this._altMouseTriggered && t.preventDefault(), this._altListeningMouse = !1, this._altMouseTriggered = !1);
    }));
  }
}
Zt.ID = "editor.contrib.menuPreventer";
rt(Zt.ID, Zt, 2);
const Tl = "editor.contrib.selectionClipboard";
let Ne = class Sn {
  static get(e) {
    return e.getContribution(Sn.ID);
  }
  constructor(e, t, i, n, s) {
    this._editor = e, this._snippetService = t, this._clipboardService = i, this._languageFeaturesService = n, this._activeSnippets = [], this._hasSnippets = Sn.ContextKey.bindTo(s), this._configListener = this._editor.onDidChangeConfiguration((o) => {
      o.hasChanged(118) && this._update();
    }), this._update();
  }
  dispose() {
    var e;
    this._configListener.dispose(), (e = this._selectionListener) == null || e.dispose();
  }
  _update() {
    var t;
    const e = this._editor.getOption(118) === "onlySnippets";
    this._enabled !== e && (this._enabled = e, this._enabled ? (this._selectionListener = this._editor.onDidChangeCursorSelection((i) => this._updateSnippets()), this._editor.getModel() && this._updateSnippets()) : (t = this._selectionListener) == null || t.dispose());
  }
  _updateSnippets() {
    var o;
    if (this._activeSnippets = [], (o = this._completionProvider) == null || o.dispose(), !this._editor.hasModel())
      return;
    const e = this._editor.getSelection(), t = this._editor.getModel();
    t.tokenization.tokenizeIfCheap(e.positionLineNumber);
    const i = t.getLanguageIdAtPosition(e.positionLineNumber, e.positionColumn), n = this._snippetService.getSnippetsSync(i);
    if (!n) {
      this._hasSnippets.set(!1);
      return;
    }
    if (K.isEmpty(e)) {
      const r = lu(t, e.getPosition());
      if (r)
        for (const a of n)
          r.endsWith(a.prefix) && this._activeSnippets.push(a);
    } else if (!K.spansMultipleLines(e) && t.getValueLengthInRange(e) <= 100) {
      const r = t.getValueInRange(e);
      if (r)
        for (const a of n)
          r === a.prefix && this._activeSnippets.push(a);
    }
    const s = this._activeSnippets.length;
    if (s === 0)
      this._hasSnippets.set(!1);
    else if (s === 1)
      this._hasSnippets.set(!0);
    else {
      this._hasSnippets.set(!0), this._completionProvider = {
        dispose: () => {
          r.dispose();
        },
        provideCompletionItems: (a, u) => a !== t || !e.containsPosition(u) ? void 0 : { suggestions: this._activeSnippets.map((h) => {
          const p = K.fromPositions(u.delta(0, -h.prefix.length), u);
          return new hu(h, p);
        }) }
      };
      const r = this._languageFeaturesService.completionProvider.register({ language: t.getLanguageId(), pattern: t.uri.fsPath, scheme: t.uri.scheme }, this._completionProvider);
    }
  }
  async performSnippetCompletions() {
    var e;
    if (this._editor.hasModel())
      if (this._activeSnippets.length === 1) {
        const [t] = this._activeSnippets;
        let i;
        if (t.needsClipboard) {
          const n = new Xd(
            this._editor,
            5
          );
          if (i = await this._clipboardService.readText(), !n.validate(this._editor))
            return;
        }
        (e = Qn.get(this._editor)) == null || e.insert(t.codeSnippet, {
          overwriteBefore: t.prefix.length,
          overwriteAfter: 0,
          clipboardText: i
        });
      } else
        this._activeSnippets.length > 1 && this._completionProvider && Jd(this._editor, this._completionProvider);
  }
};
Ne.ID = "editor.tabCompletionController";
Ne.ContextKey = new Gd("hasSnippetCompletions", void 0);
Ne = E([
  g(1, jd),
  g(2, oi),
  g(3, Nt),
  g(4, W)
], Ne);
rt(Ne.ID, Ne, 0);
const Al = Jn.bindToContribution(Ne.get);
Yn(new Al({
  id: "insertSnippet",
  precondition: Ne.ContextKey,
  handler: (d) => d.performSnippetCompletions(),
  kbOpts: {
    weight: 100,
    kbExpr: A.and(
      Xe.editorTextFocus,
      Xe.tabDoesNotMoveFocus,
      Qn.InSnippetMode.toNegated()
    ),
    primary: 2
  }
}));
function Ll() {
  return {
    wordWrap: "on",
    overviewRulerLanes: 0,
    glyphMargin: !1,
    lineNumbers: "off",
    folding: !1,
    selectOnLineNumbers: !1,
    hideCursorInOverviewRuler: !0,
    selectionHighlight: !1,
    scrollbar: {
      horizontal: "hidden"
    },
    lineDecorationsWidth: 0,
    overviewRulerBorder: !1,
    scrollBeyondLastLine: !1,
    renderLineHighlight: "none",
    fixedOverflowWidgets: !0,
    acceptSuggestionOnEnter: "smart",
    dragAndDrop: !1,
    revealHorizontalRightPadding: 5,
    minimap: {
      enabled: !1
    },
    guides: {
      indentation: !1
    }
  };
}
function Ml() {
  return {
    isSimpleWidget: !0,
    contributions: Yd.getSomeEditorContributions([
      Zt.ID,
      Tl,
      Qd.ID,
      Zd.ID,
      Qn.ID,
      Ne.ID
    ])
  };
}
const wo = O, ys = ec("privateBreakpointWidgetService"), ko = "breakpointwidgetdecoration";
function Nl(d) {
  return d.getModel().bracketPairs.getBracketPairsInRange(K.fromPositions(d.getPosition())).some((i) => i.openingBracketInfo.bracketText === "{");
}
function Rl(d, e) {
  var i;
  const t = (i = d.getColor(oc)) == null ? void 0 : i.transparent(0.4);
  return [{
    range: {
      startLineNumber: 0,
      endLineNumber: 0,
      startColumn: 0,
      endColumn: 1
    },
    renderOptions: {
      after: {
        contentText: e,
        color: t ? t.toString() : void 0
      }
    }
  }];
}
let vn = class extends hr {
  constructor(e, t, i, n, s, o, r, a, u, l, h, p, f) {
    super(e, { showFrame: !0, showArrow: !1, frameWidth: 1, isAccessible: !0 }), this.lineNumber = t, this.column = i, this.contextViewService = s, this.debugService = o, this.themeService = r, this.contextKeyService = a, this.instantiationService = u, this.modelService = l, this.codeEditorService = h, this._configurationService = p, this.languageFeaturesService = f, this.conditionInput = "", this.hitCountInput = "", this.logMessageInput = "", this.toDispose = [];
    const b = this.editor.getModel();
    if (b) {
      const m = b.uri, S = this.debugService.getModel().getBreakpoints({ lineNumber: this.lineNumber, column: this.column, uri: m });
      this.breakpoint = S.length ? S[0] : void 0;
    }
    n === void 0 ? this.breakpoint && !this.breakpoint.condition && !this.breakpoint.hitCondition && this.breakpoint.logMessage ? this.context = 2 : this.breakpoint && !this.breakpoint.condition && this.breakpoint.hitCondition ? this.context = 1 : this.context = 0 : this.context = n, this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints((m) => {
      this.breakpoint && m && m.removed && m.removed.indexOf(this.breakpoint) >= 0 && this.dispose();
    })), this.codeEditorService.registerDecorationType("breakpoint-widget", ko, {}), this.create();
  }
  get placeholder() {
    switch (this.context) {
      case 2:
        return c(
          "breakpointWidgetLogMessagePlaceholder",
          "Message to log when breakpoint is hit. Expressions within {} are interpolated. 'Enter' to accept, 'esc' to cancel."
        );
      case 1:
        return c(
          "breakpointWidgetHitCountPlaceholder",
          "Break when hit count condition is met. 'Enter' to accept, 'esc' to cancel."
        );
      default:
        return c(
          "breakpointWidgetExpressionPlaceholder",
          "Break when expression evaluates to true. 'Enter' to accept, 'esc' to cancel."
        );
    }
  }
  getInputValue(e) {
    switch (this.context) {
      case 2:
        return e && e.logMessage ? e.logMessage : this.logMessageInput;
      case 1:
        return e && e.hitCondition ? e.hitCondition : this.hitCountInput;
      default:
        return e && e.condition ? e.condition : this.conditionInput;
    }
  }
  rememberInput() {
    const e = this.input.getModel().getValue();
    switch (this.context) {
      case 2:
        this.logMessageInput = e;
        break;
      case 1:
        this.hitCountInput = e;
        break;
      default:
        this.conditionInput = e;
    }
  }
  setInputMode() {
    if (this.editor.hasModel()) {
      const e = this.context === 2 ? gr : this.editor.getModel().getLanguageId();
      this.input.getModel().setLanguage(e);
    }
  }
  show(e) {
    const t = this.input.getModel().getLineCount();
    super.show(e, t + 1);
  }
  fitHeightToContent() {
    const e = this.input.getModel().getLineCount();
    this._relayout(e + 1);
  }
  _fillContainer(e) {
    this.setCssClass("breakpoint-widget");
    const t = new pr(
      [{ text: c("expression", "Expression") }, { text: c("hitCount", "Hit Count") }, { text: c("logMessage", "Log Message") }],
      this.context,
      this.contextViewService,
      Zn,
      { ariaLabel: c("breakpointType", "Breakpoint Type") }
    );
    this.selectContainer = wo(".breakpoint-select-container"), t.render(k(e, this.selectContainer)), t.onDidSelect((i) => {
      this.rememberInput(), this.context = i.index, this.setInputMode();
      const n = this.getInputValue(this.breakpoint);
      this.input.getModel().setValue(n), this.input.focus();
    }), this.inputContainer = wo(".inputContainer"), this.createBreakpointInput(k(e, this.inputContainer)), this.input.getModel().setValue(this.getInputValue(this.breakpoint)), this.toDispose.push(this.input.getModel().onDidChangeContent(() => {
      this.fitHeightToContent();
    })), this.input.setPosition({ lineNumber: 1, column: this.input.getModel().getLineMaxColumn(1) }), setTimeout(() => this.input.focus(), 150);
  }
  _doLayout(e, t) {
    this.heightInPx = e, this.input.layout({ height: e, width: t - 113 }), this.centerInputVertically();
  }
  createBreakpointInput(e) {
    const t = this.contextKeyService.createScoped(e);
    this.toDispose.push(t);
    const i = this.instantiationService.createChild(new dr(
      [W, t],
      [ys, this]
    )), n = this.createEditorOptions(), s = Ml();
    this.input = i.createInstance(ic, e, n, s), fr.bindTo(t).set(!0);
    const o = this.modelService.createModel("", null, ee.parse(`${xe}:${this.editor.getId()}:breakpointinput`), !0);
    this.editor.hasModel() && o.setLanguage(this.editor.getModel().getLanguageId()), this.input.setModel(o), this.setInputMode(), this.toDispose.push(o);
    const r = () => {
      const u = this.input.getModel().getValue() ? [] : Rl(this.themeService.getColorTheme(), this.placeholder);
      this.input.setDecorationsByType("breakpoint-widget", ko, u);
    };
    this.input.getModel().onDidChangeContent(() => r()), this.themeService.onDidColorThemeChange(() => r()), this.toDispose.push(this.languageFeaturesService.completionProvider.register({ scheme: xe, hasAccessToAllModels: !0 }, {
      provideCompletionItems: (a, u, l, h) => {
        let p;
        const f = this.editor.getModel();
        return f && (this.context === 0 || this.context === 2 && Nl(this.input)) ? p = nc(this.languageFeaturesService.completionProvider, f, new es(this.lineNumber, 1), new sc(
          void 0,
          (/* @__PURE__ */ new Set()).add(27)
        ), l, h).then((b) => {
          let m = 0;
          if (this.context === 0)
            m = u.column - 1;
          else {
            const S = this.input.getModel().getValue();
            for (; u.column - 2 - m >= 0 && S[u.column - 2 - m] !== "{" && S[u.column - 2 - m] !== " "; )
              m++;
          }
          return {
            suggestions: b.items.map((S) => (S.completion.range = K.fromPositions(u.delta(0, -m), u), S.completion))
          };
        }) : p = Promise.resolve({ suggestions: [] }), p;
      }
    })), this.toDispose.push(this._configurationService.onDidChangeConfiguration((a) => {
      (a.affectsConfiguration("editor.fontSize") || a.affectsConfiguration("editor.lineHeight")) && (this.input.updateOptions(this.createEditorOptions()), this.centerInputVertically());
    }));
  }
  createEditorOptions() {
    const e = this._configurationService.getValue("editor"), t = Ll();
    return t.fontSize = e.fontSize, t.fontFamily = e.fontFamily, t.lineHeight = e.lineHeight, t.fontLigatures = e.fontLigatures, t.ariaLabel = this.placeholder, t;
  }
  centerInputVertically() {
    if (this.container && typeof this.heightInPx == "number") {
      const e = this.input.getOption(64), t = this.input.getModel().getLineCount(), i = (this.heightInPx - t * e) / 2;
      this.inputContainer.style.marginTop = i + "px";
    }
  }
  close(e) {
    if (e) {
      let t = this.breakpoint && this.breakpoint.condition, i = this.breakpoint && this.breakpoint.hitCondition, n = this.breakpoint && this.breakpoint.logMessage;
      if (this.rememberInput(), (this.conditionInput || this.context === 0) && (t = this.conditionInput), (this.hitCountInput || this.context === 1) && (i = this.hitCountInput), (this.logMessageInput || this.context === 2) && (n = this.logMessageInput), this.breakpoint) {
        const s = /* @__PURE__ */ new Map();
        s.set(this.breakpoint.getId(), {
          condition: t,
          hitCondition: i,
          logMessage: n
        }), this.debugService.updateBreakpoints(this.breakpoint.originalUri, s, !1).then(void 0, br);
      } else {
        const s = this.editor.getModel();
        s && this.debugService.addBreakpoints(s.uri, [{
          lineNumber: this.lineNumber,
          column: this.column,
          enabled: !0,
          condition: t,
          hitCondition: i,
          logMessage: n
        }]);
      }
    }
    this.dispose();
  }
  dispose() {
    super.dispose(), this.input.dispose(), z(this.toDispose), setTimeout(() => this.editor.focus(), 0);
  }
};
vn = E([
  g(4, Rt),
  g(5, w),
  g(6, Mt),
  g(7, W),
  g(8, re),
  g(9, $n),
  g(10, tc),
  g(11, G),
  g(12, Nt)
], vn);
class Ol extends Jn {
  constructor() {
    super({
      id: "breakpointWidget.action.acceptInput",
      precondition: ts,
      kbOpts: {
        kbExpr: fr,
        primary: 3,
        weight: 100
      }
    });
  }
  runEditorCommand(e, t) {
    e.get(ys).close(!0);
  }
}
class Pl extends Jn {
  constructor() {
    super({
      id: "closeBreakpointWidget",
      precondition: ts,
      kbOpts: {
        kbExpr: Xe.textInputFocus,
        primary: 9,
        secondary: [1033],
        weight: 100
      }
    });
  }
  runEditorCommand(e, t, i) {
    const n = t.getContribution(ci);
    if (n)
      return n.closeBreakpointWidget();
    e.get(ys).close(!1);
  }
}
Yn(new Ol());
Yn(new Pl());
const Fl = O, Vl = {
  description: "breakpoint-helper-decoration",
  glyphMarginClassName: C.asClassName(Kr),
  stickiness: 1
};
function Wl(d, e, t, i, n, s) {
  const o = [];
  return t.forEach((r) => {
    if (r.lineNumber > e.getLineCount())
      return;
    const a = t.some((h) => h !== r && h.lineNumber === r.lineNumber), u = e.getLineFirstNonWhitespaceColumn(r.lineNumber), l = e.validateRange(
      r.column ? new K(
        r.lineNumber,
        r.column,
        r.lineNumber,
        r.column + 1
      ) : new K(r.lineNumber, u, r.lineNumber, u + 1)
    );
    o.push({
      options: Ul(d, e, r, i, n, s, a),
      range: l
    });
  }), o;
}
function Ul(d, e, t, i, n, s, o) {
  const r = d.get(w), a = d.get(ni), { icon: u, message: l, showAdapterUnverifiedMessage: h } = ht(i, n, t, void 0);
  let p, f;
  if (h) {
    let S;
    f = r.getModel().getSessions().map((N) => {
      var V;
      const P = r.getAdapterManager().getDebugger(N.configuration.type), L = (V = P == null ? void 0 : P.strings) == null ? void 0 : V[uc.UnverifiedBreakpoints];
      if (L)
        return S || (S = vr(a.guessLanguageIdByFilepathOrFirstLine(t.uri))), S && P.interestedInLanguage(S) ? L : void 0;
    }).find((N) => !!N);
  }
  if (l)
    if (p = new Ks(void 0, { isTrusted: !0, supportThemeIcons: !0 }), t.condition || t.hitCondition) {
      const S = e.getLanguageId();
      p.appendCodeblock(S, l), f && p.appendMarkdown("$(warning) " + f);
    } else
      p.appendText(l), f && p.appendMarkdown(`

$(warning) ` + f);
  else
    f && (p = new Ks(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(f));
  let b = null;
  s && (b = {
    color: is(na),
    position: ns.Left
  });
  const m = t.column && (o || t.column > e.getLineFirstNonWhitespaceColumn(t.lineNumber));
  return {
    description: "breakpoint-decoration",
    glyphMarginClassName: C.asClassName(u),
    glyphMarginHoverMessage: p,
    stickiness: 1,
    before: m ? {
      content: ui,
      inlineClassName: "debug-breakpoint-placeholder",
      inlineClassNameAffectsLetterSpacing: !0
    } : void 0,
    overviewRuler: b
  };
}
async function Hl(d, e, t) {
  return t.capabilities.supportsBreakpointLocationsRequest ? await Promise.all(Le(e, (i) => i).map(async (i) => {
    try {
      return { lineNumber: i, positions: await t.breakpointsLocations(d.uri, i) };
    } catch {
      return { lineNumber: i, positions: [] };
    }
  })) : [];
}
function $l(d, e, t) {
  const i = [];
  for (const { positions: n, lineNumber: s } of t) {
    if (n.length === 0)
      continue;
    const o = d.getLineFirstNonWhitespaceColumn(s), r = d.getLineLastNonWhitespaceColumn(s);
    n.forEach((a) => {
      const u = new K(a.lineNumber, a.column, a.lineNumber, a.column + 1);
      if (a.column <= o && !e.some(
        (h) => h.range.startColumn > o && h.range.startLineNumber === a.lineNumber
      ) || a.column > r)
        return;
      const l = e.find((h) => h.range.equalsRange(u));
      l && l.inlineWidget || i.push({
        range: u,
        options: {
          description: "breakpoint-placeholder-decoration",
          stickiness: 1,
          before: l ? void 0 : {
            content: ui,
            inlineClassName: "debug-breakpoint-placeholder",
            inlineClassNameAffectsLetterSpacing: !0
          }
        },
        breakpoint: l ? l.breakpoint : void 0
      });
    });
  }
  return i;
}
let wn = class {
  constructor(e, t, i, n, s, o, r, a) {
    this.editor = e, this.debugService = t, this.contextMenuService = i, this.instantiationService = n, this.dialogService = o, this.configurationService = r, this.labelService = a, this.breakpointHintDecoration = null, this.toDispose = [], this.ignoreDecorationsChangedEvent = !1, this.ignoreBreakpointsChangeEvent = !1, this.breakpointDecorations = [], this.candidateDecorations = [], this.breakpointWidgetVisible = ts.bindTo(s), this.setDecorationsScheduler = new fe(() => this.setDecorations(), 30), this.setDecorationsScheduler.schedule(), this.registerListeners();
  }
  getContextMenuActionsAtPosition(e, t) {
    if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
      return [];
    if (!this.debugService.canSetBreakpointsIn(t))
      return [];
    const i = this.debugService.getModel().getBreakpoints({ lineNumber: e, uri: t.uri });
    return this.getContextMenuActions(i, t.uri, e);
  }
  registerListeners() {
    this.toDispose.push(this.editor.onMouseDown(async (e) => {
      if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
        return;
      const t = this.editor.getModel();
      if (!e.target.position || !t || e.target.type !== 2 || e.target.detail.isAfterLines || !this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber))
        return;
      const i = this.debugService.canSetBreakpointsIn(t), n = e.target.position.lineNumber, s = t.uri;
      if (!(e.event.rightButton || Ce && e.event.leftButton && e.event.ctrlKey)) {
        const o = this.debugService.getModel().getBreakpoints({ uri: s, lineNumber: n });
        if (o.length) {
          const r = e.event.shiftKey, a = o.some((u) => u.enabled);
          if (r)
            o.forEach((u) => this.debugService.enableOrDisableBreakpoints(!a, u));
          else if (!rc && o.some((u) => !!u.condition || !!u.logMessage || !!u.hitCondition)) {
            const u = o.every((f) => !!f.logMessage), l = u ? c("logPoint", "Logpoint") : c("breakpoint", "Breakpoint"), h = c(
              "breakpointHasConditionDisabled",
              "This {0} has a {1} that will get lost on remove. Consider enabling the {0} instead.",
              l.toLowerCase(),
              u ? c("message", "message") : c("condition", "condition")
            ), p = c(
              "breakpointHasConditionEnabled",
              "This {0} has a {1} that will get lost on remove. Consider disabling the {0} instead.",
              l.toLowerCase(),
              u ? c("message", "message") : c("condition", "condition")
            );
            await this.dialogService.prompt({
              type: ye.Info,
              message: a ? p : h,
              buttons: [
                {
                  label: c(
                    { key: "removeLogPoint", comment: ["&& denotes a mnemonic"] },
                    "&&Remove {0}",
                    l
                  ),
                  run: () => o.forEach((f) => this.debugService.removeBreakpoints(f.getId()))
                },
                {
                  label: c(
                    "disableLogPoint",
                    "{0} {1}",
                    a ? c({ key: "disable", comment: ["&& denotes a mnemonic"] }, "&&Disable") : c({ key: "enable", comment: ["&& denotes a mnemonic"] }, "&&Enable"),
                    l
                  ),
                  run: () => o.forEach((f) => this.debugService.enableOrDisableBreakpoints(!a, f))
                }
              ],
              cancelButton: !0
            });
          } else
            a ? o.forEach((u) => this.debugService.removeBreakpoints(u.getId())) : o.forEach((u) => this.debugService.enableOrDisableBreakpoints(!a, u));
        } else
          i && this.debugService.addBreakpoints(s, [{ lineNumber: n }]);
      }
    })), ac.pointerEvents && dc || (this.toDispose.push(this.editor.onMouseMove((e) => {
      if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
        return;
      let t = -1;
      const i = this.editor.getModel();
      i && e.target.position && (e.target.type === 2 || e.target.type === 3) && this.debugService.canSetBreakpointsIn(i) && this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber) && (e.target.detail.isAfterLines || (t = e.target.position.lineNumber)), this.ensureBreakpointHintDecoration(t);
    })), this.toDispose.push(this.editor.onMouseLeave(() => {
      this.ensureBreakpointHintDecoration(-1);
    }))), this.toDispose.push(this.editor.onDidChangeModel(async () => {
      this.closeBreakpointWidget(), await this.setDecorations();
    })), this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(() => {
      !this.ignoreBreakpointsChangeEvent && !this.setDecorationsScheduler.isScheduled() && this.setDecorationsScheduler.schedule();
    })), this.toDispose.push(this.debugService.onDidChangeState(() => {
      this.setDecorationsScheduler.isScheduled() || this.setDecorationsScheduler.schedule();
    })), this.toDispose.push(this.editor.onDidChangeModelDecorations(() => this.onModelDecorationsChanged())), this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
      (e.affectsConfiguration("debug.showBreakpointsInOverviewRuler") || e.affectsConfiguration("debug.showInlineBreakpointCandidates")) && await this.setDecorations();
    }));
  }
  getContextMenuActions(e, t, i, n) {
    const s = [];
    if (e.length === 1) {
      const o = e[0].logMessage ? c("logPoint", "Logpoint") : c("breakpoint", "Breakpoint");
      s.push(new J(
        "debug.removeBreakpoint",
        c("removeBreakpoint", "Remove {0}", o),
        void 0,
        !0,
        async () => {
          await this.debugService.removeBreakpoints(e[0].getId());
        }
      )), s.push(new J(
        "workbench.debug.action.editBreakpointAction",
        c("editBreakpoint", "Edit {0}...", o),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(e[0].lineNumber, e[0].column))
      )), s.push(new J(
        "workbench.debug.viewlet.action.toggleBreakpoint",
        e[0].enabled ? c("disableBreakpoint", "Disable {0}", o) : c("enableBreakpoint", "Enable {0}", o),
        void 0,
        !0,
        () => this.debugService.enableOrDisableBreakpoints(!e[0].enabled, e[0])
      ));
    } else if (e.length > 1) {
      const o = e.slice().sort((r, a) => r.column && a.column ? r.column - a.column : 1);
      s.push(new mi(
        "debug.removeBreakpoints",
        c("removeBreakpoints", "Remove Breakpoints"),
        o.map(
          (r) => new J("removeInlineBreakpoint", r.column ? c(
            "removeInlineBreakpointOnColumn",
            "Remove Inline Breakpoint on Column {0}",
            r.column
          ) : c("removeLineBreakpoint", "Remove Line Breakpoint"), void 0, !0, () => this.debugService.removeBreakpoints(r.getId()))
        )
      )), s.push(new mi(
        "debug.editBreakpoints",
        c("editBreakpoints", "Edit Breakpoints"),
        o.map(
          (r) => new J("editBreakpoint", r.column ? c(
            "editInlineBreakpointOnColumn",
            "Edit Inline Breakpoint on Column {0}",
            r.column
          ) : c("editLineBreakpoint", "Edit Line Breakpoint"), void 0, !0, () => Promise.resolve(this.showBreakpointWidget(r.lineNumber, r.column)))
        )
      )), s.push(new mi(
        "debug.enableDisableBreakpoints",
        c("enableDisableBreakpoints", "Enable/Disable Breakpoints"),
        o.map((r) => new J(
          r.enabled ? "disableColumnBreakpoint" : "enableColumnBreakpoint",
          r.enabled ? r.column ? c(
            "disableInlineColumnBreakpoint",
            "Disable Inline Breakpoint on Column {0}",
            r.column
          ) : c("disableBreakpointOnLine", "Disable Line Breakpoint") : r.column ? c("enableBreakpoints", "Enable Inline Breakpoint on Column {0}", r.column) : c("enableBreakpointOnLine", "Enable Line Breakpoint"),
          void 0,
          !0,
          () => this.debugService.enableOrDisableBreakpoints(!r.enabled, r)
        ))
      ));
    } else
      s.push(new J(
        "addBreakpoint",
        c("addBreakpoint", "Add Breakpoint"),
        void 0,
        !0,
        () => this.debugService.addBreakpoints(t, [{ lineNumber: i, column: n }])
      )), s.push(new J(
        "addConditionalBreakpoint",
        c("addConditionalBreakpoint", "Add Conditional Breakpoint..."),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(i, n, 0))
      )), s.push(new J(
        "addLogPoint",
        c("addLogPoint", "Add Logpoint..."),
        void 0,
        !0,
        () => Promise.resolve(this.showBreakpointWidget(i, n, 2))
      ));
    return this.debugService.state === 2 && (s.push(new ir()), s.push(new J(
      "runToLine",
      c("runToLine", "Run to Line"),
      void 0,
      !0,
      () => this.debugService.runTo(t, i).catch(br)
    ))), s;
  }
  marginFreeFromNonDebugDecorations(e) {
    const t = this.editor.getLineDecorations(e);
    if (t)
      for (const { options: i } of t) {
        const n = i.glyphMarginClassName;
        if (n && (!n.includes("codicon-") || n.includes("codicon-testing-") || n.includes("codicon-merge-") || n.includes("codicon-arrow-")))
          return !1;
      }
    return !0;
  }
  ensureBreakpointHintDecoration(e) {
    this.editor.changeDecorations((t) => {
      this.breakpointHintDecoration && (t.removeDecoration(this.breakpointHintDecoration), this.breakpointHintDecoration = null), e !== -1 && (this.breakpointHintDecoration = t.addDecoration({
        startLineNumber: e,
        startColumn: 1,
        endLineNumber: e,
        endColumn: 1
      }, Vl));
    });
  }
  async setDecorations() {
    if (!this.editor.hasModel())
      return;
    const e = (l, h) => {
      const p = $l(i, this.breakpointDecorations, h), f = l.deltaDecorations(this.candidateDecorations.map((b) => b.decorationId), p);
      this.candidateDecorations.forEach((b) => {
        b.inlineWidget.dispose();
      }), this.candidateDecorations = f.map((b, m) => {
        const S = p[m], N = S.breakpoint ? ht(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), S.breakpoint, this.labelService).icon : mt.disabled, P = () => this.getContextMenuActions(S.breakpoint ? [S.breakpoint] : [], t.getModel().uri, S.range.startLineNumber, S.range.startColumn), L = new ei(
          t,
          b,
          C.asClassName(N),
          S.breakpoint,
          this.debugService,
          this.contextMenuService,
          P
        );
        return {
          decorationId: b,
          inlineWidget: L
        };
      });
    }, t = this.editor, i = t.getModel(), n = this.debugService.getModel().getBreakpoints({ uri: i.uri }), s = this.configurationService.getValue("debug"), o = this.instantiationService.invokeFunction((l) => Wl(l, i, n, this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), s.showBreakpointsInOverviewRuler)), r = this.debugService.getViewModel().focusedSession, a = s.showInlineBreakpointCandidates && r ? Hl(this.editor.getModel(), o.map((l) => l.range.startLineNumber), r) : Promise.resolve([]), u = await Promise.race([a, Sr(500).then(() => {
    })]);
    u === void 0 && a.then((l) => t.changeDecorations((h) => e(h, l)));
    try {
      this.ignoreDecorationsChangedEvent = !0, t.changeDecorations((l) => {
        const h = l.deltaDecorations(this.breakpointDecorations.map((p) => p.decorationId), o);
        this.breakpointDecorations.forEach((p) => {
          var f;
          (f = p.inlineWidget) == null || f.dispose();
        }), this.breakpointDecorations = h.map((p, f) => {
          let b;
          const m = n[f];
          if (o[f].options.before) {
            const S = () => this.getContextMenuActions([m], t.getModel().uri, m.lineNumber, m.column);
            b = new ei(
              t,
              p,
              o[f].options.glyphMarginClassName,
              m,
              this.debugService,
              this.contextMenuService,
              S
            );
          }
          return {
            decorationId: p,
            breakpoint: m,
            range: o[f].range,
            inlineWidget: b
          };
        }), u && e(l, u);
      });
    } finally {
      this.ignoreDecorationsChangedEvent = !1;
    }
    for (const l of this.breakpointDecorations)
      l.inlineWidget && this.editor.layoutContentWidget(l.inlineWidget);
  }
  async onModelDecorationsChanged() {
    if (this.breakpointDecorations.length === 0 || this.ignoreDecorationsChangedEvent || !this.editor.hasModel())
      return;
    let e = !1;
    const t = this.editor.getModel();
    if (this.breakpointDecorations.forEach((n) => {
      if (e)
        return;
      const s = t.getDecorationRange(n.decorationId);
      s && !n.range.equalsRange(s) && (e = !0, n.range = s);
    }), !e)
      return;
    const i = /* @__PURE__ */ new Map();
    for (let n = 0, s = this.breakpointDecorations.length; n < s; n++) {
      const o = this.breakpointDecorations[n], r = t.getDecorationRange(o.decorationId);
      r && o.breakpoint && i.set(o.breakpoint.getId(), {
        lineNumber: r.startLineNumber,
        column: o.breakpoint.column ? r.startColumn : void 0
      });
    }
    try {
      this.ignoreBreakpointsChangeEvent = !0, await this.debugService.updateBreakpoints(t.uri, i, !0);
    } finally {
      this.ignoreBreakpointsChangeEvent = !1;
    }
  }
  showBreakpointWidget(e, t, i) {
    var n;
    (n = this.breakpointWidget) == null || n.dispose(), this.breakpointWidget = this.instantiationService.createInstance(vn, this.editor, e, t, i), this.breakpointWidget.show({ lineNumber: e, column: 1 }), this.breakpointWidgetVisible.set(!0);
  }
  closeBreakpointWidget() {
    this.breakpointWidget && (this.breakpointWidget.dispose(), this.breakpointWidget = void 0, this.breakpointWidgetVisible.reset(), this.editor.focus());
  }
  dispose() {
    var e;
    (e = this.breakpointWidget) == null || e.dispose(), this.editor.removeDecorations(this.breakpointDecorations.map((t) => t.decorationId)), z(this.toDispose);
  }
};
wn = E([
  g(1, w),
  g(2, At),
  g(3, re),
  g(4, W),
  g(5, Et),
  g(6, G),
  g(7, Ye)
], wn);
Yr.registerGutterActionsGenerator(({ lineNumber: d, editor: e, accessor: t }, i) => {
  const n = e.getModel(), s = t.get(w);
  if (!n || !s.getAdapterManager().hasEnabledDebuggers() || !s.canSetBreakpointsIn(n))
    return;
  const o = e.getContribution(ci);
  if (!o)
    return;
  const r = o.getContextMenuActionsAtPosition(d, n);
  for (const a of r)
    i.push(a, "2_debug");
});
class ei {
  constructor(e, t, i, n, s, o, r) {
    this.editor = e, this.decorationId = t, this.breakpoint = n, this.debugService = s, this.contextMenuService = o, this.getContextMenuActions = r, this.allowEditorOverflow = !1, this.suppressMouseDown = !0, this.toDispose = [], this.range = this.editor.getModel().getDecorationRange(t), this.toDispose.push(this.editor.onDidChangeModelDecorations(() => {
      const u = this.editor.getModel().getDecorationRange(this.decorationId);
      this.range && !this.range.equalsRange(u) && (this.range = u, this.editor.layoutContentWidget(this));
    })), this.create(i), this.editor.addContentWidget(this), this.editor.layoutContentWidget(this);
  }
  create(e) {
    this.domNode = Fl(".inline-breakpoint-widget"), e && this.domNode.classList.add(...e.split(" ")), this.toDispose.push(H(this.domNode, Z.CLICK, async (i) => {
      var n;
      switch ((n = this.breakpoint) == null ? void 0 : n.enabled) {
        case void 0:
          await this.debugService.addBreakpoints(this.editor.getModel().uri, [{ lineNumber: this.range.startLineNumber, column: this.range.startColumn }]);
          break;
        case !0:
          await this.debugService.removeBreakpoints(this.breakpoint.getId());
          break;
        case !1:
          this.debugService.enableOrDisableBreakpoints(!0, this.breakpoint);
          break;
      }
    })), this.toDispose.push(H(this.domNode, Z.CONTEXT_MENU, (i) => {
      const n = new Pi(i), s = { x: n.posx, y: n.posy }, o = this.getContextMenuActions();
      this.contextMenuService.showContextMenu({
        getAnchor: () => s,
        getActions: () => o,
        getActionsContext: () => this.breakpoint,
        onHide: () => cc(o)
      });
    }));
    const t = () => {
      const i = this.editor.getOption(64);
      this.domNode.style.height = `${i}px`, this.domNode.style.width = `${Math.ceil(0.8 * i)}px`, this.domNode.style.marginLeft = "4px";
    };
    t(), this.toDispose.push(this.editor.onDidChangeConfiguration((i) => {
      (i.hasChanged(50) || i.hasChanged(64)) && t();
    }));
  }
  getId() {
    return le();
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return this.range ? (this.domNode.classList.toggle("line-start", this.range.startColumn === 1), {
      position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn - 1 },
      preference: [0]
    }) : null;
  }
  dispose() {
    this.editor.removeContentWidget(this), z(this.toDispose);
  }
}
ei.__decorator = E([
  Ot
], ei.prototype, "getId", null);
mr((d, e) => {
  const t = d.getColor(na);
  t && e.addRule(`
		${Ci.map((r) => `.monaco-workbench ${C.asCSSSelector(r.regular)}`).join(`,
		`)},
		.monaco-workbench ${C.asCSSSelector(zr)},
		.monaco-workbench ${C.asCSSSelector(Kr)}:not([class*='codicon-debug-breakpoint']):not([class*='codicon-debug-stackframe']),
		.monaco-workbench ${C.asCSSSelector(mt.regular)}${C.asCSSSelector(Xi)}::after,
		.monaco-workbench ${C.asCSSSelector(mt.regular)}${C.asCSSSelector(ji)}::after {
			color: ${t} !important;
		}
		`);
  const i = d.getColor(ql);
  i && e.addRule(`
		${Ci.map((r) => `.monaco-workbench ${C.asCSSSelector(r.disabled)}`).join(`,
		`)} {
			color: ${i};
		}
		`);
  const n = d.getColor(Kl);
  n && e.addRule(`
		${Ci.map((r) => `.monaco-workbench ${C.asCSSSelector(r.unverified)}`).join(`,
		`)} {
			color: ${n};
		}
		`);
  const s = d.getColor(zl);
  s && e.addRule(`
		.monaco-workbench ${C.asCSSSelector(ji)},
		.monaco-editor .debug-top-stack-frame-column {
			color: ${s} !important;
		}
		`);
  const o = d.getColor(Gl);
  o && e.addRule(`
		.monaco-workbench ${C.asCSSSelector(Xi)} {
			color: ${o} !important;
		}
		`);
});
const na = B("debugIcon.breakpointForeground", { dark: "#E51400", light: "#E51400", hcDark: "#E51400", hcLight: "#E51400" }, c("debugIcon.breakpointForeground", "Icon color for breakpoints.")), ql = B("debugIcon.breakpointDisabledForeground", { dark: "#848484", light: "#848484", hcDark: "#848484", hcLight: "#848484" }, c(
  "debugIcon.breakpointDisabledForeground",
  "Icon color for disabled breakpoints."
)), Kl = B("debugIcon.breakpointUnverifiedForeground", { dark: "#848484", light: "#848484", hcDark: "#848484", hcLight: "#848484" }, c(
  "debugIcon.breakpointUnverifiedForeground",
  "Icon color for unverified breakpoints."
)), zl = B("debugIcon.breakpointCurrentStackframeForeground", { dark: "#FFCC00", light: "#BE8700", hcDark: "#FFCC00", hcLight: "#BE8700" }, c(
  "debugIcon.breakpointCurrentStackframeForeground",
  "Icon color for the current breakpoint stack frame."
)), Gl = B("debugIcon.breakpointStackframeForeground", { dark: "#89D185", light: "#89D185", hcDark: "#89D185", hcLight: "#89D185" }, c(
  "debugIcon.breakpointStackframeForeground",
  "Icon color for all breakpoint stack frames."
));
const jl = B("editor.stackFrameHighlightBackground", { dark: "#ffff0033", light: "#ffff6673", hcDark: "#ffff0033", hcLight: "#ffff6673" }, c(
  "topStackFrameLineHighlight",
  "Background color for the highlight of line at the top stack frame position."
)), Xl = B("editor.focusedStackFrameHighlightBackground", { dark: "#7abd7a4d", light: "#cee7ce73", hcDark: "#7abd7a4d", hcLight: "#cee7ce73" }, c(
  "focusedStackFrameLineHighlight",
  "Background color for the highlight of line at focused stack frame position."
)), fi = 1, Jl = {
  description: "top-stack-frame-margin",
  glyphMarginClassName: C.asClassName(ji),
  stickiness: fi,
  overviewRuler: {
    position: ns.Full,
    color: is(jl)
  }
}, Yl = {
  description: "focused-stack-frame-margin",
  glyphMarginClassName: C.asClassName(Xi),
  stickiness: fi,
  overviewRuler: {
    position: ns.Full,
    color: is(Xl)
  }
}, Ql = {
  description: "top-stack-frame-decoration",
  isWholeLine: !0,
  className: "debug-top-stack-frame-line",
  stickiness: fi
}, Zl = {
  description: "focused-stack-frame-decoration",
  isWholeLine: !0,
  className: "debug-focused-stack-frame-line",
  stickiness: fi
};
function eh(d, e, t) {
  const i = [], n = new K(
    d.range.startLineNumber,
    d.range.startColumn,
    d.range.startLineNumber,
    1073741824
  ), s = new K(
    d.range.startLineNumber,
    d.range.startColumn,
    d.range.startLineNumber,
    d.range.startColumn + 1
  ), o = d.thread.getTopStackFrame();
  return d.getId() === (o == null ? void 0 : o.getId()) ? (e && i.push({
    options: Jl,
    range: s
  }), i.push({
    options: Ql,
    range: n
  }), d.range.startColumn > 1 && i.push({
    options: {
      description: "top-stack-frame-inline-decoration",
      before: {
        content: "",
        inlineClassName: t ? "debug-top-stack-frame-column start-of-line" : "debug-top-stack-frame-column",
        inlineClassNameAffectsLetterSpacing: !0
      }
    },
    range: n
  })) : (e && i.push({
    options: Yl,
    range: s
  }), i.push({
    options: Zl,
    range: n
  })), i;
}
let kn = class extends ae {
  constructor(e, t, i, n) {
    super(), this.editor = e, this.debugService = t, this.uriIdentityService = i, this.logService = n, this.decorations = this.editor.createDecorationsCollection();
    const s = () => this.decorations.set(this.createCallStackDecorations());
    this._register(ne.any(this.debugService.getViewModel().onDidFocusStackFrame, this.debugService.getModel().onDidChangeCallStack)(() => {
      s();
    })), this._register(this.editor.onDidChangeModel((o) => {
      o.newModelUrl && s();
    })), s();
  }
  createCallStackDecorations() {
    const e = this.editor;
    if (!e.hasModel())
      return [];
    const t = this.debugService.getViewModel().focusedStackFrame, i = [];
    return this.debugService.getModel().getSessions().forEach((n) => {
      const s = n === (t == null ? void 0 : t.thread.session);
      n.getAllThreads().forEach((o) => {
        if (o.stopped) {
          const r = o.getCallStack(), a = [];
          r.length > 0 && (t && !t.equals(r[0]) && a.push(t), a.push(r[0])), a.forEach((u) => {
            var l, h;
            if (u && this.uriIdentityService.extUri.isEqual(u.source.uri, (l = e.getModel()) == null ? void 0 : l.uri)) {
              if (u.range.startLineNumber > ((h = e.getModel()) == null ? void 0 : h.getLineCount()) || u.range.startLineNumber < 1) {
                this.logService.warn(`CallStackEditorContribution: invalid stack frame line number: ${u.range.startLineNumber}`);
                return;
              }
              const p = e.getModel().getLineFirstNonWhitespaceColumn(u.range.startLineNumber) >= u.range.startColumn;
              i.push(...eh(u, s, p));
            }
          });
        }
      });
    }), Le(i, (n) => `${n.options.className} ${n.options.glyphMarginClassName} ${n.range.startLineNumber} ${n.range.startColumn}`);
  }
  dispose() {
    super.dispose(), this.decorations.clear();
  }
};
kn = E([
  g(1, w),
  g(2, Je),
  g(3, It)
], kn);
const th = B("debugToolBar.background", {
  dark: "#333333",
  light: "#F3F3F3",
  hcDark: "#000000",
  hcLight: "#FFFFFF"
}, c("debugToolBarBackground", "Debug toolbar background color.")), ih = B("debugToolBar.border", {
  dark: null,
  light: null,
  hcDark: null,
  hcLight: null
}, c("debugToolBarBorder", "Debug toolbar border color.")), nh = B("debugIcon.startForeground", {
  dark: "#89D185",
  light: "#388A34",
  hcDark: "#89D185",
  hcLight: "#388A34"
}, c("debugIcon.startForeground", "Debug toolbar icon for start debugging."));
function sh() {
  const d = B("debugTokenExpression.name", { dark: "#c586c0", light: "#9b46b0", hcDark: U, hcLight: U }, "Foreground color for the token names shown in the debug views (ie. the Variables or Watch view)."), e = B("debugTokenExpression.value", { dark: "#cccccc99", light: "#6c6c6ccc", hcDark: U, hcLight: U }, "Foreground color for the token values shown in the debug views (ie. the Variables or Watch view)."), t = B("debugTokenExpression.string", { dark: "#ce9178", light: "#a31515", hcDark: "#f48771", hcLight: "#a31515" }, "Foreground color for strings in the debug views (ie. the Variables or Watch view)."), i = B("debugTokenExpression.boolean", { dark: "#4e94ce", light: "#0000ff", hcDark: "#75bdfe", hcLight: "#0000ff" }, "Foreground color for booleans in the debug views (ie. the Variables or Watch view)."), n = B("debugTokenExpression.number", { dark: "#b5cea8", light: "#098658", hcDark: "#89d185", hcLight: "#098658" }, "Foreground color for numbers in the debug views (ie. the Variables or Watch view)."), s = B("debugTokenExpression.error", { dark: "#f48771", light: "#e51400", hcDark: "#f48771", hcLight: "#e51400" }, "Foreground color for expression errors in the debug views (ie. the Variables or Watch view) and for error logs shown in the debug console."), o = B("debugView.exceptionLabelForeground", { dark: U, light: "#FFF", hcDark: U, hcLight: U }, "Foreground color for a label shown in the CALL STACK view when the debugger breaks on an exception."), r = B("debugView.exceptionLabelBackground", { dark: "#6C2022", light: "#A31515", hcDark: "#6C2022", hcLight: "#A31515" }, "Background color for a label shown in the CALL STACK view when the debugger breaks on an exception."), a = B("debugView.stateLabelForeground", { dark: U, light: U, hcDark: U, hcLight: U }, "Foreground color for a label in the CALL STACK view showing the current session's or thread's state."), u = B("debugView.stateLabelBackground", { dark: "#88888844", light: "#88888844", hcDark: "#88888844", hcLight: "#88888844" }, "Background color for a label in the CALL STACK view showing the current session's or thread's state."), l = B("debugView.valueChangedHighlight", { dark: "#569CD6", light: "#569CD6", hcDark: "#569CD6", hcLight: "#569CD6" }, "Color used to highlight value changes in the debug views (ie. in the Variables view)."), h = B("debugConsole.infoForeground", { dark: zs, light: zs, hcDark: U, hcLight: U }, "Foreground color for info messages in debug REPL console."), p = B("debugConsole.warningForeground", { dark: Si, light: Si, hcDark: "#008000", hcLight: Si }, "Foreground color for warning messages in debug REPL console."), f = B("debugConsole.errorForeground", { dark: Ht, light: Ht, hcDark: Ht, hcLight: Ht }, "Foreground color for error messages in debug REPL console."), b = B("debugConsole.sourceForeground", { dark: U, light: U, hcDark: U, hcLight: U }, "Foreground color for source filenames in debug REPL console."), m = B("debugConsoleInputIcon.foreground", { dark: U, light: U, hcDark: U, hcLight: U }, "Foreground color for debug console input marker icon."), S = B("debugIcon.pauseForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.pauseForeground", "Debug toolbar icon for pause.")), N = B("debugIcon.stopForeground", {
    dark: "#F48771",
    light: "#A1260D",
    hcDark: "#F48771",
    hcLight: "#A1260D"
  }, c("debugIcon.stopForeground", "Debug toolbar icon for stop.")), P = B("debugIcon.disconnectForeground", {
    dark: "#F48771",
    light: "#A1260D",
    hcDark: "#F48771",
    hcLight: "#A1260D"
  }, c("debugIcon.disconnectForeground", "Debug toolbar icon for disconnect.")), L = B("debugIcon.restartForeground", {
    dark: "#89D185",
    light: "#388A34",
    hcDark: "#89D185",
    hcLight: "#388A34"
  }, c("debugIcon.restartForeground", "Debug toolbar icon for restart.")), V = B("debugIcon.stepOverForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepOverForeground", "Debug toolbar icon for step over.")), _ = B("debugIcon.stepIntoForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepIntoForeground", "Debug toolbar icon for step into.")), T = B("debugIcon.stepOutForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepOutForeground", "Debug toolbar icon for step over.")), ie = B("debugIcon.continueForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.continueForeground", "Debug toolbar icon for continue.")), ke = B("debugIcon.stepBackForeground", {
    dark: "#75BEFF",
    light: "#007ACC",
    hcDark: "#75BEFF",
    hcLight: "#007ACC"
  }, c("debugIcon.stepBackForeground", "Debug toolbar icon for step back."));
  mr((D, j) => {
    const gt = D.getColor(lc), bi = D.getColor(hc), da = D.getColor(gc), Ds = D.getColor(o), Es = D.getColor(r), ca = D.getColor(a), ua = D.getColor(u), Vt = D.getColor(l), la = D.getColor(pc);
    j.addRule(`
			/* Text colour of the call stack row's filename */
			.debug-pane .debug-call-stack .monaco-list-row:not(.selected) .stack-frame > .file .file-name {
				color: ${da}
			}

			/* Line & column number "badge" for selected call stack row */
			.debug-pane .monaco-list-row.selected .line-number {
				background-color: ${gt};
				color: ${bi};
			}

			/* Line & column number "badge" for unselected call stack row (basically all other rows) */
			.debug-pane .line-number {
				background-color: ${gt.transparent(0.6)};
				color: ${bi.transparent(0.6)};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running.
			*/
			.debug-pane .debug-call-stack .thread > .state.label,
			.debug-pane .debug-call-stack .session > .state.label {
				background-color: ${ua};
				color: ${ca};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running
			* and thread paused due to a thrown exception.
			*/
			.debug-pane .debug-call-stack .thread > .state.label.exception,
			.debug-pane .debug-call-stack .session > .state.label.exception {
				background-color: ${Es};
				color: ${Ds};
			}

			/* Info "badge" shown when the debugger pauses due to a thrown exception. */
			.debug-pane .call-stack-state-message > .label.exception {
				background-color: ${Es};
				color: ${Ds};
			}

			/* Animation of changed values in Debug viewlet */
			@keyframes debugViewletValueChanged {
				0%   { background-color: ${Vt.transparent(0)} }
				5%   { background-color: ${Vt.transparent(0.9)} }
				100% { background-color: ${Vt.transparent(0.3)} }
			}

			.debug-pane .monaco-list-row .expression .value.changed {
				background-color: ${Vt.transparent(0.3)};
				animation-name: debugViewletValueChanged;
				animation-duration: 1s;
				animation-fill-mode: forwards;
			}

			.monaco-list-row .expression .lazy-button:hover {
				background-color: ${la}
			}
		`);
    const Is = D.getColor(fc);
    Is && j.addRule(`
			.debug-pane .line-number {
				border: 1px solid ${Is};
			}
			`), bc(D.type) && j.addRule(`
			.debug-pane .line-number {
				background-color: ${gt};
				color: ${bi};
			}`);
    const ha = D.getColor(d), ga = D.getColor(e), pa = D.getColor(t), fa = D.getColor(i), ba = D.getColor(s), ma = D.getColor(n);
    j.addRule(`
			.monaco-workbench .monaco-list-row .expression .name {
				color: ${ha};
			}

			.monaco-workbench .monaco-list-row .expression .value,
			.monaco-workbench .debug-hover-widget .value {
				color: ${ga};
			}

			.monaco-workbench .monaco-list-row .expression .value.string,
			.monaco-workbench .debug-hover-widget .value.string {
				color: ${pa};
			}

			.monaco-workbench .monaco-list-row .expression .value.boolean,
			.monaco-workbench .debug-hover-widget .value.boolean {
				color: ${fa};
			}

			.monaco-workbench .monaco-list-row .expression .error,
			.monaco-workbench .debug-hover-widget .error,
			.monaco-workbench .debug-pane .debug-variables .scope .error {
				color: ${ba};
			}

			.monaco-workbench .monaco-list-row .expression .value.number,
			.monaco-workbench .debug-hover-widget .value.number {
				color: ${ma};
			}
		`);
    const Sa = D.getColor(mc) || nr.fromHex("#80808060"), va = D.getColor(h), wa = D.getColor(p), ka = D.getColor(f), Ca = D.getColor(b), ya = D.getColor(m);
    j.addRule(`
			.repl .repl-input-wrapper {
				border-top: 1px solid ${Sa};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.info {
				color: ${va};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.warn {
				color: ${wa};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.error {
				color: ${ka};
			}

			.monaco-workbench .repl .repl-tree .output .expression .source {
				color: ${Ca};
			}

			.monaco-workbench .repl .repl-tree .monaco-tl-contents .arrow {
				color: ${ya};
			}
		`), D.defines(m) || j.addRule(`
				.monaco-workbench.vs .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.25;
				}

				.monaco-workbench.vs-dark .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.4;
				}

				.monaco-workbench.hc-black .repl .repl-tree .monaco-tl-contents .arrow,
				.monaco-workbench.hc-light .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 1;
				}
			`);
    const _s = D.getColor(nh);
    _s && j.addRule(`.monaco-workbench ${C.asCSSSelector(Gr)} { color: ${_s}; }`);
    const xs = D.getColor(S);
    xs && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Zi)}, .monaco-workbench ${C.asCSSSelector(Zi)} { color: ${xs}; }`);
    const Bs = D.getColor(N);
    Bs && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(St)},.monaco-workbench ${C.asCSSSelector(St)} { color: ${Bs}; }`);
    const Ts = D.getColor(P);
    Ts && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(ze)},.monaco-workbench .debug-view-content ${C.asCSSSelector(ze)}, .monaco-workbench .debug-toolbar ${C.asCSSSelector(ze)} { color: ${Ts}; }`);
    const As = D.getColor(L);
    As && j.addRule(`.monaco-workbench ${C.asCSSSelector(Ji)}, .monaco-workbench ${C.asCSSSelector(lo)}, .monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Ji)}, .monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(lo)} { color: ${As}; }`);
    const Ls = D.getColor(V);
    Ls && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Yi)}, .monaco-workbench ${C.asCSSSelector(Yi)} { color: ${Ls}; }`);
    const Ms = D.getColor(_);
    Ms && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Kt)}, .monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Kt)}, .monaco-workbench ${C.asCSSSelector(Kt)} { color: ${Ms}; }`);
    const Ns = D.getColor(T);
    Ns && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(zt)}, .monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(zt)}, .monaco-workbench ${C.asCSSSelector(zt)} { color: ${Ns}; }`);
    const Rs = D.getColor(ie);
    Rs && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(en)}, .monaco-workbench ${C.asCSSSelector(en)}, .monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(tn)}, .monaco-workbench ${C.asCSSSelector(tn)} { color: ${Rs}; }`);
    const Os = D.getColor(ke);
    Os && j.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${C.asCSSSelector(Qi)}, .monaco-workbench ${C.asCSSSelector(Qi)} { color: ${Os}; }`);
  });
}
let Cn = class extends wr {
  constructor(e, t, i) {
    super(bs, { canAcceptInBackground: !0 }), this._debugService = e, this._viewsService = t, this._commandService = i;
  }
  _getPicks(e, t, i) {
    const n = [];
    this._debugService.getModel().getSessions(!0).filter((o) => o.hasSeparateRepl()).forEach((o, r) => {
      const a = this._createPick(o, r, e);
      a && n.push(a);
    }), n.length > 0 && n.push({ type: "separator" });
    const s = c("workbench.action.debug.startDebug", "Start a New Debug Session");
    return n.push({
      label: `$(plus) ${s}`,
      ariaLabel: s,
      accept: () => this._commandService.executeCommand(li)
    }), n;
  }
  _createPick(e, t, i) {
    const n = e.name, s = qe(i, n, !0);
    if (s)
      return {
        label: n,
        highlights: { label: s },
        accept: (o, r) => {
          this._debugService.focusStackFrame(void 0, void 0, e, { explicit: !0 }), this._viewsService.isViewVisible(Fe) || this._viewsService.openView(Fe, !0);
        }
      };
  }
};
Cn = E([
  g(0, w),
  g(1, st),
  g(2, _e)
], Cn);
const oh = 1024, rh = /^(true|false)$/i, ah = /^(['"]).*\1$/, Ze = O;
function sa(d, e, t) {
  let i = typeof d == "string" ? d : d.value;
  if (e.className = "value", i === null || (d instanceof $ || d instanceof be || d instanceof Jr) && !d.available ? (e.classList.add("unavailable"), i !== $.DEFAULT_VALUE && e.classList.add("error")) : (d instanceof Y && t.showChanged && d.valueChanged && i !== $.DEFAULT_VALUE && (e.className = "value changed", d.valueChanged = !1), t.colorize && typeof d != "string" && (d.type === "number" || d.type === "boolean" || d.type === "string" ? e.classList.add(d.type) : isNaN(+i) ? rh.test(i) ? e.classList.add("boolean") : ah.test(i) && e.classList.add("string") : e.classList.add("number"))), t.maxValueLength && i && i.length > t.maxValueLength && (i = i.substring(0, t.maxValueLength) + "..."), i || (i = ""), t.linkDetector) {
    e.textContent = "";
    const n = d instanceof Y ? d.getSession() : void 0;
    e.appendChild(t.linkDetector.linkify(i, !1, n ? n.root : void 0, !0));
  } else
    e.textContent = i;
  t.showHover && (e.title = i || "");
}
function dh(d, e, t, i, n) {
  var s, o, r;
  if (d.available) {
    let a = d.name;
    d.value && typeof d.name == "string" && (a += ":"), e.label.set(a, i, d.type ? d.type : d.name), e.name.classList.toggle("virtual", ((s = d.presentationHint) == null ? void 0 : s.kind) === "virtual"), e.name.classList.toggle("internal", ((o = d.presentationHint) == null ? void 0 : o.visibility) === "internal");
  } else
    d.value && typeof d.name == "string" && d.name && e.label.set(":");
  e.expression.classList.toggle("lazy", !!((r = d.presentationHint) != null && r.lazy)), sa(d, e.value, {
    showChanged: t,
    maxValueLength: oh,
    showHover: !0,
    colorize: !0,
    linkDetector: n
  });
}
let yn = class {
  constructor(e, t) {
    this.debugService = e, this.contextViewService = t;
  }
  renderTemplate(e) {
    const t = k(e, Ze(".expression")), i = k(t, Ze("span.name")), n = k(t, Ze("span.lazy-button"));
    n.classList.add(...C.asClassNameArray(I.eye)), n.title = c("debug.lazyButton.tooltip", "Click to expand");
    const s = k(t, Ze("span.value")), o = new Sc(i), r = k(t, Ze(".inputBoxContainer")), a = new oe();
    let u;
    this.renderActionBar && (k(t, Ze(".span.actionbar-spacer")), u = a.add(new ut(t)));
    const l = { expression: t, name: i, value: s, label: o, inputBoxContainer: r, actionBar: u, elementDisposable: [], templateDisposable: a, lazyButton: n, currentElement: void 0 };
    return a.add(H(n, Z.CLICK, () => {
      l.currentElement && this.debugService.getViewModel().evaluateLazyExpression(l.currentElement);
    })), l;
  }
  renderExpressionElement(e, t, i) {
    i.currentElement = e, this.renderExpression(t.element, i, vc(t.filterData)), i.actionBar && this.renderActionBar(i.actionBar, e, i);
    const n = this.debugService.getViewModel().getSelectedExpression();
    if (e === (n == null ? void 0 : n.expression) || e instanceof be && e.errorMessage) {
      const s = this.getInputBoxOptions(e, !!(n != null && n.settingWatch));
      s && i.elementDisposable.push(this.renderInputBox(i.name, i.value, i.inputBoxContainer, s));
    }
  }
  renderInputBox(e, t, i, n) {
    e.style.display = "none", t.style.display = "none", i.style.display = "initial", wc(i);
    const s = new kc(
      i,
      this.contextViewService,
      { ...n, inputBoxStyles: Cc }
    );
    s.value = n.initialValue, s.focus(), s.select();
    const o = yc((a, u) => {
      e.style.display = "", t.style.display = "", i.style.display = "none";
      const l = s.value;
      z(r), u && (this.debugService.getViewModel().setSelectedExpression(void 0, !1), n.onFinish(l, a));
    }), r = [
      s,
      ct(s.inputElement, Z.KEY_DOWN, (a) => {
        const u = a.equals(9), l = a.equals(3);
        (u || l) && (a.preventDefault(), a.stopPropagation(), o(l, !0));
      }),
      H(s.inputElement, Z.BLUR, () => {
        o(!0, !0);
      }),
      H(s.inputElement, Z.CLICK, (a) => {
        a.preventDefault(), a.stopPropagation();
      })
    ];
    return $o(() => {
      o(!1, !1);
    });
  }
  disposeElement(e, t, i) {
    z(i.elementDisposable), i.elementDisposable = [];
  }
  disposeTemplate(e) {
    z(e.elementDisposable), e.templateDisposable.dispose();
  }
};
yn = E([
  g(0, w),
  g(1, Rt)
], yn);
const Co = "\\u0000-\\u0020\\u007f-\\u009f", ch = new RegExp(
  "(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s" + Co + '"]{2,}[^\\s' + Co + `"')}\\],:;.!?]`,
  "ug"
), uh = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/, lh = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/, hh = new RegExp(`(${uh.source}|${lh.source})`), gh = /((?:\~|\.)?(?:\/[\w\.-]*)+)/, ph = /(?:\:([\d]+))?(?:\:([\d]+))?/, fh = new RegExp(
  `${qn ? hh.source : gh.source}${ph.source}`,
  "g"
), bh = /:([\d]+)(?::([\d]+))?$/, mh = 2e3;
let ti = class {
  constructor(e, t, i, n, s, o, r) {
    this.editorService = e, this.fileService = t, this.openerService = i, this.pathService = n, this.tunnelService = s, this.environmentService = o, this.configurationService = r;
  }
  linkify(e, t, i, n) {
    if (t) {
      const o = e.split(`
`);
      for (let u = 0; u < o.length - 1; u++)
        o[u] = o[u] + `
`;
      o[o.length - 1] || o.pop();
      const r = o.map((u) => this.linkify(u, !1, i, n));
      if (r.length === 1)
        return r[0];
      const a = document.createElement("span");
      return r.forEach((u) => a.appendChild(u)), a;
    }
    const s = document.createElement("span");
    for (const o of this.detectLinks(e))
      try {
        switch (o.kind) {
          case "text":
            s.appendChild(document.createTextNode(o.value));
            break;
          case "web":
            s.appendChild(this.createWebLink(n ? e : void 0, o.value));
            break;
          case "path": {
            const r = o.captures[0], a = o.captures[1] ? Number(o.captures[1]) : 0, u = o.captures[2] ? Number(o.captures[2]) : 0;
            s.appendChild(this.createPathLink(n ? e : void 0, o.value, r, a, u, i));
            break;
          }
        }
      } catch {
        s.appendChild(document.createTextNode(o.value));
      }
    return s;
  }
  createWebLink(e, t) {
    const i = this.createLink(t);
    let n = ee.parse(t);
    const s = bh.exec(n.path);
    return s && (n = n.with({
      path: n.path.slice(0, s.index),
      fragment: `L${s[0].slice(1)}`
    })), this.decorateLink(i, n, e, async () => {
      if (n.scheme === Pe.file) {
        const o = n.fsPath, r = await this.pathService.path, a = Mi(r.sep === Gs.sep && qn ? o.replace(/\\/g, Gs.sep) : o), u = ee.parse(a);
        if (!await this.fileService.exists(u))
          return;
        await this.editorService.openEditor({
          resource: u,
          options: {
            pinned: !0,
            selection: s ? { startLineNumber: +s[1], startColumn: +s[2] } : void 0
          }
        });
        return;
      }
      this.openerService.open(t, { allowTunneling: !!this.environmentService.remoteAuthority && this.configurationService.getValue("remote.forwardOnOpen") });
    }), i;
  }
  createPathLink(e, t, i, n, s, o) {
    if (i[0] === "/" && i[1] === "/")
      return document.createTextNode(t);
    const r = { selection: { startLineNumber: n, startColumn: s } };
    if (i[0] === ".") {
      if (!o)
        return document.createTextNode(t);
      const l = o.toResource(i), h = this.createLink(t);
      return this.decorateLink(h, l, e, (p) => this.editorService.openEditor({ resource: l, options: { ...r, preserveFocus: p } })), h;
    }
    if (i[0] === "~") {
      const l = this.pathService.resolvedUserHome;
      l && (i = Ec(l.fsPath, i.substring(1)));
    }
    const a = this.createLink(t);
    a.tabIndex = 0;
    const u = ee.file(Mi(i));
    return this.fileService.stat(u).then((l) => {
      l.isDirectory || this.decorateLink(a, u, e, (h) => this.editorService.openEditor({ resource: u, options: { ...r, preserveFocus: h } }));
    }).catch(() => {
    }), a;
  }
  createLink(e) {
    const t = document.createElement("a");
    return t.textContent = e, t;
  }
  decorateLink(e, t, i, n) {
    e.classList.add("link");
    const s = this.tunnelService.canTunnel(t) ? c("followForwardedLink", "follow link using forwarded port") : c("followLink", "follow link");
    e.title = i ? Ce ? c("fileLinkWithPathMac", `Cmd + click to {0}
{1}`, s, i) : c("fileLinkWithPath", `Ctrl + click to {0}
{1}`, s, i) : Ce ? c("fileLinkMac", "Cmd + click to {0}", s) : c("fileLink", "Ctrl + click to {0}", s), e.onmousemove = (o) => {
      e.classList.toggle("pointer", Ce ? o.metaKey : o.ctrlKey);
    }, e.onmouseleave = () => e.classList.remove("pointer"), e.onclick = (o) => {
      const r = window.getSelection();
      !r || r.type === "Range" || (Ce ? o.metaKey : o.ctrlKey) && (o.preventDefault(), o.stopImmediatePropagation(), n(!1));
    }, e.onkeydown = (o) => {
      const r = new We(o);
      (r.keyCode === 3 || r.keyCode === 10) && (r.preventDefault(), r.stopPropagation(), n(r.keyCode === 10));
    };
  }
  detectLinks(e) {
    if (e.length > mh)
      return [{ kind: "text", value: e, captures: [] }];
    const t = [ch, fh], i = ["web", "path"], n = [], s = (o, r) => {
      if (r >= t.length) {
        n.push({ value: o, kind: "text", captures: [] });
        return;
      }
      const a = t[r];
      let u = 0, l;
      for (a.lastIndex = 0; (l = a.exec(o)) !== null; ) {
        const p = o.substring(u, l.index);
        p && s(p, r + 1);
        const f = l[0];
        n.push({
          value: f,
          kind: i[r],
          captures: l.slice(1)
        }), u = l.index + f.length;
      }
      const h = o.substring(u);
      h && s(h, r + 1);
    };
    return s(e, 0), n;
  }
};
ti = E([
  g(0, se),
  g(1, Kn),
  g(2, zn),
  g(3, tr),
  g(4, Dc),
  g(5, Pn),
  g(6, G)
], ti);
let ii;
const Sh = (d) => {
  var e;
  return {
    sessionId: (e = d.getSession()) == null ? void 0 : e.getId(),
    container: d.parent instanceof $ ? { expression: d.parent.name } : d.parent.toDebugProtocolObject(),
    variable: d.toDebugProtocolObject()
  };
};
function vh(d, e, t = []) {
  var s, o, r;
  const i = e.getSession(), n = [
    [xc.key, e.variableMenuContext || ""],
    [Bc.key, !!e.evaluateName],
    [Tc.key, !!(i != null && i.capabilities.supportsReadMemoryRequest) && e.memoryReference !== void 0],
    [Ac.key, !!((o = (s = e.presentationHint) == null ? void 0 : s.attributes) != null && o.includes("readOnly")) || ((r = e.presentationHint) == null ? void 0 : r.lazy)],
    ...t
  ];
  return ii = e, d.createOverlay(n);
}
let Ct = class oa extends yn {
  constructor(e, t, i, n, s) {
    super(n, s), this.linkDetector = e, this.menuService = t, this.contextKeyService = i;
  }
  get templateId() {
    return oa.ID;
  }
  renderExpression(e, t, i) {
    dh(e, t, !0, i, this.linkDetector);
  }
  renderElement(e, t, i) {
    super.renderExpressionElement(e.element, e, i);
  }
  getInputBoxOptions(e) {
    const t = e;
    return {
      initialValue: e.value,
      ariaLabel: c("variableValueAriaLabel", "Type new variable value"),
      validationOptions: {
        validation: () => t.errorMessage ? { content: t.errorMessage } : null
      },
      onFinish: (i, n) => {
        t.errorMessage = void 0;
        const s = this.debugService.getViewModel().focusedStackFrame;
        n && t.value !== i && s && t.setVariable(i, s).then(() => {
          this.debugService.getViewModel().updateViews();
        });
      }
    };
  }
  renderActionBar(e, t) {
    const i = t, n = vh(this.contextKeyService, i), s = this.menuService.createMenu(y.DebugVariablesContext, n), o = [], r = Sh(i);
    _c(s, { arg: r, shouldForwardArgs: !1 }, { primary: o, secondary: [] }, "inline"), e.clear(), e.context = r, e.push(o, { icon: !0, label: !1 });
  }
};
Ct.ID = "variable";
Ct = E([
  g(1, Lt),
  g(2, W),
  g(3, w),
  g(4, Rt)
], Ct);
const wh = "debug.setVariable";
R.registerCommand({
  id: wh,
  handler: (d) => {
    d.get(w).getViewModel().setSelectedExpression(ii, !1);
  }
});
const kh = "workbench.debug.viewlet.action.copyValue";
R.registerCommand({
  id: kh,
  handler: async (d, e, t) => {
    const i = d.get(w), n = d.get(oi);
    let s = "", o;
    e instanceof be || e instanceof $ ? (s = "watch", o = t || []) : (s = "variables", o = ii ? [ii] : []);
    const r = i.getViewModel().focusedStackFrame, a = i.getViewModel().focusedSession;
    if (!r || !a || o.length === 0)
      return;
    const u = a.capabilities.supportsClipboardContext ? "clipboard" : s, l = o.map(
      (h) => h instanceof be ? h.evaluateName || h.value : h.name
    );
    try {
      const h = await Promise.all(l.map((f) => a.evaluate(f, r.frameId, u))), p = ss(h).map((f) => f.body.result);
      p.length && n.writeText(p.join(`
`));
    } catch {
      const p = o.map((f) => f.value);
      n.writeText(p.join(`
`));
    }
  }
});
const Ch = "workbench.debug.viewlet.action.viewMemory", Dn = "ms-vscode.hexeditor", yh = "hexEditor.hexedit";
R.registerCommand({
  id: Ch,
  handler: async (d, e, t) => {
    var f;
    const i = d.get(w);
    let n, s;
    if ("sessionId" in e) {
      if (!e.sessionId || !e.variable.memoryReference)
        return;
      n = e.sessionId, s = e.variable.memoryReference;
    } else {
      if (!e.memoryReference)
        return;
      const b = i.getViewModel().focusedSession;
      if (!b)
        return;
      n = b.getId(), s = e.memoryReference;
    }
    const o = d.get(_e), r = d.get(se), a = d.get(Re), u = d.get(Ic), l = d.get(Dt), h = d.get(Bt);
    (await l.getExtension(Dn) || await Dh(a, u, l, o)) && (h.publicLog("debug/didViewMemory", {
      debugType: (f = i.getModel().getSession(n)) == null ? void 0 : f.configuration.type
    }), await r.openEditor({
      resource: Eu(n, s),
      options: {
        revealIfOpened: !0,
        override: yh
      }
    }, Wn));
  }
});
function Dh(d, e, t, i) {
  return new Promise((n) => {
    let s = !1;
    d.prompt(Ko.Info, c(
      "viewMemory.prompt",
      "Inspecting binary data requires the Hex Editor extension. Would you like to install it now?"
    ), [
      {
        label: c("cancel", "Cancel"),
        run: () => n(!1)
      },
      {
        label: c("install", "Install"),
        run: async () => {
          s = !0;
          try {
            await e.withProgress({
              location: 15,
              title: c("viewMemory.install.progress", "Installing the Hex Editor...")
            }, async () => {
              for (await i.executeCommand("workbench.extensions.installExtension", Dn); !await t.getExtension(Dn); )
                await Sr(30);
            }), n(!0);
          } catch (r) {
            d.error(r), n(!1);
          }
        }
      }
    ], { sticky: !0 }).onDidClose((r) => {
      s || n(!1);
    });
  });
}
const Eh = "debug.breakWhenValueChanges";
R.registerCommand({
  id: Eh,
  handler: async (d) => {
    d.get(w);
  }
});
const Ih = "debug.breakWhenValueIsAccessed";
R.registerCommand({
  id: Ih,
  handler: async (d) => {
    d.get(w);
  }
});
const _h = "debug.breakWhenValueIsRead";
R.registerCommand({
  id: _h,
  handler: async (d) => {
    d.get(w);
  }
});
const xh = "debug.copyEvaluatePath";
R.registerCommand({
  id: xh,
  handler: async (d, e) => {
    await d.get(oi).writeText(e.variable.evaluateName);
  }
});
const Bh = "debug.addToWatchExpressions";
R.registerCommand({
  id: Bh,
  handler: async (d, e) => {
    d.get(w).addWatchExpression(e.variable.evaluateName);
  }
});
ve(class extends gi {
  constructor() {
    super({
      id: "variables.collapse",
      viewId: js,
      title: c("collapse", "Collapse All"),
      f1: !1,
      icon: I.collapseAll,
      menu: {
        id: y.ViewTitle,
        group: "navigation",
        when: A.equals("view", js)
      }
    });
  }
  runInView(d, e) {
    e.collapseAll();
  }
});
const et = O;
async function ra(d, e) {
  if (!d)
    return null;
  const i = (await d.getChildren()).filter((n) => e[0] === n.name);
  return i.length !== 1 ? null : e.length === 1 ? i[0] : ra(i[0], e.slice(1));
}
async function Th(d, e) {
  const i = (await d.getScopes()).filter((s) => !s.expensive), n = ss(await Promise.all(i.map((s) => ra(s, e))));
  return n.length > 0 && n.every((s) => s.value === n[0].value) ? n[0] : void 0;
}
let Ge = class En {
  constructor(e, t, i) {
    this.editor = e, this.debugService = t, this.instantiationService = i, this.allowEditorOverflow = !0, this.highlightDecorations = this.editor.createDecorationsCollection(), this.toDispose = [], this._isVisible = !1, this.showAtPosition = null, this.positionPreference = [1, 2], this.debugHoverComputer = this.instantiationService.createInstance(In, this.editor);
  }
  create() {
    this.domNode = et(".debug-hover-widget"), this.complexValueContainer = k(this.domNode, et(".complex-value")), this.complexValueTitle = k(this.complexValueContainer, et(".title")), this.treeContainer = k(this.complexValueContainer, et(".debug-hover-tree")), this.treeContainer.setAttribute("role", "tree");
    const e = k(this.complexValueContainer, et(".tip"));
    e.textContent = c(
      { key: "quickTip", comment: ['"switch to editor language hover" means to show the programming language hover widget instead of the debug hover'] },
      "Hold {0} key to switch to editor language hover",
      Ce ? "Option" : "Alt"
    );
    const t = new Lh(), i = this.instantiationService.createInstance(ti);
    this.tree = this.instantiationService.createInstance(Mc, "DebugHover", this.treeContainer, new Mh(), [this.instantiationService.createInstance(Ct, i)], t, {
      accessibilityProvider: new Ah(),
      mouseSupport: !1,
      horizontalScrolling: !0,
      useShadows: !1,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (n) => n.name },
      overrideStyles: {
        listBackground: Xs
      }
    }), this.valueContainer = et(".value"), this.valueContainer.tabIndex = 0, this.valueContainer.setAttribute("role", "tooltip"), this.scrollbar = new cr(this.valueContainer, { horizontal: 2 }), this.domNode.appendChild(this.scrollbar.getDomNode()), this.toDispose.push(this.scrollbar), this.editor.applyFontInfo(this.domNode), this.domNode.style.backgroundColor = Ke(Xs), this.domNode.style.border = `1px solid ${Ke(Nc)}`, this.domNode.style.color = Ke(Rc), this.toDispose.push(this.tree.onDidChangeContentHeight(() => this.layoutTreeAndContainer(!1))), this.registerListeners(), this.editor.addContentWidget(this);
  }
  registerListeners() {
    this.toDispose.push(ct(this.domNode, "keydown", (e) => {
      e.equals(9) && this.hide();
    })), this.toDispose.push(this.editor.onDidChangeConfiguration((e) => {
      e.hasChanged(48) && this.editor.applyFontInfo(this.domNode);
    })), this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (e) => {
      e instanceof be && this.tree.hasNode(e) && (await this.tree.updateChildren(e, !1, !0), await this.tree.expand(e));
    }));
  }
  isHovered() {
    var e;
    return !!((e = this.domNode) != null && e.matches(":hover"));
  }
  isVisible() {
    return this._isVisible;
  }
  willBeVisible() {
    return !!this.showCancellationSource;
  }
  getId() {
    return En.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  async showAt(e, t) {
    var r;
    (r = this.showCancellationSource) == null || r.cancel();
    const i = this.showCancellationSource = new Me(), n = this.debugService.getViewModel().focusedSession;
    if (!n || !this.editor.hasModel()) {
      this.hide();
      return;
    }
    const s = await this.debugHoverComputer.compute(e, i.token);
    if (this.isVisible() && !s.rangeChanged)
      return;
    if (!s.range || i.token.isCancellationRequested) {
      this.hide();
      return;
    }
    const o = await this.debugHoverComputer.evaluate(n);
    if (i.token.isCancellationRequested || !o || o instanceof $ && !o.available) {
      this.hide();
      return;
    }
    return this.highlightDecorations.set([{
      range: s.range,
      options: En._HOVER_HIGHLIGHT_DECORATION_OPTIONS
    }]), this.doShow(s.range.getStartPosition(), o, t);
  }
  async doShow(e, t, i, n = !1) {
    if (this.domNode || this.create(), this.showAtPosition = e, this._isVisible = !0, !t.hasChildren || n) {
      this.complexValueContainer.hidden = !0, this.valueContainer.hidden = !1, sa(t, this.valueContainer, {
        showChanged: !1,
        colorize: !0
      }), this.valueContainer.title = "", this.editor.layoutContentWidget(this), this.scrollbar.scanDomNode(), i && (this.editor.render(), this.valueContainer.focus());
      return;
    }
    this.valueContainer.hidden = !0, await this.tree.setInput(t), this.complexValueTitle.textContent = t.value, this.complexValueTitle.title = t.value, this.layoutTreeAndContainer(!0), this.tree.scrollTop = 0, this.tree.scrollLeft = 0, this.complexValueContainer.hidden = !1, i && (this.editor.render(), this.tree.domFocus());
  }
  layoutTreeAndContainer(e) {
    const i = Math.min(Math.max(266, this.editor.getLayoutInfo().height * 0.55), this.tree.contentHeight + 10);
    this.treeContainer.style.height = `${i}px`, this.tree.layout(i, e ? 400 : void 0), this.editor.layoutContentWidget(this), this.scrollbar.scanDomNode();
  }
  afterRender(e) {
    e && (this.positionPreference = [e]);
  }
  hide() {
    this.showCancellationSource && (this.showCancellationSource.cancel(), this.showCancellationSource = void 0), this._isVisible && (kr(document.activeElement, this.domNode) && this.editor.focus(), this._isVisible = !1, this.highlightDecorations.clear(), this.editor.layoutContentWidget(this), this.positionPreference = [1, 2]);
  }
  getPosition() {
    return this._isVisible ? {
      position: this.showAtPosition,
      preference: this.positionPreference
    } : null;
  }
  dispose() {
    this.toDispose = z(this.toDispose);
  }
};
Ge.ID = "debug.hoverWidget";
Ge._HOVER_HIGHLIGHT_DECORATION_OPTIONS = Lc.register({
  description: "bdebug-hover-highlight",
  className: "hoverHighlight"
});
Ge = E([
  g(1, w),
  g(2, re)
], Ge);
class Ah {
  getWidgetAriaLabel() {
    return c("treeAriaLabel", "Debug Hover");
  }
  getAriaLabel(e) {
    return c(
      { key: "variableAriaLabel", comment: ["Do not translate placeholders. Placeholders are name and value of a variable."] },
      "{0}, value {1}, variables, debug",
      e.name,
      e.value
    );
  }
}
class Lh {
  hasChildren(e) {
    return e.hasChildren;
  }
  getChildren(e) {
    return e.getChildren();
  }
}
class Mh {
  getHeight(e) {
    return 18;
  }
  getTemplateId(e) {
    return Ct.ID;
  }
}
let In = class {
  constructor(e, t, i, n) {
    this.editor = e, this.debugService = t, this.languageFeaturesService = i, this.logService = n;
  }
  async compute(e, t) {
    if (!this.debugService.getViewModel().focusedSession || !this.editor.hasModel())
      return { rangeChanged: !1 };
    const n = this.editor.getModel(), s = await Oc(this.languageFeaturesService, n, e, t);
    if (!s)
      return { rangeChanged: !1 };
    const { range: o, matchingExpression: r } = s, a = this._currentRange ? !this._currentRange.equalsRange(o) : !0;
    return this._currentExpression = r, this._currentRange = K.lift(o), { rangeChanged: a, range: this._currentRange };
  }
  async evaluate(e) {
    if (!this._currentExpression) {
      this.logService.error("No expression to evaluate");
      return;
    }
    if (e.capabilities.supportsEvaluateForHovers) {
      const t = new $(this._currentExpression);
      return await t.evaluate(e, this.debugService.getViewModel().focusedStackFrame, "hover"), t;
    } else {
      const t = this.debugService.getViewModel().focusedStackFrame;
      if (t)
        return await Th(t, ss(this._currentExpression.split(".").map((i) => i.trim())));
    }
  }
};
In = E([
  g(1, w),
  g(2, Nt),
  g(3, It)
], In);
const bt = O, Nh = B("debugExceptionWidget.border", { dark: "#a31515", light: "#a31515", hcDark: "#a31515", hcLight: "#a31515" }, c("debugExceptionWidgetBorder", "Exception widget border color.")), Rh = B("debugExceptionWidget.background", { dark: "#420b0d", light: "#f1dfde", hcDark: "#420b0d", hcLight: "#f1dfde" }, c("debugExceptionWidgetBackground", "Exception widget background color."));
let _n = class extends hr {
  constructor(e, t, i, n, s) {
    super(e, { showFrame: !0, showArrow: !0, isAccessible: !0, frameWidth: 1, className: "exception-widget-container" }), this.exceptionInfo = t, this.debugSession = i, this.instantiationService = s, this.applyTheme(n.getColorTheme()), this._disposables.add(n.onDidColorThemeChange(this.applyTheme.bind(this))), this.create();
    const o = new fe(() => this._doLayout(void 0, void 0), 50);
    this._disposables.add(this.editor.onDidLayoutChange(() => o.schedule())), this._disposables.add(o);
  }
  applyTheme(e) {
    this.backgroundColor = e.getColor(Rh);
    const t = e.getColor(Nh);
    this.style({
      arrowColor: t,
      frameColor: t
    });
  }
  _applyStyles() {
    this.container && (this.container.style.backgroundColor = this.backgroundColor ? this.backgroundColor.toString() : ""), super._applyStyles();
  }
  _fillContainer(e) {
    this.setCssClass("exception-widget");
    const t = this.editor.getOption(48);
    e.style.fontSize = `${t.fontSize}px`, e.style.lineHeight = `${t.lineHeight}px`, e.tabIndex = 0;
    const i = bt(".title"), n = bt(".label");
    k(i, n);
    const s = bt(".actions");
    k(i, s), n.textContent = this.exceptionInfo.id ? c(
      "exceptionThrownWithId",
      "Exception has occurred: {0}",
      this.exceptionInfo.id
    ) : c("exceptionThrown", "Exception has occurred.");
    let o = n.textContent;
    if (new ut(s).push(new J("editor.closeExceptionWidget", c("close", "Close"), C.asClassName(Pc), !0, async () => {
      const a = this.editor.getContribution(Cr);
      a == null || a.closeExceptionWidget();
    }), { label: !1, icon: !0 }), k(e, i), this.exceptionInfo.description) {
      const a = bt(".description");
      a.textContent = this.exceptionInfo.description, o += ", " + this.exceptionInfo.description, k(e, a);
    }
    if (this.exceptionInfo.details && this.exceptionInfo.details.stackTrace) {
      const a = bt(".stack-trace"), l = this.instantiationService.createInstance(ti).linkify(this.exceptionInfo.details.stackTrace, !0, this.debugSession ? this.debugSession.root : void 0);
      a.appendChild(l), k(e, a), o += ", " + this.exceptionInfo.details.stackTrace;
    }
    e.setAttribute("aria-label", o);
  }
  _doLayout(e, t) {
    this.container.style.height = "initial";
    const i = this.editor.getOption(64), n = Math.round(i / 3), s = Math.ceil((this.container.offsetHeight + n) / i);
    this._relayout(s);
  }
  focus() {
    var e;
    (e = this.container) == null || e.focus();
  }
  hasFocus() {
    return kr(document.activeElement, this.container);
  }
};
_n = E([
  g(3, Mt),
  g(4, re)
], _n);
const Oh = 100, yo = 150, Ph = 500, Do = 200;
B("editor.inlineValuesForeground", {
  dark: "#ffffff80",
  light: "#00000080",
  hcDark: "#ffffff80",
  hcLight: "#00000080"
}, c("editor.inlineValuesForeground", "Color for the debug inline value text."));
B("editor.inlineValuesBackground", {
  dark: "#ffc80033",
  light: "#ffc80033",
  hcDark: "#ffc80033",
  hcLight: "#ffc80033"
}, c(
  "editor.inlineValuesBackground",
  "Color for the debug inline value background."
));
class Fh {
  constructor(e, t) {
    this.column = e, this.text = t;
  }
}
function aa(d, e, t = 1073741824) {
  return e.length > yo && (e = e.substring(0, yo) + "..."), [
    {
      range: {
        startLineNumber: d,
        endLineNumber: d,
        startColumn: t,
        endColumn: t
      },
      options: {
        description: "debug-inline-value-decoration-spacer",
        after: {
          content: ui,
          cursorStops: Qs.None
        },
        showIfCollapsed: !0
      }
    },
    {
      range: {
        startLineNumber: d,
        endLineNumber: d,
        startColumn: t,
        endColumn: t
      },
      options: {
        description: "debug-inline-value-decoration",
        after: {
          content: Vh(e),
          inlineClassName: "debug-inline-value",
          inlineClassNameAffectsLetterSpacing: !0,
          cursorStops: Qs.None
        },
        showIfCollapsed: !0
      }
    }
  ];
}
function Vh(d) {
  return d.replace(/[ \t]/g, ui);
}
function Wh(d, e, t, i) {
  const n = /* @__PURE__ */ new Map();
  for (const r of d)
    if (n.set(r.name, r.value), n.size >= Oh)
      break;
  const s = /* @__PURE__ */ new Map();
  n.forEach((r, a) => {
    const u = i.get(a);
    if (u)
      for (const l of u)
        e.containsPosition(new es(l, 0)) && (s.has(l) || s.set(l, []), s.get(l).indexOf(a) === -1 && s.get(l).push(a));
  });
  const o = [];
  return s.forEach((r, a) => {
    const u = r.sort((l, h) => {
      const p = t.getLineContent(a);
      return p.indexOf(l) - p.indexOf(h);
    }).map((l) => `${l} = ${n.get(l)}`).join(", ");
    o.push(...aa(a, u));
  }), o;
}
function Uh(d) {
  const e = /* @__PURE__ */ new Map();
  if (!d)
    return e;
  for (let t = 1, i = d.getLineCount(); t <= i; ++t) {
    const n = d.getLineContent(t);
    if (n.length > Ph)
      continue;
    d.tokenization.forceTokenization(t);
    const s = d.tokenization.getLineTokens(t);
    for (let o = 0, r = s.getCount(); o < r; o++)
      if (s.getStandardTokenType(o) === 0) {
        Zs.lastIndex = 0;
        const u = s.getStartOffset(o), l = s.getEndOffset(o), h = n.substring(u, l), p = Zs.exec(h);
        if (p) {
          const f = p[0];
          e.has(f) || e.set(f, []), e.get(f).push(t);
        }
      }
  }
  return e;
}
let Se = class {
  constructor(e, t, i, n, s, o, r, a, u, l) {
    this.editor = e, this.debugService = t, this.instantiationService = i, this.commandService = n, this.configurationService = s, this.hostService = o, this.uriIdentityService = r, this.languageFeaturesService = u, this.hoverPosition = null, this.mouseDown = !1, this.gutterIsHovered = !1, this.altPressed = !1, this.oldDecorations = this.editor.createDecorationsCollection(), this._wordToLineNumbersMap = void 0, this.debounceInfo = l.for(u.inlineValuesProvider, "InlineValues", { min: Do }), this.hoverWidget = this.instantiationService.createInstance(Ge, this.editor), this.toDispose = [], this.registerListeners(), this.exceptionWidgetVisible = Vc.bindTo(a), this.toggleExceptionWidget();
  }
  registerListeners() {
    this.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame((e) => this.onFocusStackFrame(e.stackFrame))), this.toDispose.push(this.editor.onMouseDown((e) => this.onEditorMouseDown(e))), this.toDispose.push(this.editor.onMouseUp(() => this.mouseDown = !1)), this.toDispose.push(this.editor.onMouseMove((e) => this.onEditorMouseMove(e))), this.toDispose.push(this.editor.onMouseLeave((e) => {
      const t = this.hoverWidget.getDomNode();
      if (!t)
        return;
      const i = t.getBoundingClientRect();
      (e.event.posx < i.left || e.event.posx > i.right || e.event.posy < i.top || e.event.posy > i.bottom) && this.hideHoverWidget();
    })), this.toDispose.push(this.editor.onKeyDown((e) => this.onKeyDown(e))), this.toDispose.push(this.editor.onDidChangeModelContent(() => {
      this._wordToLineNumbersMap = void 0, this.updateInlineValuesScheduler.schedule();
    })), this.toDispose.push(this.debugService.getViewModel().onWillUpdateViews(() => this.updateInlineValuesScheduler.schedule())), this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(() => this.updateInlineValuesScheduler.schedule())), this.toDispose.push(this.editor.onDidChangeModel(async () => {
      this.updateHoverConfiguration(), this.toggleExceptionWidget(), this.hideHoverWidget(), this._wordToLineNumbersMap = void 0;
      const e = this.debugService.getViewModel().focusedStackFrame;
      await this.updateInlineValueDecorations(e);
    })), this.toDispose.push(this.editor.onDidScrollChange(() => {
      this.hideHoverWidget();
      const e = this.editor.getModel();
      e && this.languageFeaturesService.inlineValuesProvider.has(e) && this.updateInlineValuesScheduler.schedule();
    })), this.toDispose.push(this.debugService.onDidChangeState((e) => {
      e !== 2 && this.toggleExceptionWidget();
    }));
  }
  get wordToLineNumbersMap() {
    return this._wordToLineNumbersMap || (this._wordToLineNumbersMap = Uh(this.editor.getModel())), this._wordToLineNumbersMap;
  }
  updateHoverConfiguration() {
    const e = this.debugService.getViewModel().focusedStackFrame, t = this.editor.getModel();
    t && this.applyHoverConfiguration(t, e);
  }
  applyHoverConfiguration(e, t) {
    var i;
    t && this.uriIdentityService.extUri.isEqual(e.uri, t.source.uri) ? (this.altListener && this.altListener.dispose(), this.altListener = H(document, "keydown", (n) => {
      if (new We(n).keyCode === 6) {
        this.altPressed = !0;
        const o = this.hoverWidget.isVisible();
        if (this.hoverWidget.hide(), this.enableEditorHover(), o && this.hoverPosition) {
          const u = this.editor.getContribution(Wc.ID), l = new K(
            this.hoverPosition.lineNumber,
            this.hoverPosition.column,
            this.hoverPosition.lineNumber,
            this.hoverPosition.column
          );
          u == null || u.showContentHover(l, 1, 0, !1);
        }
        const r = new or(document, "keyup"), a = ne.any(this.hostService.onDidChangeFocus, r.event)((u) => {
          let l;
          u instanceof KeyboardEvent && (l = new We(u)), (!l || l.keyCode === 6) && (this.altPressed = !1, this.editor.updateOptions({ hover: { enabled: !1 } }), a.dispose(), r.dispose());
        });
      }
    }), this.editor.updateOptions({ hover: { enabled: !1 } })) : ((i = this.altListener) == null || i.dispose(), this.enableEditorHover());
  }
  enableEditorHover() {
    if (this.editor.hasModel()) {
      const e = this.editor.getModel(), t = {
        resource: e.uri,
        overrideIdentifier: e.getLanguageId()
      }, i = this.configurationService.getValue("editor.hover", t);
      this.editor.updateOptions({
        hover: {
          enabled: i.enabled,
          delay: i.delay,
          sticky: i.sticky
        }
      });
    }
  }
  async showHover(e, t) {
    const i = this.debugService.getViewModel().focusedStackFrame, n = this.editor.getModel();
    if (i && n && this.uriIdentityService.extUri.isEqual(i.source.uri, n.uri) && !this.altPressed)
      return this.hoverWidget.showAt(e, t);
  }
  async onFocusStackFrame(e) {
    const t = this.editor.getModel();
    t && (this.applyHoverConfiguration(t, e), e && this.uriIdentityService.extUri.isEqual(e.source.uri, t.uri) ? await this.toggleExceptionWidget() : this.hideHoverWidget()), await this.updateInlineValueDecorations(e);
  }
  get showHoverScheduler() {
    const e = this.editor.getOption(58), t = new fe(() => {
      this.hoverPosition && this.showHover(this.hoverPosition, !1);
    }, e.delay * 2);
    return this.toDispose.push(t), t;
  }
  get hideHoverScheduler() {
    const e = new fe(() => {
      this.hoverWidget.isHovered() || this.hoverWidget.hide();
    }, 0);
    return this.toDispose.push(e), e;
  }
  hideHoverWidget() {
    !this.hideHoverScheduler.isScheduled() && this.hoverWidget.willBeVisible() && this.hideHoverScheduler.schedule(), this.showHoverScheduler.cancel();
  }
  onEditorMouseDown(e) {
    this.mouseDown = !0, !(e.target.type === 9 && e.target.detail === Ge.ID) && this.hideHoverWidget();
  }
  onEditorMouseMove(e) {
    if (this.debugService.state !== 2)
      return;
    const t = e.target, i = Ce ? "metaKey" : "ctrlKey";
    this.altPressed || (t.type === 2 ? (this.editor.updateOptions({ hover: { enabled: !0 } }), this.gutterIsHovered = !0) : this.gutterIsHovered && (this.gutterIsHovered = !1, this.updateHoverConfiguration())), !(t.type === 9 && t.detail === Ge.ID && !e.event[i]) && (t.type === 6 ? t.position && !es.equals(t.position, this.hoverPosition) && (this.hoverPosition = t.position, this.hideHoverScheduler.cancel(), this.showHoverScheduler.schedule()) : this.mouseDown || this.hideHoverWidget());
  }
  onKeyDown(e) {
    const t = Ce ? 57 : 5;
    e.keyCode !== t && this.hideHoverWidget();
  }
  async toggleExceptionWidget() {
    const e = this.editor.getModel(), t = this.debugService.getViewModel().focusedStackFrame, i = t ? t.thread.getCallStack() : null;
    if (!e || !t || !i || i.length === 0) {
      this.closeExceptionWidget();
      return;
    }
    const n = i.find((o) => !!(o && o.source && o.source.available && o.source.presentationHint !== "deemphasize"));
    if (!n || n !== t) {
      this.closeExceptionWidget();
      return;
    }
    const s = this.uriIdentityService.extUri.isEqual(n.source.uri, e.uri);
    if (this.exceptionWidget && !s)
      this.closeExceptionWidget();
    else if (s) {
      const o = await t.thread.exceptionInfo;
      o && this.showExceptionWidget(o, this.debugService.getViewModel().focusedSession, n.range.startLineNumber, n.range.startColumn);
    }
  }
  showExceptionWidget(e, t, i, n) {
    this.exceptionWidget && this.exceptionWidget.dispose(), this.exceptionWidget = this.instantiationService.createInstance(_n, this.editor, e, t), this.exceptionWidget.show({ lineNumber: i, column: n }, 0), this.exceptionWidget.focus(), this.editor.revealRangeInCenter({
      startLineNumber: i,
      startColumn: n,
      endLineNumber: i,
      endColumn: n
    }), this.exceptionWidgetVisible.set(!0);
  }
  closeExceptionWidget() {
    if (this.exceptionWidget) {
      const e = this.exceptionWidget.hasFocus();
      this.exceptionWidget.dispose(), this.exceptionWidget = void 0, this.exceptionWidgetVisible.set(!1), e && this.editor.focus();
    }
  }
  async addLaunchConfiguration() {
    const e = this.editor.getModel();
    if (!e)
      return;
    let t, i;
    const n = () => {
      let o = 0;
      $c(e.getValue(), {
        onObjectProperty: (r) => {
          i = r;
        },
        onArrayBegin: (r) => {
          i === "configurations" && o === 0 && (t = e.getPositionAt(r + 1)), o++;
        },
        onArrayEnd: () => {
          o--;
        }
      });
    };
    if (n(), !t) {
      const { tabSize: o, insertSpaces: r } = e.getOptions(), a = e.getEOL(), u = Uc(e.uri.fsPath) === "launch.json" ? Js(e.getValue(), ["configurations"], [], { tabSize: o, insertSpaces: r, eol: a })[0] : Js(e.getValue(), ["launch"], { configurations: [] }, { tabSize: o, insertSpaces: r, eol: a })[0], l = e.getPositionAt(u.offset), h = l.lineNumber, p = new K(
        h,
        l.column,
        h,
        e.getLineMaxColumn(h)
      );
      e.pushEditOperations(null, [yr.replace(p, u.content)], () => null), n();
    }
    if (!t)
      return;
    this.editor.focus(), await ((o) => (e.getLineLastNonWhitespaceColumn(o.lineNumber) > o.column && (this.editor.setPosition(o), qc.LineBreakInsert.runEditorCommand(null, this.editor, null)), this.editor.setPosition(o), this.commandService.executeCommand("editor.action.insertLineAfter")))(t), await this.commandService.executeCommand("editor.action.triggerSuggest");
  }
  get removeInlineValuesScheduler() {
    return new fe(() => {
      this.oldDecorations.clear();
    }, 100);
  }
  get updateInlineValuesScheduler() {
    const e = this.editor.getModel();
    return new fe(
      async () => await this.updateInlineValueDecorations(this.debugService.getViewModel().focusedStackFrame),
      e ? this.debounceInfo.get(e) : Do
    );
  }
  async updateInlineValueDecorations(e) {
    const t = "{0} = {1}", i = ", ", n = this.editor.getModel(), s = this.configurationService.getValue("debug").inlineValues;
    if (!(s === !0 || s === "on" || s === "auto" && n && this.languageFeaturesService.inlineValuesProvider.has(n)) || !n || !e || n.uri.toString() !== e.source.uri.toString()) {
      this.removeInlineValuesScheduler.isScheduled() || this.removeInlineValuesScheduler.schedule();
      return;
    }
    this.removeInlineValuesScheduler.cancel();
    let r;
    if (this.languageFeaturesService.inlineValuesProvider.has(n)) {
      const a = async (S, N) => {
        const P = await e.getMostSpecificScopes(e.range), L = N ? S : S.toLowerCase();
        for (const V of P) {
          const T = (await V.getChildren()).find((ie) => N ? ie.name === L : ie.name.toLowerCase() === L);
          if (T)
            return T.value;
        }
      }, u = {
        frameId: e.frameId,
        stoppedLocation: new K(
          e.range.startLineNumber,
          e.range.startColumn + 1,
          e.range.endLineNumber,
          e.range.endColumn + 1
        )
      }, l = new Me().token, h = this.editor.getVisibleRangesPlusViewportAboveBelow(), p = this.languageFeaturesService.inlineValuesProvider.ordered(n).reverse();
      r = [];
      const f = /* @__PURE__ */ new Map(), b = Uo(p.map((S) => h.map(
        (N) => Promise.resolve(S.provideInlineValues(n, N, u, l)).then(async (P) => {
          if (P)
            for (const L of P) {
              let V;
              switch (L.type) {
                case "text":
                  V = L.text;
                  break;
                case "variable": {
                  let _ = L.variableName;
                  _ || (_ = n.getLineContent(L.range.startLineNumber).substring(L.range.startColumn - 1, L.range.endColumn - 1));
                  const T = await a(_, L.caseSensitiveLookup);
                  T && (V = Ys(t, _, T));
                  break;
                }
                case "expression": {
                  let _ = L.expression;
                  if (_ || (_ = n.getLineContent(L.range.startLineNumber).substring(L.range.startColumn - 1, L.range.endColumn - 1)), _) {
                    const T = new $(_);
                    await T.evaluate(e.thread.session, e, "watch", !0), T.available && (V = Ys(t, _, T.value));
                  }
                  break;
                }
              }
              if (V) {
                const _ = L.range.startLineNumber;
                let T = f.get(_);
                T || (T = [], f.set(_, T)), T.some((ie) => ie.text === V) || T.push(new Fh(L.range.startColumn, V));
              }
            }
        }, (P) => {
          Hc(P);
        })
      ))), m = Date.now();
      await Promise.all(b), this.updateInlineValuesScheduler.delay = this.debounceInfo.update(n, Date.now() - m), f.forEach((S, N) => {
        if (S.length > 0) {
          S = S.sort((L, V) => L.column - V.column);
          const P = S.map((L) => L.text).join(i);
          r.push(...aa(N, P));
        }
      });
    } else {
      const a = await e.getMostSpecificScopes(e.range), u = await Promise.all(a.map(async (l) => {
        const h = await l.getChildren();
        let p = new K(0, 0, e.range.startLineNumber, e.range.startColumn);
        return l.range && (p = p.setStartPosition(l.range.startLineNumber, l.range.startColumn)), Wh(h, p, n, this.wordToLineNumbersMap);
      }));
      r = Le(
        u.reduce((l, h) => l.concat(h), []),
        (l) => {
          var h;
          return `${l.range.startLineNumber}:${(h = l == null ? void 0 : l.options.after) == null ? void 0 : h.content}`;
        }
      );
    }
    this.oldDecorations.set(r);
  }
  dispose() {
    this.hoverWidget && this.hoverWidget.dispose(), this.configurationWidget && this.configurationWidget.dispose(), this.toDispose = z(this.toDispose), this.oldDecorations.clear();
  }
};
Se.__decorator = E([
  Ot
], Se.prototype, "showHoverScheduler", null);
Se.__decorator = E([
  Ot
], Se.prototype, "hideHoverScheduler", null);
Se.__decorator = E([
  Ot
], Se.prototype, "removeInlineValuesScheduler", null);
Se.__decorator = E([
  Ot
], Se.prototype, "updateInlineValuesScheduler", null);
Se = E([
  g(1, w),
  g(2, re),
  g(3, _e),
  g(4, G),
  g(5, jo),
  g(6, Je),
  g(7, W),
  g(8, Nt),
  g(9, Fc)
], Se);
let xn = class extends wr {
  constructor(e, t, i, n) {
    super(fs, {
      noResultsPick: {
        label: c("noDebugResults", "No matching launch configurations")
      }
    }), this.debugService = e, this.contextService = t, this.commandService = i, this.notificationService = n;
  }
  async _getPicks(e) {
    var r, a;
    const t = [];
    if (!this.debugService.getAdapterManager().hasEnabledDebuggers())
      return [];
    t.push({ type: "separator", label: "launch.json" });
    const i = this.debugService.getConfigurationManager();
    let n;
    for (const u of i.getAllConfigurations()) {
      const l = qe(e, u.name, !0);
      l && (n !== ((r = u.presentation) == null ? void 0 : r.group) && (t.push({ type: "separator" }), n = (a = u.presentation) == null ? void 0 : a.group), t.push({
        label: u.name,
        description: this.contextService.getWorkbenchState() === 3 ? u.launch.name : "",
        highlights: { label: l },
        buttons: [{
          iconClass: C.asClassName(jr),
          tooltip: c("customizeLaunchConfig", "Configure Launch Configuration")
        }],
        trigger: () => (u.launch.openConfigFile({ preserveFocus: !1 }), eo.CLOSE_PICKER),
        accept: async () => {
          await i.selectConfiguration(u.launch, u.name);
          try {
            await this.debugService.startDebugging(u.launch, void 0, { startedByUser: !0 });
          } catch (h) {
            this.notificationService.error(h);
          }
        }
      }));
    }
    const s = await i.getDynamicProviders();
    s.length > 0 && t.push({
      type: "separator",
      label: c({
        key: "contributed",
        comment: ["contributed is lower case because it looks better like that in UI. Nothing preceeds it. It is a name of the grouping of debug configurations."]
      }, "contributed")
    }), i.getRecentDynamicConfigurations().forEach(({ name: u, type: l }) => {
      const h = qe(e, u, !0);
      h && t.push({
        label: u,
        highlights: { label: h },
        buttons: [{
          iconClass: C.asClassName(cl),
          tooltip: c("removeLaunchConfig", "Remove Launch Configuration")
        }],
        trigger: () => (i.removeRecentDynamicConfigurations(u, l), eo.CLOSE_PICKER),
        accept: async () => {
          await i.selectConfiguration(void 0, u, void 0, { type: l });
          try {
            const { launch: p, getConfig: f } = i.selectedConfiguration, b = await f();
            await this.debugService.startDebugging(p, b, { startedByUser: !0 });
          } catch (p) {
            this.notificationService.error(p);
          }
        }
      });
    }), s.forEach((u) => {
      t.push({
        label: `$(folder) ${u.label}...`,
        ariaLabel: c(
          { key: "providerAriaLabel", comment: ['Placeholder stands for the provider label. For example "NodeJS".'] },
          "{0} contributed configurations",
          u.label
        ),
        accept: async () => {
          const l = await u.pick();
          l && (await i.selectConfiguration(l.launch, l.config.name, l.config, { type: u.type }), this.debugService.startDebugging(l.launch, l.config, { startedByUser: !0 }));
        }
      });
    });
    const o = i.getLaunches().filter((u) => !u.hidden);
    o.length > 0 && t.push({ type: "separator", label: c("configure", "configure") });
    for (const u of o) {
      const l = this.contextService.getWorkbenchState() === 3 ? c("addConfigTo", "Add Config ({0})...", u.name) : c("addConfiguration", "Add Configuration...");
      t.push({
        label: l,
        description: this.contextService.getWorkbenchState() === 3 ? u.name : "",
        highlights: { label: vr(qe(e, l, !0)) },
        accept: () => this.commandService.executeCommand(os, u.uri.toString())
      });
    }
    return t;
  }
};
xn = E([
  g(0, w),
  g(1, Qe),
  g(2, _e),
  g(3, Re)
], xn);
let Bn = class extends Xn {
  get onDidChangeDropdownVisibility() {
    return this._dropdown.onDidChangeVisibility;
  }
  constructor(e, t, i, n, s, o, r, a, u, l) {
    var h;
    super(null, e), this._contextMenuProvider = s, this._options = o, this._container = null, this._dropdownContainer = null, this._primaryAction = new Kc(
      e,
      void 0,
      r,
      a,
      u,
      l,
      s
    ), this._dropdown = new to(t, i, this._contextMenuProvider, {
      menuAsChild: !0,
      classNames: n ? ["codicon", "codicon-chevron-down", n] : ["codicon", "codicon-chevron-down"],
      keybindingProvider: (h = this._options) == null ? void 0 : h.getKeyBinding
    });
  }
  setActionContext(e) {
    super.setActionContext(e), this._primaryAction.setActionContext(e), this._dropdown.setActionContext(e);
  }
  render(e) {
    this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-primary");
    const t = O(".action-container");
    this._primaryAction.render(k(this._container, t)), this._dropdownContainer = O(".dropdown-action-container"), this._dropdown.render(k(this._container, this._dropdownContainer)), this._register(H(t, Z.KEY_DOWN, (i) => {
      const n = new We(i);
      n.equals(17) && (this._primaryAction.element.tabIndex = -1, this._dropdown.focus(), n.stopPropagation());
    })), this._register(H(this._dropdownContainer, Z.KEY_DOWN, (i) => {
      var s;
      const n = new We(i);
      n.equals(15) && (this._primaryAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), (s = this._primaryAction.element) == null || s.focus(), n.stopPropagation());
    }));
  }
  focus(e) {
    e ? this._dropdown.focus() : (this._primaryAction.element.tabIndex = 0, this._primaryAction.element.focus());
  }
  blur() {
    this._primaryAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
  }
  setFocusable(e) {
    e ? this._primaryAction.element.tabIndex = 0 : (this._primaryAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
  }
  update(e, t, i) {
    this._dropdown.dispose(), this._dropdown = new to(e, t, this._contextMenuProvider, {
      menuAsChild: !0,
      classNames: ["codicon", i || "codicon-chevron-down"]
    }), this._dropdownContainer && this._dropdown.render(this._dropdownContainer);
  }
  dispose() {
    this._primaryAction.dispose(), this._dropdown.dispose(), super.dispose();
  }
};
Bn = E([
  g(6, jn),
  g(7, Re),
  g(8, W),
  g(9, Mt)
], Bn);
const Eo = O;
let Tn = class An extends Xn {
  constructor(e, t, i, n, s, o, r, a) {
    super(e, t), this.context = e, this.debugService = i, this.configurationService = n, this.commandService = s, this.contextService = o, this.keybindingService = a, this.debugOptions = [], this.selected = 0, this.providers = [], this.toDispose = [], this.selectBox = new pr(
      [],
      -1,
      r,
      Zn,
      { ariaLabel: c("debugLaunchConfigurations", "Debug Launch Configurations") }
    ), this.selectBox.setFocusable(!1), this.toDispose.push(this.selectBox), this.registerListeners();
  }
  registerListeners() {
    this.toDispose.push(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration("launch") && this.updateOptions();
    })), this.toDispose.push(this.debugService.getConfigurationManager().onDidSelectConfiguration(() => {
      this.updateOptions();
    }));
  }
  render(e) {
    var s;
    this.container = e, e.classList.add("start-debug-action-item"), this.start = k(e, Eo(C.asCSSSelector(Gr)));
    const t = (s = this.keybindingService.lookupKeybinding(this.action.id)) == null ? void 0 : s.getLabel(), i = t ? ` (${t})` : "";
    this.start.title = this.action.label + i, this.start.setAttribute("role", "button"), this.toDispose.push(H(this.start, Z.CLICK, () => {
      this.start.blur(), this.debugService.state !== 1 && this.actionRunner.run(this.action, this.context);
    })), this.toDispose.push(H(this.start, Z.MOUSE_DOWN, (o) => {
      this.action.enabled && o.button === 0 && this.start.classList.add("active");
    })), this.toDispose.push(H(this.start, Z.MOUSE_UP, () => {
      this.start.classList.remove("active");
    })), this.toDispose.push(H(this.start, Z.MOUSE_OUT, () => {
      this.start.classList.remove("active");
    })), this.toDispose.push(H(this.start, Z.KEY_DOWN, (o) => {
      const r = new We(o);
      r.equals(17) && (this.start.tabIndex = -1, this.selectBox.focus(), r.stopPropagation());
    })), this.toDispose.push(this.selectBox.onDidSelect(async (o) => {
      const r = this.debugOptions[o.index];
      (r.handler ? await r.handler() : !1) ? this.selected = o.index : this.selectBox.select(this.selected);
    }));
    const n = Eo(".configuration");
    this.selectBox.render(k(e, n)), this.toDispose.push(H(n, Z.KEY_DOWN, (o) => {
      const r = new We(o);
      r.equals(15) && (this.selectBox.setFocusable(!1), this.start.tabIndex = 0, this.start.focus(), r.stopPropagation());
    })), this.container.style.border = `1px solid ${Ke(io)}`, n.style.borderLeft = `1px solid ${Ke(io)}`, this.container.style.backgroundColor = Ke(zc), this.debugService.getConfigurationManager().getDynamicProviders().then((o) => {
      this.providers = o, this.providers.length > 0 && this.updateOptions();
    }), this.updateOptions();
  }
  setActionContext(e) {
    this.context = e;
  }
  isEnabled() {
    return !0;
  }
  focus(e) {
    e ? this.selectBox.focus() : (this.start.tabIndex = 0, this.start.focus());
  }
  blur() {
    this.start.tabIndex = -1, this.selectBox.blur(), this.container.blur();
  }
  setFocusable(e) {
    e ? this.start.tabIndex = 0 : (this.start.tabIndex = -1, this.selectBox.setFocusable(!1));
  }
  dispose() {
    this.toDispose = z(this.toDispose);
  }
  updateOptions() {
    this.selected = 0, this.debugOptions = [];
    const e = this.debugService.getConfigurationManager(), t = this.contextService.getWorkbenchState() === 3;
    let i;
    const n = [];
    e.getAllConfigurations().forEach(({ launch: s, name: o, presentation: r }) => {
      i !== (r == null ? void 0 : r.group) && (i = r == null ? void 0 : r.group, this.debugOptions.length && (this.debugOptions.push({ label: An.SEPARATOR, handler: () => Promise.resolve(!1) }), n.push(this.debugOptions.length - 1))), o === e.selectedConfiguration.name && s === e.selectedConfiguration.launch && (this.selected = this.debugOptions.length);
      const a = t ? `${o} (${s.name})` : o;
      this.debugOptions.push({
        label: a,
        handler: async () => (await e.selectConfiguration(s, o), !0)
      });
    }), e.getRecentDynamicConfigurations().slice(0, 3).forEach(({ name: s, type: o }) => {
      o === e.selectedConfiguration.type && e.selectedConfiguration.name === s && (this.selected = this.debugOptions.length), this.debugOptions.push({
        label: s,
        handler: async () => (await e.selectConfiguration(void 0, s, void 0, { type: o }), !0)
      });
    }), this.debugOptions.length === 0 && this.debugOptions.push({ label: c("noConfigurations", "No Configurations"), handler: async () => !1 }), this.debugOptions.push({ label: An.SEPARATOR, handler: () => Promise.resolve(!1) }), n.push(this.debugOptions.length - 1), this.providers.forEach((s) => {
      this.debugOptions.push({
        label: `${s.label}...`,
        handler: async () => {
          const o = await s.pick();
          return o ? (await e.selectConfiguration(o.launch, o.config.name, o.config, { type: s.type }), !0) : !1;
        }
      });
    }), e.getLaunches().filter((s) => !s.hidden).forEach((s) => {
      const o = t ? c("addConfigTo", "Add Config ({0})...", s.name) : c("addConfiguration", "Add Configuration...");
      this.debugOptions.push({
        label: o,
        handler: async () => (await this.commandService.executeCommand(os, s.uri.toString()), !1)
      });
    }), this.selectBox.setOptions(this.debugOptions.map(
      (s, o) => ({ text: s.label, isDisabled: n.indexOf(o) !== -1 })
    ), this.selected);
  }
};
Tn.SEPARATOR = "─────────";
Tn = E([
  g(2, w),
  g(3, G),
  g(4, _e),
  g(5, Qe),
  g(6, Rt),
  g(7, jn)
], Tn);
let Ln = class extends Gc {
  constructor(e, t, i, n, s) {
    super(null, e, [], -1, n, Zn, { ariaLabel: c("debugSession", "Debug Session") }), this.debugService = i, this.configurationService = s, this._register(this.debugService.getViewModel().onDidFocusSession(() => {
      const r = this.getSelectedSession();
      if (r) {
        const a = this.getSessions().indexOf(r);
        this.select(a);
      }
    })), this._register(this.debugService.onDidNewSession((r) => {
      const a = [];
      a.push(r.onDidChangeName(() => this.update())), a.push(r.onDidEndAdapter(() => z(a))), this.update();
    })), this.getSessions().forEach((r) => {
      this._register(r.onDidChangeName(() => this.update()));
    }), this._register(this.debugService.onDidEndSession(() => this.update()));
    const o = t ? this.mapFocusedSessionToSelected(t) : void 0;
    this.update(o);
  }
  getActionContext(e, t) {
    return this.getSessions()[t];
  }
  update(e) {
    e || (e = this.getSelectedSession());
    const t = this.getSessions(), i = t.map((n) => {
      const s = n.getLabel();
      return n.parentSession ? `  ${s}` : s;
    });
    this.setOptions(i.map((n) => ({ text: n })), e ? t.indexOf(e) : void 0);
  }
  getSelectedSession() {
    const e = this.debugService.getViewModel().focusedSession;
    return e ? this.mapFocusedSessionToSelected(e) : void 0;
  }
  getSessions() {
    const e = this.configurationService.getValue("debug").showSubSessionsInToolBar, t = this.debugService.getModel().getSessions();
    return e ? t : t.filter((i) => !i.parentSession);
  }
  mapFocusedSessionToSelected(e) {
    const t = this.configurationService.getValue("debug").showSubSessionsInToolBar;
    for (; e.parentSession && !t; )
      e = e.parentSession;
    return e;
  }
};
Ln = E([
  g(2, w),
  g(3, Rt),
  g(4, G)
], Ln);
const Io = "debug.actionswidgetposition", _o = "debug.actionswidgety";
let Mn = class extends jc {
  constructor(e, t, i, n, s, o, r, a, u, l) {
    super(r), this.notificationService = e, this.telemetryService = t, this.debugService = i, this.layoutService = n, this.storageService = s, this.configurationService = o, this.instantiationService = a, this.yCoordinate = 0, this.isVisible = !1, this.isBuilt = !1, this.stopActionViewItemDisposables = this._register(new oe()), this.$el = O("div.debug-toolbar"), this.$el.style.top = `${n.offset.top}px`, this.dragArea = k(this.$el, O("div.drag-area" + C.asCSSSelector(al)));
    const h = k(this.$el, O("div.action-bar-container"));
    this.debugToolBarMenu = u.createMenu(y.DebugToolBar, l), this._register(this.debugToolBarMenu), this.activeActions = [], this.actionBar = this._register(new ut(h, {
      orientation: 0,
      actionViewItemProvider: (p) => {
        if (p.id === hs)
          return this.instantiationService.createInstance(Ln, p, void 0);
        if (p.id === lt || p.id === Ft) {
          this.stopActionViewItemDisposables.clear();
          const f = this.instantiationService.invokeFunction((b) => Hh(p, this.stopActionViewItemDisposables, b));
          if (f)
            return f;
        }
        return ur(this.instantiationService, p);
      }
    })), this.updateScheduler = this._register(new fe(() => {
      var m;
      const p = this.debugService.state, f = this.configurationService.getValue("debug").toolBarLocation;
      if (p === 0 || f === "docked" || f === "hidden" || this.debugService.getModel().getSessions().every((S) => S.suppressDebugToolbar) || p === 1 && ((m = this.debugService.initializingOptions) != null && m.suppressDebugToolbar))
        return this.hide();
      const b = [];
      at(this.debugToolBarMenu, { shouldForwardArgs: !0 }, b), Xc(b, this.activeActions, (S, N) => S.id === N.id && S.enabled === N.enabled) || (this.actionBar.clear(), this.actionBar.push(b, { icon: !0, label: !1 }), this.activeActions = b), this.show();
    }, 20)), this.updateStyles(), this.registerListeners(), this.hide();
  }
  registerListeners() {
    this._register(this.debugService.onDidChangeState(() => this.updateScheduler.schedule())), this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration("debug.toolBarLocation") && this.updateScheduler.schedule();
    })), this._register(this.debugToolBarMenu.onDidChange(() => this.updateScheduler.schedule())), this._register(this.actionBar.actionRunner.onDidRun((e) => {
      e.error && !er(e.error) && this.notificationService.error(e.error), this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "debugActionsWidget" });
    })), this._register(H(window, Z.RESIZE, () => this.setCoordinates())), this._register(no(this.dragArea, (e) => {
      if (new Pi(e).detail === 2) {
        const i = this.$el.clientWidth;
        this.setCoordinates(0.5 * window.innerWidth - 0.5 * i, 0), this.storePosition();
      }
    })), this._register(Jc(this.dragArea, (e) => {
      this.dragArea.classList.add("dragged");
      const t = Yc(window, (n) => {
        const s = new Pi(n);
        s.preventDefault(), this.setCoordinates(s.posx - 14, s.posy - this.layoutService.offset.top);
      }), i = no(window, (n) => {
        this.storePosition(), this.dragArea.classList.remove("dragged"), t.dispose(), i.dispose();
      });
    })), this._register(this.layoutService.onDidChangePartVisibility(() => this.setYCoordinate())), this._register(Qc.onDidChange(() => this.setYCoordinate()));
  }
  storePosition() {
    const e = Zc(this.$el).left;
    if (e) {
      const t = parseFloat(e) / window.innerWidth;
      this.storageService.store(Io, t, 0, 1);
    }
  }
  updateStyles() {
    if (super.updateStyles(), this.$el) {
      this.$el.style.backgroundColor = this.getColor(th) || "";
      const e = this.getColor(eu);
      this.$el.style.boxShadow = e ? `0 0 8px 2px ${e}` : "";
      const t = this.getColor(tu), i = this.getColor(ih);
      t ? this.$el.style.border = `1px solid ${t}` : (this.$el.style.border = i ? `solid ${i}` : "none", this.$el.style.border = "1px 0");
    }
  }
  setYCoordinate(e = this.yCoordinate) {
    const t = this.layoutService.offset.top;
    this.$el.style.top = `${t + e}px`, this.yCoordinate = e;
  }
  setCoordinates(e, t) {
    if (!this.isVisible)
      return;
    const i = this.$el.clientWidth;
    if (e === void 0) {
      const s = this.storageService.get(Io, 0);
      e = s !== void 0 ? parseFloat(s) * window.innerWidth : 0.5 * window.innerWidth - 0.5 * i;
    }
    e = Math.max(0, Math.min(e, window.innerWidth - i)), this.$el.style.left = `${e}px`, t === void 0 && (t = this.storageService.getNumber(_o, 0, 0));
    const n = 35;
    if (t < n / 2 || t > n + n / 2) {
      const s = t < n;
      this.setYCoordinate(s ? 0 : n), this.storageService.store(_o, s ? 0 : 2 * n, 0, 1);
    }
  }
  show() {
    if (this.isVisible) {
      this.setCoordinates();
      return;
    }
    this.isBuilt || (this.isBuilt = !0, this.layoutService.container.appendChild(this.$el)), this.isVisible = !0, iu(this.$el), this.setCoordinates();
  }
  hide() {
    this.isVisible = !1, nu(this.$el);
  }
  dispose() {
    var e;
    super.dispose(), (e = this.$el) == null || e.remove();
  }
};
Mn = E([
  g(0, Re),
  g(1, Bt),
  g(2, w),
  g(3, Zo),
  g(4, ri),
  g(5, G),
  g(6, Mt),
  g(7, re),
  g(8, Lt),
  g(9, W)
], Mn);
function Hh(d, e, t) {
  const i = t.get(Lt), n = t.get(W), s = t.get(re), o = t.get(At), r = i.createMenu(y.DebugToolBarStop, n), a = [];
  if (at(r, { shouldForwardArgs: !0 }, a), !a.length)
    return;
  const u = e.add(new J("notebook.moreRunActions", c("notebook.moreRunActionsLabel", "More..."), "codicon-chevron-down", !0));
  return s.createInstance(Bn, d, u, a, "debug-stop-actions", o, {});
}
const Nn = [], we = (d, e, t, i, n, s, o) => {
  F.appendMenuItem(y.DebugToolBar, {
    group: "navigation",
    when: n,
    order: t,
    command: {
      id: d,
      title: e,
      icon: i,
      precondition: s
    },
    alt: o
  }), Nn.push(F.appendMenuItem(y.ViewContainerTitle, {
    group: "navigation",
    when: A.and(n, A.equals("viewContainer", di), q.notEqualsTo("inactive"), A.equals("config.debug.toolBarLocation", "docked")),
    order: t,
    command: {
      id: d,
      title: e,
      icon: i,
      precondition: s
    }
  }));
};
F.onDidChangeMenu((d) => {
  if (d.has(y.DebugToolBar)) {
    z(Nn);
    const e = F.getMenuItems(y.DebugToolBar);
    for (const t of e)
      Nn.push(F.appendMenuItem(y.ViewContainerTitle, {
        ...t,
        when: A.and(t.when, A.equals("viewContainer", di), q.notEqualsTo("inactive"), A.equals("config.debug.toolBarLocation", "docked"))
      }));
  }
});
we(ls, il, 10, en, q.isEqualTo("stopped"));
we(Ar, el, 10, Zi, q.notEqualsTo("stopped"), q.isEqualTo("running"));
we(lt, ps, 70, St, me.toNegated(), void 0, { id: Ft, title: gs, icon: ze, precondition: A.and(me.toNegated(), ot) });
we(Ft, gs, 70, ze, me, void 0, { id: lt, title: ps, icon: St, precondition: A.and(me, ot) });
we(ds, Yu, 20, Yi, void 0, q.isEqualTo("stopped"));
we(cs, Qu, 30, Kt, void 0, q.isEqualTo("stopped"));
we(us, Zu, 40, zt, void 0, q.isEqualTo("stopped"));
we(as, Ju, 60, Ji);
we(Tr, c("stepBackDebug", "Step Back"), 50, Qi, Gn, q.isEqualTo("stopped"));
we(Br, c("reverseContinue", "Reverse"), 55, tn, Gn, q.isEqualTo("stopped"));
we(hs, nl, 100, void 0, Yo);
F.appendMenuItem(y.DebugToolBarStop, {
  group: "navigation",
  when: A.and(me.toNegated(), ot),
  order: 0,
  command: {
    id: Ft,
    title: gs,
    icon: ze
  }
});
F.appendMenuItem(y.DebugToolBarStop, {
  group: "navigation",
  when: A.and(me, ot),
  order: 0,
  command: {
    id: lt,
    title: ps,
    icon: St
  }
});
F.appendMenuItem(y.DebugToolBarStop, {
  group: "navigation",
  when: A.or(A.and(me.toNegated(), Oi, ot), A.and(me, Oi)),
  order: 0,
  command: {
    id: Lr,
    title: tl,
    icon: ze
  }
});
let Rn = class On {
  constructor(e, t, i, n, s) {
    this.debugService = t, this.modelService = i, this.languageService = n, this.editorWorkerService = s, this.pendingUpdates = /* @__PURE__ */ new Map(), e.registerTextModelContentProvider(xe, this), On.INSTANCE = this;
  }
  dispose() {
    this.pendingUpdates.forEach((e) => e.dispose());
  }
  provideTextContent(e) {
    return this.createOrUpdateContentModel(e, !0);
  }
  static refreshDebugContent(e) {
    var t;
    (t = On.INSTANCE) == null || t.createOrUpdateContentModel(e, !1);
  }
  createOrUpdateContentModel(e, t) {
    const i = this.modelService.getModel(e);
    if (!i && !t)
      return null;
    let n;
    if (e.query) {
      const o = qt.getEncodedDebugData(e);
      n = this.debugService.getModel().getSession(o.sessionId);
    }
    if (n || (n = this.debugService.getViewModel().focusedSession), !n)
      return Promise.reject(new Go(c("unable", "Unable to resolve the resource without a debug session")));
    const s = (o) => {
      this.debugService.sourceIsNotAvailable(e);
      const r = this.languageService.createById(gr), a = o ? c(
        "canNotResolveSourceWithError",
        "Could not load source '{0}': {1}.",
        e.path,
        o
      ) : c("canNotResolveSource", "Could not load source '{0}'.", e.path);
      return this.modelService.createModel(a, r, e);
    };
    return n.loadSource(e).then((o) => {
      if (o && o.body)
        if (i) {
          const r = o.body.content, a = this.pendingUpdates.get(i.id);
          a == null || a.cancel();
          const u = new Me();
          return this.pendingUpdates.set(i.id, u), this.editorWorkerService.computeMoreMinimalEdits(i.uri, [{ text: r, range: i.getFullModelRange() }]).then((l) => (this.pendingUpdates.delete(i.id), !u.token.isCancellationRequested && l && l.length > 0 && i.applyEdits(l.map((h) => yr.replace(K.lift(h.range), h.text))), i));
        } else {
          const r = o.body.mimeType || ru(e)[0], a = this.languageService.createByMimeType(r);
          return this.modelService.createModel(o.body.content, a, e);
        }
      return s();
    }, (o) => s(o.message));
  }
};
Rn = E([
  g(0, su),
  g(1, w),
  g(2, $n),
  g(3, ni),
  g(4, ou)
], Rn);
sh();
Ee.as(Dr.Workbench).registerWorkbenchContribution(Mn, 3);
Ee.as(Dr.Workbench).registerWorkbenchContribution(Rn, 4);
Ee.as(Er.Quickaccess).registerQuickAccessProvider({
  ctor: xn,
  prefix: fs,
  contextKey: "inLaunchConfigurationsPicker",
  placeholder: c("startDebugPlaceholder", "Type the name of a launch configuration to run."),
  helpEntries: [{ description: c("startDebuggingHelp", "Start Debugging"), commandId: li }]
});
Ee.as(Er.Quickaccess).registerQuickAccessProvider({
  ctor: Cn,
  prefix: bs,
  contextKey: "inDebugConsolePicker",
  placeholder: c("tasksQuickAccessPlaceholder", "Type the name of a debug console to open."),
  helpEntries: [{ description: c("tasksQuickAccessHelp", "Show All Debug Consoles"), commandId: Nr }]
});
rt("editor.contrib.callStack", kn, 1);
rt(ci, wn, 1);
rt(Cr, Se, 2);
F.appendMenuItem(y.EditorTitle, { submenu: y.EditorTitleRun, rememberDefaultAction: !0, title: { value: c("run", "Run or Debug..."), original: "Run or Debug..." }, icon: dl, group: "navigation", order: -1 });
F.appendMenuItem(y.MenubarMainMenu, {
  submenu: y.MenubarDebugMenu,
  title: {
    value: "Run",
    original: "Run",
    mnemonicTitle: c({ key: "mRun", comment: ["&& denotes a mnemonic"] }, "&&Run")
  },
  order: 6
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "1_debug",
  command: {
    id: Wu,
    title: c(
      { key: "miStartDebugging", comment: ["&& denotes a mnemonic"] },
      "&&Start Debugging"
    )
  },
  order: 1,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "1_debug",
  command: {
    id: Uu,
    title: c(
      { key: "miRun", comment: ["&& denotes a mnemonic"] },
      "Run &&Without Debugging"
    )
  },
  order: 2,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "1_debug",
  command: {
    id: lt,
    title: c(
      { key: "miStopDebugging", comment: ["&& denotes a mnemonic"] },
      "&&Stop Debugging"
    ),
    precondition: Oe
  },
  order: 3,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "1_debug",
  command: {
    id: as,
    title: c(
      { key: "miRestart Debugging", comment: ["&& denotes a mnemonic"] },
      "&&Restart Debugging"
    ),
    precondition: Oe
  },
  order: 4,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "2_configuration",
  command: {
    id: os,
    title: c(
      { key: "miAddConfiguration", comment: ["&& denotes a mnemonic"] },
      "A&&dd Configuration..."
    )
  },
  order: 2,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "3_step",
  command: {
    id: ds,
    title: c({ key: "miStepOver", comment: ["&& denotes a mnemonic"] }, "Step &&Over"),
    precondition: q.isEqualTo("stopped")
  },
  order: 1,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "3_step",
  command: {
    id: cs,
    title: c({ key: "miStepInto", comment: ["&& denotes a mnemonic"] }, "Step &&Into"),
    precondition: q.isEqualTo("stopped")
  },
  order: 2,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "3_step",
  command: {
    id: us,
    title: c({ key: "miStepOut", comment: ["&& denotes a mnemonic"] }, "Step O&&ut"),
    precondition: q.isEqualTo("stopped")
  },
  order: 3,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "3_step",
  command: {
    id: ls,
    title: c({ key: "miContinue", comment: ["&& denotes a mnemonic"] }, "&&Continue"),
    precondition: q.isEqualTo("stopped")
  },
  order: 4,
  when: Q
});
F.appendMenuItem(y.MenubarNewBreakpointMenu, {
  group: "1_breakpoints",
  command: {
    id: rs,
    title: c(
      { key: "miInlineBreakpoint", comment: ["&& denotes a mnemonic"] },
      "Inline Breakp&&oint"
    )
  },
  order: 2,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "4_new_breakpoint",
  title: c(
    { key: "miNewBreakpoint", comment: ["&& denotes a mnemonic"] },
    "&&New Breakpoint"
  ),
  submenu: y.MenubarNewBreakpointMenu,
  order: 2,
  when: Q
});
F.appendMenuItem(y.MenubarDebugMenu, {
  group: "z_install",
  command: {
    id: "debug.installAdditionalDebuggers",
    title: c(
      { key: "miInstallAdditionalDebuggers", comment: ["&& denotes a mnemonic"] },
      "&&Install Additional Debuggers..."
    )
  },
  order: 1
});
const $h = Ee.as(au.Configuration);
$h.registerConfiguration({
  id: "debug",
  order: 20,
  title: c("debugConfigurationTitle", "Debug"),
  type: "object",
  properties: {
    "debug.allowBreakpointsEverywhere": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "allowBreakpointsEverywhere" },
        "Allow setting breakpoints in any file."
      ),
      default: !1
    },
    "debug.openExplorerOnEnd": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "openExplorerOnEnd" },
        "Automatically open the explorer view at the end of a debug session."
      ),
      default: !1
    },
    "debug.inlineValues": {
      type: "string",
      enum: ["on", "off", "auto"],
      description: c(
        { comment: ["This is the description for a setting"], key: "inlineValues" },
        "Show variable values inline in editor while debugging."
      ),
      enumDescriptions: [
        c(
          "inlineValues.on",
          "Always show variable values inline in editor while debugging."
        ),
        c(
          "inlineValues.off",
          "Never show variable values inline in editor while debugging."
        ),
        c(
          "inlineValues.focusNoScroll",
          "Show variable values inline in editor while debugging when the language supports inline value locations."
        )
      ],
      default: "auto"
    },
    "debug.toolBarLocation": {
      enum: ["floating", "docked", "hidden"],
      markdownDescription: c(
        { comment: ["This is the description for a setting"], key: "toolBarLocation" },
        "Controls the location of the debug toolbar. Either `floating` in all views, `docked` in the debug view, or `hidden`."
      ),
      default: "floating"
    },
    "debug.showInStatusBar": {
      enum: ["never", "always", "onFirstSessionStart"],
      enumDescriptions: [c("never", "Never show debug in Status bar"), c("always", "Always show debug in Status bar"), c(
        "onFirstSessionStart",
        "Show debug in Status bar only after debug was started for the first time"
      )],
      description: c(
        { comment: ["This is the description for a setting"], key: "showInStatusBar" },
        "Controls when the debug Status bar should be visible."
      ),
      default: "onFirstSessionStart"
    },
    "debug.internalConsoleOptions": Lo,
    "debug.console.closeOnEnd": {
      type: "boolean",
      description: c(
        "debug.console.closeOnEnd",
        "Controls if the Debug Console should be automatically closed when the debug session ends."
      ),
      default: !1
    },
    "debug.terminal.clearBeforeReusing": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "debug.terminal.clearBeforeReusing" },
        "Before starting a new debug session in an integrated or external terminal, clear the terminal."
      ),
      default: !1
    },
    "debug.openDebug": {
      enum: ["neverOpen", "openOnSessionStart", "openOnFirstSessionStart", "openOnDebugBreak"],
      default: "openOnDebugBreak",
      description: c("openDebug", "Controls when the debug view should open.")
    },
    "debug.showSubSessionsInToolBar": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showSubSessionsInToolBar" },
        "Controls whether the debug sub-sessions are shown in the debug tool bar. When this setting is false the stop command on a sub-session will also stop the parent session."
      ),
      default: !1
    },
    "debug.console.fontSize": {
      type: "number",
      description: c(
        "debug.console.fontSize",
        "Controls the font size in pixels in the Debug Console."
      ),
      default: Ce ? 12 : 14
    },
    "debug.console.fontFamily": {
      type: "string",
      description: c(
        "debug.console.fontFamily",
        "Controls the font family in the Debug Console."
      ),
      default: "default"
    },
    "debug.console.lineHeight": {
      type: "number",
      description: c(
        "debug.console.lineHeight",
        "Controls the line height in pixels in the Debug Console. Use 0 to compute the line height from the font size."
      ),
      default: 0
    },
    "debug.console.wordWrap": {
      type: "boolean",
      description: c(
        "debug.console.wordWrap",
        "Controls if the lines should wrap in the Debug Console."
      ),
      default: !0
    },
    "debug.console.historySuggestions": {
      type: "boolean",
      description: c(
        "debug.console.historySuggestions",
        "Controls if the Debug Console should suggest previously typed input."
      ),
      default: !0
    },
    "debug.console.collapseIdenticalLines": {
      type: "boolean",
      description: c(
        "debug.console.collapseIdenticalLines",
        "Controls if the Debug Console should collapse identical lines and show a number of occurrences with a badge."
      ),
      default: !0
    },
    "debug.console.acceptSuggestionOnEnter": {
      enum: ["off", "on"],
      description: c(
        "debug.console.acceptSuggestionOnEnter",
        "Controls whether suggestions should be accepted on Enter in the Debug Console. Enter is also used to evaluate whatever is typed in the Debug Console."
      ),
      default: "off"
    },
    launch: {
      type: "object",
      description: c(
        { comment: ["This is the description for a setting"], key: "launch" },
        "Global debug launch configuration. Should be used as an alternative to 'launch.json' that is shared across workspaces."
      ),
      default: { configurations: [], compounds: [] },
      $ref: yt
    },
    "debug.focusWindowOnBreak": {
      type: "boolean",
      description: c(
        "debug.focusWindowOnBreak",
        "Controls whether the workbench window should be focused when the debugger breaks."
      ),
      default: !0
    },
    "debug.focusEditorOnBreak": {
      type: "boolean",
      description: c(
        "debug.focusEditorOnBreak",
        "Controls whether the editor should be focused when the debugger breaks."
      ),
      default: !0
    },
    "debug.onTaskErrors": {
      enum: ["debugAnyway", "showErrors", "prompt", "abort"],
      enumDescriptions: [c("debugAnyway", "Ignore task errors and start debugging."), c("showErrors", "Show the Problems view and do not start debugging."), c("prompt", "Prompt user."), c("cancel", "Cancel debugging.")],
      description: c(
        "debug.onTaskErrors",
        "Controls what to do when errors are encountered after running a preLaunchTask."
      ),
      default: "prompt"
    },
    "debug.showBreakpointsInOverviewRuler": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showBreakpointsInOverviewRuler" },
        "Controls whether breakpoints should be shown in the overview ruler."
      ),
      default: !1
    },
    "debug.showInlineBreakpointCandidates": {
      type: "boolean",
      description: c(
        { comment: ["This is the description for a setting"], key: "showInlineBreakpointCandidates" },
        "Controls whether inline breakpoints candidate decorations should be shown in the editor while debugging."
      ),
      default: !0
    },
    "debug.saveBeforeStart": {
      description: c(
        "debug.saveBeforeStart",
        "Controls what editors to save before starting a debug session."
      ),
      enum: ["allEditorsInActiveGroup", "nonUntitledEditorsInActiveGroup", "none"],
      enumDescriptions: [
        c(
          "debug.saveBeforeStart.allEditorsInActiveGroup",
          "Save all editors in the active group before starting a debug session."
        ),
        c(
          "debug.saveBeforeStart.nonUntitledEditorsInActiveGroup",
          "Save all editors in the active group except untitled ones before starting a debug session."
        ),
        c(
          "debug.saveBeforeStart.none",
          "Don't save any editors before starting a debug session."
        )
      ],
      default: "allEditorsInActiveGroup",
      scope: 5
    },
    "debug.confirmOnExit": {
      description: c(
        "debug.confirmOnExit",
        "Controls whether to confirm when the window closes if there are active debug sessions."
      ),
      type: "string",
      enum: ["never", "always"],
      enumDescriptions: [
        c("debug.confirmOnExit.never", "Never confirm."),
        c(
          "debug.confirmOnExit.always",
          "Always confirm if there are debug sessions."
        )
      ],
      default: "never"
    },
    "debug.disassemblyView.showSourceCode": {
      type: "boolean",
      default: !0,
      description: c(
        "debug.disassemblyView.showSourceCode",
        "Show Source Code in Disassembly View."
      )
    },
    "debug.autoExpandLazyVariables": {
      type: "boolean",
      default: !1,
      description: c(
        "debug.autoExpandLazyVariables",
        "Automatically show values for variables that are lazily resolved by the debugger, such as getters."
      )
    },
    "debug.enableStatusBarColor": {
      type: "boolean",
      description: c("debug.enableStatusBarColor", "Color status bar when debugger is active"),
      default: !0
    }
  }
});
const qh = vt.prototype.showError;
vt.prototype.showError = function(d, e) {
  return qh.call(this, d, e, !1);
};
function Ig() {
  return {
    ...du(),
    [Nt.toString()]: new vi(Cl),
    [w.toString()]: new vi(vt),
    [Bo.toString()]: new vi(un)
  };
}
export {
  Ig as default
};
